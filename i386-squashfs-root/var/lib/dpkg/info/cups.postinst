#! /bin/sh
# postinst script for cups
#
# see: dh_installdeb(1)

set -e

# summary of how this script can be called:
#        * <postinst> `configure' <most-recently-configured-version>
#        * <old-postinst> `abort-upgrade' <new version>
#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#          <new-version>
#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#          <failed-install-package> <version> `removing'
#          <conflicting-package> <version>
# for details, see /usr/doc/packaging-manual/
#
# quoting from the policy:
#     Any necessary prompting should almost always be confined to the
#     post-installation script, and should be protected with a conditional
#     so that unnecessary prompting doesn't happen if a package's
#     installation fails and the `postinst' is called with `abort-upgrade',
#     `abort-remove' or `abort-deconfigure'.

# Debconf
. /usr/share/debconf/confmodule

# Default Configuration file
if [ -e /etc/default/cups ]; then
	. /etc/default/cups
fi

if [ "$1" = configure ]; then
    # Set up lpadmin group.
    if [ -z "`getent group lpadmin`" ]; then 
	addgroup --system lpadmin
    fi

    if [ -L /usr/share/ppd/cups-transitional-dir ]; then
	rm -f /usr/share/ppd/cups-transitional-dir
    fi
    if [ -L /usr/share/cups/model/cups-included ]; then
	rm -f /usr/share/cups/model/cups-included
    fi
    
    # set up custom PPD directory
    chown root:lpadmin /usr/share/ppd/custom 2>/dev/null || true
    chmod 3775 /usr/share/ppd/custom 2>/dev/null || true

    # Generate raw MIME handling files if they don't already exist.
    if [ ! -e /etc/cups/raw.types ]; then
	cat >/etc/cups/raw.types <<EOF
# This file was generated by the cups package.  You may change it, or
# reconfigure this file with dpkg-reconfigure.  If it is removed, it
# will be regenerated by the package scripts.

application/octet-stream
EOF
    fi
    if [ ! -e /etc/cups/raw.convs ]; then
	cat >/etc/cups/raw.convs <<EOF
# This file was generated by the cups package.  You may change it, or
# reconfigure this file with dpkg-reconfigure.  If it is removed, it
# will be regenerated by the package scripts.

application/octet-stream	application/vnd.cups-raw	0	-
EOF
    fi

    # Set up raw printing of application/octet-stream if desired.
    db_fget cupsys/raw-print changed
    if [ "$RET" = "true" ]; then
	mv /etc/cups/raw.convs /etc/cups/raw.convs-convert
	db_get cupsys/raw-print
	if [ "$RET" = "true" ]; then
	    sed 's/^\s*#\s*application/application/' \
		< /etc/cups/raw.convs-convert > /etc/cups/raw.convs
	else
	    sed 's/^application/#application/' \
		< /etc/cups/raw.convs-convert > /etc/cups/raw.convs
	fi
	rm -f /etc/cups/raw.convs-convert
	db_fset cupsys/raw-print changed false
    fi
    # Set up backends
    db_get cupsys/backend && SELECTED=$RET
    # We remove the scsi backend from the output as it got removed in CUPS 1.5.0
    list=`echo $SELECTED | sed -e 's/, /,/g' | sed -e 's/scsi,*//g'`
    save_IFS=$IFS
    IFS=,
    (cd /usr/lib/cups/backend && rm -f http ipp lpd parallel serial socket usb snmp dnssd)
    for module in $list; do
      ln /usr/lib/cups/backend-available/$module /usr/lib/cups/backend/$module
      if [ "$module" = "ipp" ]; then
	ln /usr/lib/cups/backend/ipp /usr/lib/cups/backend/http
      fi
    done
    IFS=$save_IFS

    # activate new backends on upgrades
    db_fset cupsys/backend changed false
    
    # Resync Debconf database with real state
    list=`( cd /usr/lib/cups/backend && for f in ipp lpd parallel serial socket usb snmp dnssd; do [ -e $f ] && echo -n "$f, "; done ) | sed -e 's/, $//'`
    db_set cupsys/backend $list;

    if [ -f /etc/cups/classes.conf ]; then
      chown root:lp /etc/cups/classes.conf ; chmod 600 /etc/cups/classes.conf
    fi
    if [ -f /etc/cups/printers.conf ]; then
      chown root:lp /etc/cups/printers.conf ; chmod 600 /etc/cups/printers.conf
    fi

    # symlink snakeoil SSL certificate if present
    if [ -e /etc/ssl/certs/ssl-cert-snakeoil.pem -a \
	  -e /etc/ssl/private/ssl-cert-snakeoil.key -a \
	  -n "`getent group ssl-cert`" -a ! -e /etc/cups/ssl/server.crt \
	  -a ! -e /etc/cups/ssl/server.key -a ! -h /etc/cups/ssl/server.crt \
	  -a ! -h /etc/cups/ssl/server.key ]; then
	 ln -s /etc/ssl/certs/ssl-cert-snakeoil.pem /etc/cups/ssl/server.crt
	 ln -s /etc/ssl/private/ssl-cert-snakeoil.key /etc/cups/ssl/server.key
    fi 

    APP_PROFILE=/etc/apparmor.d/usr.sbin.cupsd
    if [ -f "$APP_PROFILE" ]; then
        # Add the local/ include
        LOCAL_APP_PROFILE=/etc/apparmor.d/local/usr.sbin.cupsd

        test -e "$LOCAL_APP_PROFILE" || {
            tmp=`mktemp`
        cat <<EOM > "$tmp"
# Site-specific additions and overrides for usr.sbin.cupsd.
# For more details, please see /etc/apparmor.d/local/README.
EOM
            mkdir `dirname $LOCAL_APP_PROFILE` 2>/dev/null || true
            mv -f "$tmp" "$LOCAL_APP_PROFILE"
            chmod 644 "$LOCAL_APP_PROFILE"
        }

        # Reload the profile, including any abstraction updates
        if aa-status --enabled 2>/dev/null; then
            apparmor_parser -r -T -W "$APP_PROFILE" || true
        fi
    fi

    # init.d priority transition
    if dpkg --compare-versions "$2" le-nl "1.3.9-15"; then
	for l in 2 3 4 5; do
	    old=/etc/rc${l}.d/S20cups
	    new=/etc/rc${l}.d/S50cups
	    if [ -e "$old" ] && [ ! -e "$new" ]; then
		mv "$old" "$new"
	    fi
	done
    fi

    # Clear cache if we upgrade to 1.4.x
    if dpkg --compare-versions "$2" lt-nl "1.4.1-5"; then
	rm /var/cache/cups/* 2> /dev/null || :
    fi

    # Clear PPD cache if we upgrade to 1.5.x
    if dpkg --compare-versions "$2" lt-nl "1.5.0-3"; then
	rm /var/cache/cups/ppds.dat 2> /dev/null || :
    fi

    # Manage printcap file and associated symlinks
    if [ -e /etc/cups/cupsd.conf ]; then
	if [ -e /etc/printcap.cups ]; then
	    rm -f /etc/printcap.cups
	fi
	if [ -L /etc/printcap -a ! -e /etc/printcap ]; then
	    rm -f /etc/printcap
	fi

	printcap_file=`egrep '^Printcap ' /etc/cups/cupsd.conf | awk '{print $2}' | tail -n 1`
	if [ -z "$printcap_file" ]; then
	    printcap_file=/var/run/cups/printcap
	fi
	if [ ! -e /etc/printcap -a -e $printcap_file ]; then
	    ln -s $printcap_file /etc/printcap
	fi
    fi

    # Clean up after some broken cups-pdf versions
    if dpkg --compare-versions "$2" lt-nl "1.4.4-1"; then
	chmod 755 /usr/lib/cups/backend /usr/lib/cups/backend-available
    fi

    if dpkg --compare-versions "$2" lt "1.4.6-8"; then
	rmmod usblp 2>/dev/null || :
    fi
fi

# Automatically added by dh_installinit
if [ -e "/etc/init/cups.conf" ]; then
	invoke-rc.d cups start || exit $?
fi
# End automatically added section
# Automatically added by dh_usrlocal
if [ "$1" = configure ]; then
(
	while read line; do
		set -- $line
		dir="$1"; mode="$2"; user="$3"; group="$4"
		if [ ! -e "$dir" ]; then
			if mkdir "$dir" 2>/dev/null; then
				chown "$user":"$group" "$dir"
				chmod "$mode" "$dir"
			fi
		fi
	done
) << DATA
/usr/local/share 2775 root staff
/usr/local/share/ppd 2775 root staff
DATA
fi
# End automatically added section


# ppd_updater is supposed to be launched only with a running CUPS.
ppd_updater () {
	driverregexp="$1"
	gennicknameregexp="$2"

	[ ! -z "$gennicknameregexp" ] && \
	    gennicknameregexp="; $gennicknameregexp"
	gennicknameregexp='s/\s*\(recommended\)//'"$gennicknameregexp"
	tmpfile1=`mktemp -t updateppds.XXXXXX`
	tempfiles="$tempfiles $tmpfile1"
	grep -E $driverregexp $tmpfile0 > $tmpfile1 || :
	cd /etc/cups/ppd
	for ppd in *.ppd; do
	    [ -r "$ppd" ] || continue
	    queue=${ppd%.ppd}
	    lpstat -h /var/run/cups/cups.sock -p "$queue" >/dev/null 2>&1 || continue
	    nickname=`grep '\*NickName:' "$ppd" | cut -d '"' -f 2 | perl -p -e 's/\n$//' | perl -p -e "$gennicknameregexp" | perl -p -e 's/(\W)/\\\\$1/g'`
	    lang=`grep '\*LanguageVersion:' "$ppd" | cut -d ' ' -f 2 | perl -e 'print lc(<>)' | perl -p -e 's/[\r\n]//gs'`
	    ppdfound="0"
	    englishppduri=""
	    tmpfile2=`mktemp -t updateppds.XXXXXX`
	    tempfiles="$tempfiles $tmpfile2"
	    cat $tmpfile1 | perl -p -e "$gennicknameregexp; s/\n*$/\n/s" | grep -E '^\S+\s+.*'"$nickname"'$' | cut -d ' ' -f 1 > $tmpfile2
	    while read newppduri; do
		[ "$ppdfound" = "0" ] && lpadmin -h /var/run/cups/cups.sock -p "$queue" -m $newppduri 2>/dev/null || continue
		newlang=`grep '\*LanguageVersion:' "$ppd" | cut -d ' ' -f 2 | perl -e 'print lc(<>)' | perl -p -e 's/[\r\n]//gs'`
		[ "$newlang" = "$lang" ] && ppdfound="1"
		[ "$newlang" = "english" ] && englishppduri="$newppduri"
	    done < $tmpfile2
	    [ "$ppdfound" = "0" ] && [ ! -z "$englishppduri" ] && lpadmin -h /var/run/cups/cups.sock -p "$queue" -m $englishppduri 2>/dev/null && ppdfound="1"
	    [ "$ppdfound" = "1" ] && echo PPD for printer $queue updated >&2
	done
	return 0
}

# Do the following only if CUPS is running and the needed CUPS tools
# are available
if which lpstat > /dev/null 2>&1 && \
	which lpinfo > /dev/null 2>&1 && \
	which lpadmin > /dev/null 2>&1 && \
	LC_ALL=C lpstat -h /var/run/cups/cups.sock -r | grep -v not > /dev/null 2>&1; then

	tempfiles=
	trap 'rm -f $tempfiles; exit 0' 0 HUP INT QUIT ILL ABRT PIPE TERM
	tmpfile0=`mktemp -t updateppds.XXXXXX`
	tempfiles="$tempfiles $tmpfile0"

	lpinfo -h /var/run/cups/cups.sock -m > $tmpfile0

	if [ "$1" = configure ] ; then
		# Update CUPS included drivers' queues
		echo "Updating PPD files for cups ..."
		ppd_updater 'lsb/usr/cups-included/|drv:///sample.drv/' 's/,\s*\d+\.\d+[\d\.]*$//i'
	elif [ "$1" = triggered ] && [ "$2" = /usr/share/cups/ppd-updaters ] ; then
		# Update external drivers' queues.
		# 
		# We log the modification dates of the file in 
		# /usr/share/cups/ppd-updaters/* after updating the PPDs 
		# according to them. These dates are more or less the creation
		# dates of the driver packages. Then we only update the PPDs of
		# packages, where the /usr/share/cups/ppd-updaters/* file has a
		# modification date different to the logged date as this means
		# that a fresh /usr/share/cups/ppd-updaters/* file and
		# therefore a fresh package got installed. This avoids updating
		# of PPDs when the corresponding package was not changed.
	        logfile=/var/cache/cups/ppd-updates
		touch $logfile
		for driver in `ls /usr/share/cups/ppd-updaters`; do
			modtime=`ls -l --time-style=+%s /usr/share/cups/ppd-updaters/$driver | perl -p -e 's/^\s*\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+)\s+(\S+)\s*$/$1\n/'`
			oldmodtime=`cat $logfile | grep " $driver$" | cut -d ' ' -f 1`
			if [ "$modtime" != "$oldmodtime" ]; then
				echo "Updating PPD files for $driver ..."
				. /usr/share/cups/ppd-updaters/${driver}
				ppd_updater "${DRIVER_REGEXP}" "${GENNICKNAME_REGEXP}"
				cat $logfile | grep -v " $driver$" > $logfile.new || touch $logfile.new
				echo "$modtime $driver" >> $logfile.new
				mv $logfile.new $logfile
			fi
		done
	fi
fi

db_stop
exit 0
