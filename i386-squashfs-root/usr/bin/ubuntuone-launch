#!/usr/bin/python

# ubuntuone-launch - Ubuntu One storage synchronization daemon startup helper
#
# Author: John Lenton <john.lenton@canonical.com>
#
# Copyright 2010 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
Ubuntu One storage synchronization daemon (syncdaemon) startup helper.

This script decides whether to start and connect syncdaemon.

 * If you've never used Ubuntu One file sync, or if you've disabled
   file sync via Ubuntu One control panel (or equivalently via setting
   files_sync_enabled to False in the syncdaemon configuration file),
   syncdaemon is not started, and nothing happens as a result of this
   script being run.

 * otherwise if syncdaemon is not already running it is started, and
   local rescan is allowed to finish.

 * if syncdaemon has never synced to the server, or if there are no
   credentials for Ubuntu One in the keyring, nothing further happens.

 * otherwise, syncdaemon is asked to connect.

"""
import sys
import os

U1ROOT = os.path.expanduser('~/Ubuntu One/')

if __name__ == '__main__':
    # this check is done early to speed up startup on people who are not
    # (yet) using the service (this way avoids all the imports).
    if not os.path.isdir(U1ROOT):
        # no directory, just quit
        sys.exit(1)

import dbus
import glib
import gobject
from dbus.mainloop.glib import DBusGMainLoop
from ubuntuone.platform.credentials import CredentialsManagementTool
from ubuntuone.platform.tools import SyncDaemonTool, is_running
from twisted.internet import defer


def stage_two(node, sync_daemon_tool):
    """Do the last few checks and ask for a connect if all is ok."""
    # if the node_id of the root node is None, the user has never
    # connected. Do not connect in that case.
    if node.get('node_id', '') is None:
        d = defer.fail(RuntimeError("never connected?"))
    else:
        # one last check: avoid having sso pop up asking for creds if
        # the user deleted them
        creds_tools = CredentialsManagementTool()
        d = creds_tools.find_credentials()

    return d


def wait_for_ready(_, sync_daemon_tool):
    """Wait for syncdaemon to be READY."""
    d = sync_daemon_tool.wait_for_signal(
        'StatusChanged',
        lambda a: a.get('name', '') == 'READY')
    return d


def main():
    """Start syncdaemon and ask it to connect, if possible."""
    gobject.set_application_name("ubuntuone-launch")
    loop = DBusGMainLoop(set_as_default=True)
    bus = dbus.SessionBus(mainloop=loop)
    sync_daemon_tool = SyncDaemonTool(bus)

    if sync_daemon_tool.is_files_sync_enabled():
        if not is_running():
            try:
                # have SD start
                d = sync_daemon_tool.start()
                d.addBoth(wait_for_ready, sync_daemon_tool)
            except dbus.exception.DBusException, e:
                # some dbus error, shouldn't happen, bail out
                d = defer.fail(e)
        else:
            # SD is already running
            d = defer.succeed(True)
    else:
        # SD will not start (has been disabled by user)
        d = defer.fail(RuntimeError("File sync is disabled"))

    d.addCallback(lambda _: sync_daemon_tool.get_metadata(U1ROOT))
    d.addCallback(stage_two, sync_daemon_tool)
    # os._exit feels like it's cheating, but it's simple and fast
    d.addCallbacks(lambda _: os._exit(0), lambda _: os._exit(1))

    mainloop = glib.MainLoop()
    mainloop.run()


if __name__ == '__main__':
    main()
