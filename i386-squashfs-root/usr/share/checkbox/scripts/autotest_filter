#!/usr/bin/python

import re
import sys
import posixpath

from optparse import OptionParser


autotest_to_checkbox_status = {
    "TEST_NA": "unsupported",
    "ABORT": "unresolved",
    "ERROR": "unresolved",
    "FAIL": "fail",
    "WARN": "fail",
    "GOOD": "pass",
    "ALERT": "fail",
    "RUNNING": "uninitiated",
    "NOSTATUS": "untested"}


class FakeJob():

    def run_test(self, name):
        pass


def print_line(key, value):
    print "%s: %s" % (key, value)

def print_element(element):
    for key, value in element.iteritems():
        print_line(key, value)

    print

def parse_file(file):
    log_pattern = re.compile(r"\d\d:\d\d:\d\d [A-Z ]{5}\| ")
    persistent_pattern = re.compile(r"Persistent state file (?P<path>.*) does not exist")
    start_pattern = re.compile(r"\tSTART\t"
        "(?P<name1>[^\t]+)\t"
        "(?P<name2>[^\t]+)\t"
        "timestamp=(?P<timestamp>[^\t]+)\t"
        "localtime=(?P<localtime>.*)")
    end_pattern = re.compile(r"\tEND "
        "(?P<status>[^\t]+)\t"
        "(?P<name1>[^\t]+)\t"
        "(?P<name2>[^\t]+)\t"
        "timestamp=(?P<timestamp>[^\t]+)\t"
        "localtime=(?P<localtime>.*)")
    data_pattern = re.compile(r"\t")

    element = {}
    elements = []
    for line in file.readlines():
        line = log_pattern.sub("", line)

        match = persistent_pattern.match(line)
        if match:
            persistent_path = match.group("path")
            control_path = posixpath.splitext(persistent_path)[0]
            globals = {"job": FakeJob()}
            exec open(control_path) in globals

            element["description"] = globals["DOC"]

        match = start_pattern.match(line)
        if match:
            element["plugin"] = "shell"
            element["requires"] = "package.alias == 'linux'"
            element["data"] = ""
            element["name"] = match.group("name1")
            continue

        match = end_pattern.match(line)
        if match:
            element["status"] = autotest_to_checkbox_status[match.group("status")]
            elements.append(element)
            element = {}
            continue

        if data_pattern.match(line):
            element["data"] += line
            continue

    return elements

def parse_filename(filename):
    if filename == "-":
        file = sys.stdin
    else:
        file = open(filename, "r")

    return parse_file(file)

def parse_filenames(filenames):
    elements = []
    for filename in filenames:
        elements.extend(parse_filename(filename))

    return elements

def main(args):
    usage = "Usage: %prog [FILE...]"
    parser = OptionParser(usage=usage)
    parser.add_option("-s", "--suite",
        help="Suite corresponding to the tests")
    (options, args) = parser.parse_args(args)

    if not args:
        filenames = ["-"]
    else:
        filenames = args

    elements = parse_filenames(filenames)
    if not elements:
        return 1

    for element in elements:
        if options.suite:
            element["suite"] = options.suite
        print_element(element)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
