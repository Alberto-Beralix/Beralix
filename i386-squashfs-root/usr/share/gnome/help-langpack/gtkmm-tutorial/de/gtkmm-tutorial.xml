<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://docbook.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY url_refdocs_base_glib_html "http://developer.gnome.org/glibmm/unstable/">
<!ENTITY url_refdocs_base_glib "&url_refdocs_base_glib_html;classGlib_1_1">
<!ENTITY url_refdocs_base_gtk_html "http://developer.gnome.org/gtkmm/unstable/">
<!ENTITY url_refdocs_base_gtk "&url_refdocs_base_gtk_html;classGtk_1_1">
<!ENTITY url_refdocs_base_gtk_namespace "&url_refdocs_base_gtk_html;namespaceGtk_1_1">
<!ENTITY url_figures_base "figures/">
<!ENTITY url_examples_base "http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/">
<!ENTITY url_examples_branchsuffix "">
<!ENTITY gtkmm "<application>gtkmm</application>">
<!ENTITY uuml "&#252;">
<!ENTITY szlig "&#223;">
<!ENTITY verbar "&#124;">
<!ENTITY copy "&#169;">
<!ENTITY nbsp "&#160;">
]>
<!--
NOTE TO TUTORIAL DOCUMENTATION AUTHORS:
When referring to the gtkmm project in this document, please use the form
&gtkmm; so that the name is consistent throughout the document. This will wrap
gtkmm with <application></application> tags which can then be styled by CSS if
desired (e.g. boldface, monospace, etc) to make it stand out as the project
name
-->
<!-- The XSL for developer.gnome.org requires this id. -->
<book id="index" lang="de">

  <bookinfo>

    <title>Programming with <application>gtkmm</application> 3</title>

    <authorgroup>
      <author>
        <firstname>Murray</firstname>
        <surname>Cumming</surname>
      </author>
      <author>
        <firstname>Bernhard</firstname>
        <surname>Rieder</surname>
        <contrib>Chapter on "Timeouts".</contrib>
      </author>
      <author>
        <firstname>Jonathon</firstname>
        <surname>Jongsma</surname>
        <contrib>Chapter on "Drawing with Cairo".</contrib>
        <contrib>Chapter on "Working with gtkmm's Source Code".</contrib>
        <contrib>Chapter on "Recent Files".</contrib>
      </author>
      <author>
        <firstname>Ole</firstname>
        <surname>Laursen</surname>
        <contrib>Parts of chapter on "Internationalization".</contrib>
      </author>
      <author>
        <firstname>Gene</firstname>
        <surname>Ruebsamen</surname>
        <contrib>Kapitel zur »Win32-Installation«.</contrib>
      </author>
      <author>
        <firstname>Cedric</firstname>
        <surname>Gustin</surname>
        <contrib>Kapitel zur »Win32-Installation«.</contrib>
      </author>
      <author>
        <firstname>Marko</firstname>
        <surname>Anastasov</surname>
        <contrib>Kapitel zum »Drucken«</contrib>
        <contrib>Parts of chapter on "Internationalization".</contrib>
      </author>
      <author>
        <firstname>Daniel</firstname>
        <surname>Elstner</surname>
        <contrib>Section "Build Structure" of chapter
          on "Wrapping C Libraries with gmmproc".</contrib>
      </author>
    </authorgroup>

    <abstract>

      <!-- This text is copied from the introduction. -->
      <para>This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user interface elements ("widgets").
      </para>

    </abstract>

    <copyright>
      <year>2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010</year>
      <holder>Murray Cumming</holder>
    </copyright><copyright><year>2010</year><holder>Mario Blättermann (mariobl@gnome.org)</holder></copyright>

    <legalnotice>
      <para>
        Permission is granted to copy, distribute and/or modify this document
        under the terms of the GNU Free Documentation License, Version 1.2
        or any later version published by the Free Software Foundation;
        with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
        You may obtain a copy of the GNU Free Documentation License from the Free Software Foundation by visiting their Web site or by writing to: Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
      </para>
    </legalnotice>

  </bookinfo>

<chapter id="chapter-introduction">
<title>Einführung</title>

<sect1 id="sec-this-book">
<title>Dieses Buch</title>

<para>This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user interface elements ("widgets"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for full API information you should follow the links into the reference documentation.</para>

<para>This book assumes a good understanding of C++, and how to create C++ programs.</para>

<para>
We would very much like to hear of any problems you have learning <application>gtkmm</application>
with this document, and would appreciate input regarding improvements. Please see the <link linkend="chapter-contributing">Contributing</link> section for further information.
</para>
</sect1>

<sect1 id="sec-gtkmm">
<title>gtkmm</title>
<para>
<application>gtkmm</application> is a C++ wrapper for
<ulink url="http://www.gtk.org/">GTK+</ulink>,
a library used to create graphical user
interfaces. It is licensed using the LGPL license, so you can develop
open software, free software, or even commercial non-free software
using <application>gtkmm</application> without purchasing licenses.
</para>
<para><application>gtkmm</application> was originally named gtk-- because GTK+ already has a + in the name. However, as -- is not easily indexed by search engines the package generally went by the name <application>gtkmm</application>, and that's what we stuck with.</para>

<sect2 id="why-use-gtkmm">
<title>Why use <application>gtkmm</application> instead of GTK+?</title>
<para><application>gtkmm</application> allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a C++ programmer you probably already realise that this leads to clearer and better organized code.</para>
<para><application>gtkmm</application> is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration.</para>
<para>Inheritance can be used to derive new widgets. The derivation of new widgets in GTK+ C code is so complicated and error prone that almost no C coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique.</para>
<para>Member instances can be used, simplifying memory management. All GTK+ C widgets are dealt with by use of pointers. As a C++ coder you know that pointers should be avoided where possible.</para>
<para><application>gtkmm</application> involves less code compared to GTK+, which uses prefixed function names and lots of cast macros.</para>
</sect2>

<sect2 id="gtkmm-vs-qt">
<title><application>gtkmm</application> im Vergleich zu Qt</title>
<para>Trolltech's Qt is the closest competition to <application>gtkmm</application>, so it deserves discussion.</para>

<para><application>gtkmm</application> developers tend to prefer <application>gtkmm</application> to Qt because <application>gtkmm</application> does things in a more C++ way. Qt originates from a time when C++ and the standard library were not standardised or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the C++ language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. <application>gtkmm</application> was able to use standard C++ to provide signals without changing the C++ language. See the FAQ for more detailed differences.</para>
</sect2>

<sect2 id="gtkmm-is-a-wrapper">
<title><application>gtkmm</application> is a wrapper</title>
<para>
<application>gtkmm</application> is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation has advantages. The <application>gtkmm</application> developers spend most of their time talking about how <application>gtkmm</application> can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK+ code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users.</para>
</sect2>
</sect1>

</chapter>

<chapter id="chapter-installation">
<title>Installation</title>
<sect1 id="sec-installation-dependencies">
<title>Abhängigkeiten</title>
<para>
  Before attempting to install <application>gtkmm</application> 3.0, you might first need to install these other
  packages.
</para>
<itemizedlist>
  <listitem><para><application>libsigc++ 2.0</application></para></listitem>
  <listitem><para><application>GTK+ 3.0</application></para></listitem>
  <listitem><para><application>cairomm</application></para></listitem>
  <listitem><para><application>pangomm</application></para></listitem>
  <listitem><para><application>atkmm</application></para></listitem>
</itemizedlist>
<para>
These dependencies have their own dependencies, including the following
applications and libraries:
</para>
<itemizedlist>
  <listitem><para><application>pkg-config</application></para></listitem>
  <listitem><para><application>glib</application></para></listitem>
  <listitem><para><application>ATK</application></para></listitem>
  <listitem><para><application>Pango</application></para></listitem>
  <listitem><para><application>Cairo</application></para></listitem>
  <listitem><para><application>gdk-pixbuf</application></para></listitem>
</itemizedlist>
</sect1>

<sect1 id="sec-install-unix-and-linux">
<title>Unix und Linux</title>

<sect2 id="sec-linux-install-from-packages">
<title>Vorkompilierte Pakete</title>

<para>
    Recent versions of <application>gtkmm</application> are packaged by nearly every major Linux
    distribution these days. So, if you use Linux, you can probably get
    started with <application>gtkmm</application> by installing the package from the official repository
    for your distribution. Distributions that include <application>gtkmm</application> in their
    repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and
    many others.
</para>
<para>
    The names of the <application>gtkmm</application> packages vary from distribution to distribution
    (e.g. <application>libgtkmm3.0-dev</application> on Debian and Ubuntu or
    <application>gtkmm30-devel</application> on Red Hat Fedora), so check with
    your distribution's package management program for the correct package name
    and install it like you would any other package.
</para>
<note>
<para>
The package names will not change when new API/ABI-compatible versions of <application>gtkmm</application>
are released. Otherwise they would not be API/ABI-compatible. So don't be
surprised, for instance, to find <application>gtkmm</application> 3.2 supplied by Debian's
<application>libgtkmm3.0-dev</application> package.
</para>
</note>
</sect2>

<sect2 id="sec-install-from-source">
<title>Installieren aus den Quellen</title>

<para>
If your distribution does not provide a pre-built <application>gtkmm</application> package, or if you
want to install a different version than the one provided by your distribution,
you can also install <application>gtkmm</application> from source. The source code for <application>gtkmm</application> can
be downloaded from <ulink url="http://www.gtkmm.org/"/>.
</para>
<para>
  After you've installed all of the dependencies, download the <application>gtkmm</application> source
  code, unpack it, and change to the newly created directory. <application>gtkmm</application> can be
  built and installed with the following sequence of commands:
</para>
<screen>
# ./configure
# make
# make install
</screen>
<note>
<para>
  Remember that on a Unix or Linux operating system, you will probably need to
  be <literal>root</literal> to install software. The <command>su</command>
  command will allow you to enter the <literal>root</literal> password and have
  <literal>root</literal> status temporarily.
</para>
</note>
<para>
    The <filename>configure</filename> script will check to make sure all of
    the required dependencies are already installed. If you are missing any
    dependencies, it will exit and display an error.
</para>
<para>
    By default, <application>gtkmm</application> will be installed under the
    <filename>/usr/local</filename> directory. On some systems you may need to
    install to a different location. For instance, on Red Hat Linux systems
    you might use the <literal>--prefix</literal> option with configure, like
    so:
<screen>
# ./configure --prefix=/usr
</screen>
</para>
<warning>
    <para>
        You should be very careful when installing to standard system prefixes
        such as <filename>/usr</filename>. Linux distributions install software
        packages to <filename>/usr</filename>, so installing a source package
        to this prefix could corrupt or conflict with software installed using
        your distribution's package-management system. Ideally, you should use
        a separate prefix for all software you install from source.
    </para>
</warning>
<para>
  If you want to help develop <application>gtkmm</application> or experiment with new features, you can
  also install <application>gtkmm</application> from git. Most users will never need to do this, but if
  you're interested in helping with <application>gtkmm</application> development, see the <link linkend="chapter-working-with-source">Working with gtkmm's Source Code</link> appendix.
</para>
</sect2>

</sect1>

<sect1 id="sec-packages-windows">
<title>Microsoft Windows</title>
<para>GTK+ and <application>gtkmm</application> were designed to work well with Microsoft Windows, and the developers encourage its use on the win32 platform. However, Windows has no standard installation system for development libraries. Please see the <ulink url="http://live.gnome.org/gtkmm/MSWindows">Windows Installation</ulink>
page for Windows-specific installation instructions and notes.</para>
</sect1>

</chapter>

<chapter id="chapter-basics">
<title>Grundlagen</title>

<para>
This chapter will introduce some of the most important aspects of <application>gtkmm</application> coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information.
</para>
<para>
Your existing knowledge of C++ will help you with <application>gtkmm</application> as it would with any library. Unless we state otherwise, you can expect <application>gtkmm</application> classes to behave like any other C++ class, and you can expect to use your existing C++ techniques with <application>gtkmm</application> classes.
</para>

<sect1 id="sec-basics-simple-example">
<title>Einfaches Beispiel</title>

<para>
To begin our introduction to <application>gtkmm</application>, we'll start with the simplest
program possible. This program will create an empty 200 x 200 pixel window.
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/base?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>base.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;gtkmm.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  Gtk::Window window;

  Gtk::Main::run(window);

  return EXIT_SUCCESS;
}
</programlisting>
<!-- end inserted example code -->

<para>We will now explain each line of the example</para>
<programlisting>#include &lt;gtkmm.h&gt;</programlisting>
<para>
All <application>gtkmm</application> programs must include certain <application>gtkmm</application> headers; <literal>gtkmm.h</literal>
includes the entire <application>gtkmm</application> kit. This is usually not a good idea, because
it includes a megabyte or so of headers, but for simple programs, it
suffices.
</para>

<para>
The next line:

<programlisting>Gtk::Main kit(argc, argv);</programlisting>

creates a <classname>Gtk::Main</classname> object. This is needed in all <application>gtkmm</application>
applications. The constructor for this object initializes <application>gtkmm</application>,  and checks the
arguments passed to your application on the command line, looking for
standard options such as <literal>-display</literal>. It takes these from the argument list, leaving anything it does not
recognize for your application to parse or ignore. This ensures
that all <application>gtkmm</application> applications accept the same set of standard arguments.
</para>

<para>
The next two lines of code create and display a window:
</para>
<programlisting>Gtk::Window window;</programlisting>
<para>
The last line shows the window and enters the <application>gtkmm</application> main processing loop, which will finish when the window is closed.
</para>

<programlisting>Gtk::Main::run(window);</programlisting>

<para>
After putting the source code in <literal>simple.cc</literal> you can compile the above program with gcc using:
<programlisting>g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`</programlisting>
Note that you must surround
the <literal>pkg-config</literal> invocation with backquotes.
Backquotes cause the shell to execute the command inside them, and to use
the command's output as part of the command line.
</para>
</sect1>

<sect1 id="sec-headers-and-linking">
<title>Headers and Linking</title>
<para>
Although we have shown the compilation command for the simple example, you really should use the automake and autoconf tools, as described in "Autoconf, Automake, Libtool", by G. V. Vaughan et al. The examples used in this book are included in the <application>gtkmm</application> package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate directory and type <literal>make</literal>.
</para>
<para>
To simplify compilation, we use <literal>pkg-config</literal>, which
is present in all (properly installed) <application>gtkmm</application> installations. This
program 'knows' what compiler switches are needed to compile programs
that use <application>gtkmm</application>. The <literal>--cflags</literal> option causes
<literal>pkg-config</literal> to output a list of include directories for the
compiler to look in; the <literal>--libs</literal> option requests the
list of libraries for the compiler to link with and the directories to
find them in. Try running it from your shell-prompt to see the results on your system.
</para>
<para>
However, this is even simpler when using the <function>PKG_CHECK_MODULES()</function> macro in a standard configure.ac file with autoconf and automake.
For instance:
<programlisting>PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.0.0])</programlisting>
This checks for the presence of gtkmm and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files.
</para>
<para>gtkmm-3.0 is the name of the current stable API. There was an older API called gtkmm-2-4 which installs in parallel when it is available. There were several versions of gtkmm-2.4, such as gtkmm 2.10 and there will be several versions of the gtkmm-3.0 API. Note that the API name does not change for every version because that would be an incompatible API and ABI break. Theoretically, there might be a future gtkmm-4.0 API which would install in parallel with gtkmm-3.0 without affecting existing applications.
</para>

<para>Note that if you mention extra modules in addition to gtkmm-3.0, they should be separated by spaces, not commas.
</para>
<para>
Openismus has more <ulink url="http://www.openismus.com/documents/linux/automake/automake.shtml">basic help with automake and autoconf</ulink>.
</para>

</sect1>

<sect1 id="sec-widgets-overview">
<title>Widgets</title>
<para><application>gtkmm</application> applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called "controls". For each widget in your application's windows, there is a C++ object in your application's code. So you just need to call a method of the widget's class to affect the visible widget.</para>
 <para>Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as <classname>Gtk::Grid</classname>, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 <classname>Gtk::Button</classname> widgets to a <classname>Gtk::VBox</classname> container widgets:
<programlisting>m_box.pack_start(m_Button1);
m_box.pack_start(m_Button2);</programlisting>
and here is how to add the <classname>Gtk::VBox</classname>, containing those buttons, to a <classname>Gtk::Frame</classname>, which has a visible frame and title:
<programlisting>m_frame.add(m_box);</programlisting>
</para>
<para>
Most of the chapters in this book deal with specific widgets. See the <link linkend="chapter-container-widgets">Container Widgets</link> section for more details about adding widgets to container widgets.
</para>

<para>Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design your user interfaces with <literal>Glade</literal> and load them at runtime with <literal>Gtk::Builder</literal>. See the <link linkend="chapter-builder">Glade and Gtk::Builder</link> chapter.
</para>

<para>Although <application>gtkmm</application> widget instances have lifetimes and scopes just like those of other C++ classes, <application>gtkmm</application> has an optional time-saving feature that you will see in some of the examples. <function>Gtk::manage()</function> allows you to say that a child widget is owned by the container into which you place it. This allows you to <function>new</function> the widget, add it to the container and forget about deleting it. You can learn more about <application>gtkmm</application> memory management techniques in the <link linkend="chapter-memory">Memory Management chapter</link>.
</para>

</sect1>

<sect1 id="sec-signals-overview">
<title>Signale</title>

<para>
<application>gtkmm</application>, like most GUI toolkits, is <emphasis>event-driven</emphasis>. When an event occurs, such as the press of a mouse
button, the appropriate signal will be <emphasis>emitted</emphasis> by the Widget
that was pressed. Each Widget has a different set of signals that it can emit. To make a
button click result in an action, we set up a
<emphasis>signal handler</emphasis> to catch the button's "clicked" signal.
</para>
<para><application>gtkmm</application> uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "clicked" signal with a signal handler called "on_button_clicked":
<programlisting>m_button1.signal_clicked().connect( sigc::mem_fun(*this,
  &amp;HelloWorld::on_button_clicked) );</programlisting>
</para>

<para>For more detailed information about signals, see the <link linkend="chapter-signals">appendix</link>.</para>
<para>For information about implementing your own signals rather than
just connecting to the existing <application>gtkmm</application> signals, see the <link linkend="chapter-custom-signals">appendix</link>.</para>

</sect1>

<sect1 id="sec-basics-ustring">
<title>Glib::ustring</title>
<para>You might be surprised to learn that <application>gtkmm</application> doesn't use <classname>std::string</classname> in it its interfaces. Instead it uses <classname>Glib::ustring</classname>, which is so similar and unobtrusive that you could actually pretend that each Glib::ustring is a <classname>std::string</classname> and ignore the rest of this section. But read on if you want to use languages other than English in your application.</para>
<para>std::string uses 8 bit per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese. Although the encodings for these languages has now been specified by the Unicode Constortium, the C and C++ languages do not yet provide any standardised Unicode support. GTK+ and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring. It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string.</para>
<para>One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. <classname>std::string</classname> will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using <classname>Glib::ustring</classname> instead.</para>
<para>Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "Grüß Gott" would be "Gr\xC3\xBC\xC3\x9F Gott").</para>
<para>You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. <classname>Glib::ustring</classname> worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes.</para>

<para>Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones.</para>

<para><ulink url="http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html">Referenz</ulink></para>

<para>See the <link linkend="chapter-internationalization">Internationalization</link> section for information about providing the UTF-8 string literals.</para>

</sect1>

<sect1 id="sec-intermediate-types">
<title>Intermediate types</title>
<para>Some API related to gtkmm uses intermediate data containers, such as <classname>Glib::StringArrayHandle</classname>, instead of a specific Standard C++ container such as <classname>std::vector</classname> or <classname>std::list</classname>, though <application>gtkmm</application> itself now uses just <classname>std::vector</classname> since <application>gtkmm</application> 3.0.</para>
<para>You should not declare these types yourself. You should instead use whatever Standard C++ container you prefer. glibmm will do the conversion for you. Here are some of these intermediate types:
<itemizedlist>
    <listitem><para><classname>Glib::StringArrayHandle</classname> or <classname>Glib::ArrayHandle&lt;Glib::ustring&gt;</classname>: Use <classname>std::vector&lt;Glib::ustring&gt;</classname>, <classname>std::list&lt;Glib::ustring&gt;</classname>, <type>const char*[]</type>, etc.</para></listitem>
    <listitem><para><classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::list&lt;Gtk::Widget*&gt;</classname>, etc.</para></listitem>
    <listitem><para><classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::list&lt;Gtk::Widget*&gt;</classname>, etc.</para></listitem>
</itemizedlist>

</para>

</sect1>

<sect1 id="sec-basics-gobj-and-wrap">
<title>Mischen der APIs von C und C++</title>
<para>You can use C APIs which do not yet have convenient C++ interfaces. It is generally not a problem to use C APIs from C++, and <application>gtkmm</application> helps by providing access to the underlying C object, and providing an easy way to create a C++ wrapper object from a C object, provided that the C API is also based on the GObject system.</para>

<para>To use a <application>gtkmm</application> instance with a C function that requires a C GObject instance, use the <function>gobj()</function> function to obtain a pointer to the underlying GObject instance. For instance</para>

<para>
<programlisting>
Gtk::Button* button = new Gtk::Button("example");
gtk_button_do_something_new(button-&gt;gobj());
</programlisting>
</para>

<para>To obtain a <application>gtkmm</application> instance from a C GObject instance, use the Glib::wrap() function. For instance</para>
<para>
<programlisting>
GtkButton* cbutton = get_a_button();
Gtk::Button* button = Glib::wrap(cbutton);
</programlisting>
</para>
</sect1>

<sect1 id="sec-helloworld">
<title>Hello World in <application>gtkmm</application></title>

<para>
We've now learned enough to look at a real example. In accordance with an ancient
tradition of computer science, we now introduce Hello World, a la <application>gtkmm</application>:
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/helloworld?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>helloworld.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_HELLOWORLD_H
#define GTKMM_EXAMPLE_HELLOWORLD_H

#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;

class HelloWorld : public Gtk::Window
{

public:
  HelloWorld();
  virtual ~HelloWorld();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};

#endif // GTKMM_EXAMPLE_HELLOWORLD_H
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "helloworld.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  HelloWorld helloworld;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(helloworld);

  return 0;
}
</programlisting>
<para>File: <filename>helloworld.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "helloworld.h"
#include &lt;iostream&gt;

HelloWorld::HelloWorld()
: m_button("Hello World")   // creates a new button with label "Hello World".
{
  // Sets the border width of the window.
  set_border_width(10);

  // When the button receives the "clicked" signal, it will call the
  // on_button_clicked() method defined below.
  m_button.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;HelloWorld::on_button_clicked));

  // This packs the button into the Window (a container).
  add(m_button);

  // The final step is to display this newly created widget...
  m_button.show();
}

HelloWorld::~HelloWorld()
{
}

void HelloWorld::on_button_clicked()
{
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
}
</programlisting>
<!-- end inserted example code -->

<para>
Try to compile and run it before going on. You should see something like this:
</para>

<figure id="figure-helloworld">
  <title>Hello World</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/helloworld.png"/>
  </screenshot>
</figure>

<para>
Pretty thrilling, eh?  Let's examine the code. First, the
<classname>HelloWorld</classname> class:
</para>

<programlisting>class HelloWorld : public Gtk::Window
{

public:
  HelloWorld();
  virtual ~HelloWorld();

protected:
  //Signal handlers:
  virtual void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};</programlisting>

<para>
This class implements the "Hello World" window. It's derived from
<classname>Gtk::Window</classname>, and has a single <classname>Gtk::Button</classname> as a member.
We've chosen to use the
constructor to do all of the initialisation work for the window,
including setting up the signals. Here it is, with the comments
omitted:
</para>

<programlisting>HelloWorld::HelloWorld()
:
  m_button ("Hello World")
{
  set_border_width(10);
  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;HelloWorld::on_button_clicked));
  add(m_button);.
  m_button.show();
}</programlisting>

<para>
Notice that we've used an initialiser statement to give the <literal>m_button</literal>
object the label "Hello World".
</para>

<para>
Next we call the Window's <methodname>set_border_width()</methodname> method. This sets
the amount of space between the sides of the window and the widget it
contains.
</para>

<para>
We then hook up a signal handler to <literal>m_button</literal>'s <literal>clicked</literal> signal.
This prints our friendly greeting to <literal>stdout</literal>.
</para>

<para>
Next, we use the Window's <methodname>add()</methodname> method to put <literal>m_button</literal> in
the Window. (<methodname>add()</methodname> comes from <classname>Gtk::Container</classname>, which is
described in the chapter on container widgets.)  The <methodname>add()</methodname> method
places the Widget in the Window, but it doesn't display
the widget. <application>gtkmm</application> widgets are always invisible when you create them - to display them, you must call their <methodname>show()</methodname> method, which
is what we do in the next line.
</para>


<para>
Now let's look at our program's <function>main()</function> function. Here it is,
without comments:
</para>

<programlisting>int main(int argc, char** argv)
{
  Gtk::Main kit(argc, argv);

  HelloWorld helloworld;
  Gtk::Main::run(helloworld);

  return 0;
}</programlisting>

<para>
First we instantiate an object called <literal>kit</literal>. This is of type
<classname>Gtk::Main</classname>. Every <application>gtkmm</application> program must have one of these. We pass
our command-line arguments to its constructor. It takes the arguments
it wants, and leaves you the rest, as we described earlier.
</para>

<para>
Next we make an object of our <classname>HelloWorld</classname> class, whose constructor
takes no arguments, but it isn't visible yet. When we call Gtk::Main::run(), giving it the helloworld Window, it shows the Window and starts the <application>gtkmm</application> <emphasis>event loop</emphasis>. During the event loop <application>gtkmm</application> idles, waiting for actions from the user, and responding appropriately. When the user closes the Window, run() will return, causing the final line of our main() function be to executed. The application will then finish.
</para>

</sect1>
</chapter>

<chapter id="changes-gtkmm3">
<title>Changes in <application>gtkmm</application> 3</title>

<para><application>gtkmm</application>-3.0 is a new version of the <application>gtkmm</application> API that installs in parallel with the older <application>gtkmm</application>-2.4 API. The last version of the <application>gtkmm</application>-2.4 API was <application>gtkmm</application> 2.24. <application>gtkmm</application> 3 has no major fundamental differences to <application>gtkmm</application> 2 but does make several small changes that were not possible while maintaining binary compatibility. If you never used the <application>gtkmm</application>-2.4 API then you can safely ignore this chapter.</para>

<para><application>gtkmm</application> 3's library is called <literal>libgtkmm-3.0</literal> rather than <literal>libgtkmm-2.4</literal> and installs its headers in a similarly-versioned directory, so your pkg-config check should ask for <literal>gtkmm-3.0</literal>  rather than <literal>gtkmm-2.4</literal>.</para>


<para><application>gtkmm</application> 3 added some new classes:</para>

<orderedlist>
<!-- TODO: The AppChooser content-type is not documented properly: https://bugzilla.gnome.org/show_bug.cgi?id=650012 -->
<listitem><simpara><classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</classname>, <classname>Gtk::AppChooserDialog</classname> allow the user to select an installed application to open a particularl type of content.</simpara></listitem>

<listitem><simpara><classname>Gtk::Grid</classname> is a new container widget that will eventually replace <classname>Gtk::Box</classname>. It arranges its children according to properties of those children rather than its own layout details.</simpara></listitem>
<listitem><simpara><classname>Gtk::Switch</classname> displays On/Off states more explictly than <classname>Gtk::CheckBox</classname>. It may be useful, for instance, when allowing users to activate hardware.</simpara></listitem>
</orderedlist>

<para><application>gtkmm</application> 3 also made several small changes to the API, which you will probably encounter when porting code that used <application>gtkmm</application>-2.4. Here is a short list:</para>

<para>
<orderedlist>

<listitem><simpara><classname>Gtk::CellLayout</classname>, used by <classname>Gtk::IconView</classname>, <classname>Gtk::TreeView::Column</classname> and <classname>Gtk::ComboBox</classname>, now has a <classname>Gtk::CellArea</classname> which can be used to specify more details of how the <classname>CellRenderer</classname>s are arranged and aligned.</simpara></listitem>

<listitem><simpara>Gtk::ComboBox now derives from CellLayout, allowing easier layout and alignment of its <classname>Gtk::CellRenderer</classname>s.</simpara></listitem>

<listitem><simpara><classname>Gtk::Adjustment</classname> and <classname>IconSet</classname> and <classname>Gdk::Cursor</classname> are now used via <classname>Glib::RefPtr</classname>.</simpara></listitem>

<listitem><simpara><classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, <classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, <classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</classname>, <classname>Gtk::ScrollBar</classname> and <classname>Gtk::Separator</classname> now derive from <classname>Gtk::Orientable</classname>, allowing their
orientation (vertical or horizontal) to be specified without requiring the use of a derived class such as <classname>Gtk::HBox</classname>.</simpara></listitem>

<listitem><simpara><classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, <classname>Gtk::TreeView</classname> and other widgets derive from Scrollable instead of having their own methods such as <methodname>get_vadjustment()</methodname> and instead of having their won set_scroll_adjustments signal.</simpara></listitem>

<listitem><simpara><classname>Gtk::Style</classname> and <classname>Gtk::Rc</classname> were removed, replaced by <classname>Gtk::StyleContext</classname>, and <classname>Gtk::StyleProvider</classname>s, such as <classname>Gtk::CssProvider</classname>.</simpara></listitem>

<listitem><simpara>Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes that cairomm is used for drawing, via the provided <classname>Cairo::Context</classname> and does not require you to call <methodname>Cairo::Context::clip()</methodname>.</simpara></listitem>

<listitem><simpara><classname>Gdk::RGBA</classname> replaces <classname>Color</classname>, adding an alpha component for opacity. <classname>Colormap</classname> was removed, along with its awkward use to allocate colors.</simpara></listitem>

<listitem><simpara><classname>Gdk::Pixmap</classname> and <classname>Gdk::Bitmap</classname> were removed in favour of <classname>Gdk::Pixbuf</classname>.</simpara></listitem>

<listitem><simpara><classname>Gdk::Drawable</classname> was removed, with its methods moving into <classname>Gdk::Window</classname>.</simpara></listitem>

<listitem><simpara>We now use std::vector in several methods instead of the intermediate *Handle types to make the API clearer.</simpara></listitem>

</orderedlist>
</para>

<para>All deprecated API was removed in <application>gtkmm</application> 3.0, though there will be new deprecations in future versions.</para>

<para>As a first step to porting your source code to <application>gtkmm</application>-3.0; you should probably ensure that your application builds with the deprecated <application>gtkmm</application>-2.4; API disabled, by defining macro such as GTK_DISABLE_DEPRECATED. There are some autotools macros that can help with this by defining them optionally at build time. See the <ulink url="https://live.gnome.org/gtkmm/PortingToGtkmm3">gtkmm 3 porting wiki page</ulink> for more details.</para>

</chapter>

<chapter id="chapter-button-widget">
<title>Knöpfe</title>

<para><application>gtkmm</application> stellt vier grundlegende Knopftypen bereit:</para>

<variablelist>

<varlistentry>
<term>Push-Buttons</term>
<listitem>
<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html"><classname>Gtk::Button</classname></ulink>. Standard buttons, usually
marked with a label or picture. Pushing one triggers an action. See the <link linkend="sec-pushbuttons">Button</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Umschaltknöpfe</term>
<listitem>
<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html"><classname>Gtk::ToggleButton</classname></ulink>.
Unlike a normal Button, which springs back up, a ToggleButton stays down until you
press it again. It might be useful as an on/off switch. See the <link linkend="sec-toggle-buttons">ToggleButton</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Ankreuzfelder</term>
<listitem>
<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html"><classname>Gtk::CheckButton</classname></ulink>.
These act like ToggleButtons, but show their state in small squares,
with their label at the side. They should be used in most situations
which require an on/off setting.
See the <link linkend="sec-checkboxes">CheckBox</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Radioknöpfe</term>
<listitem>
<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1RadioButton.html"><classname>Gtk::RadioButton</classname></ulink>.
Named after the station selectors on old car
radios, these buttons are used in groups for options which are
mutually exclusive. Pressing one causes all the
others in its group to turn off. They are similar to
CheckBoxes (a small widget with a label at the side), but usually
look different.
See the <link linkend="sec-radio-buttons">RadioButton</link> section.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
Note that, due to GTK+'s theming system, the appearance of these
widgets will vary. In the case of checkboxes and radio buttons, they
may vary considerably.
</para>

<sect1 id="sec-pushbuttons">
<title>Knopf</title>

<sect2 id="pushbutton-constructors"><title>Konstruktoren</title>

<para>
There are two ways to create a Button. You can specify a label
string in the <classname>Gtk::Button</classname> constructor,
or set it later with <methodname>set_label()</methodname>.
</para>

<para>To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <literal>true</literal> for the optional <literal>mnemonic</literal> parameter. For instance:
</para>
<programlisting>Gtk::Button* pButton = new Gtk::Button("_Something", true);</programlisting>

<para>
Wherever possible you should use Stock items, to ensure consistency with other applications, and to improve the appearance of your applications by using icons. For instance,
<programlisting>Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);</programlisting>
This will use standard text, in all languages, with standard keyboard accelerators, with a standard icon.
</para>

<para>
<classname>Gtk::Button</classname> is also
a container so you could put any other widget, such as a
<classname>Gtk::Image</classname> into it.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button.html">Referenz</ulink></para>
</sect2>

<sect2 id="pushbutton-example"><title>Beispiel</title>

<para>
This example creates a button with a picture and a label.
</para>

<figure id="figure-buttons">
  <title>buttons example</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/buttons.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/buttons/button?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>buttons.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_BUTTONS_H
#define GTKMM_EXAMPLE_BUTTONS_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/button.h&gt;

class Buttons : public Gtk::Window
{
public:
  Buttons();
  virtual ~Buttons();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Button m_button;
};

#endif //GTKMM_EXAMPLE_BUTTONS_H
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "buttons.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  Buttons buttons;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(buttons);

  return 0;
}
</programlisting>
<para>File: <filename>buttons.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "buttons.h"
#include &lt;iostream&gt;

Buttons::Buttons()
{
  m_button.add_pixlabel("info.xpm", "cool button");

  set_title("Pixmap'd buttons!");
  set_border_width(10);

  m_button.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;Buttons::on_button_clicked) );

  add(m_button);

  show_all_children();
}

Buttons::~Buttons()
{
}

void Buttons::on_button_clicked()
{
  std::cout &lt;&lt; "The Button was clicked." &lt;&lt; std::endl;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="pushbutton-signals"><title>Signale</title>

<para>
The <classname>Gtk::Button</classname> widget has the following signals, but most of the time you will just handle the <literal>clicked</literal> signal:
</para>

<para>
<variablelist>

<varlistentry>
<term><literal>pressed</literal></term>
<listitem>
<para>Wird ausgegeben, wenn der Knopf gedrückt wird.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>released</literal></term>
<listitem>
<para>Wird ausgegeben, wenn der Knopf losgelassen wird.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>clicked</literal></term>
<listitem>
<para>
Emitted when the button is pressed and released.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>enter</literal></term>
<listitem>
<para>
Emitted when the mouse pointer moves over the button's window.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>leave</literal></term>
<listitem>
<para>
Emitted when the mouse pointer leaves the button's window.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

</sect2>
</sect1>

<sect1 id="sec-toggle-buttons">
<title>ToggleButton</title>

<para><classname>ToggleButton</classname>s are like normal <classname>Button</classname>s, but when clicked they remain activated, or pressed,  until clicked again.</para>

<para>
To retrieve the state of the <classname>ToggleButton</classname>, you can use the
<methodname>get_active()</methodname> method. This returns <literal>true</literal> if the button
is "down". You can also set the toggle button's state, with <methodname>set_active()</methodname>. Note that, if you do this, and the state actually changes, it causes the
"clicked" signal to be emitted. This is usually what you want.
</para>

<para>
You can use the <methodname>toggled()</methodname> method to toggle the button, rather than
forcing it to be up or down: This switches the button's state, and causes the <literal>toggled</literal> signal to be emitted.
</para>

<para>
<classname>Gtk::ToggleButton</classname> is most useful as a base class for the
<classname>Gtk::CheckButton</classname> and
<classname>Gtk::RadioButton</classname> classes.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToggleButton.html">Referenz</ulink></para>

</sect1>

<sect1 id="sec-checkboxes">
<title>CheckButton</title>

<para>
<classname>Gtk::CheckButton</classname> inherits from
<classname>Gtk::ToggleButton</classname>. The only real difference between the
two is <classname>Gtk::CheckButton</classname>'s
appearance. You can check, set, and toggle a checkbox using the same
member methods as for <classname>Gtk::ToggleButton</classname>.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1CheckButton.html">Referenz</ulink></para>

<sect2 id="checkbutton-example"><title>Beispiel</title>

<figure id="figure-checkbutton">
  <title>CheckButton</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/checkbutton.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/buttons/checkbutton?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_BUTTONS_H
#define GTKMM_EXAMPLE_BUTTONS_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/checkbutton.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::CheckButton m_button;
};

#endif //GTKMM_EXAMPLE_BUTTONS_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_button("something")
{
  set_title("checkbutton example");
  set_border_width(10);

  m_button.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_clicked) );

  add(m_button);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_clicked()
{
  std::cout &lt;&lt; "The Button was clicked: state="
      &lt;&lt; (m_button.get_active() ? "true" : "false")
      &lt;&lt; std::endl;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

</sect1>

<sect1 id="sec-radio-buttons">
<title>RadioButton</title>

<para>
Like checkboxes, radio buttons also inherit from
<classname>Gtk::ToggleButton</classname>, but these work in groups, and only
one RadioButton in a group can be selected at any one time.
</para>

<sect2 id="radiobutton-groups"><title>Gruppen</title>
<para>
There are two ways to set up a group of radio buttons. The first way
is to create the buttons, and set up their groups afterwards. Only
the first two constructors are used. In the following example, we
make a new window class called <classname>RadioButtons</classname>, and then
put three radio buttons in it:
</para>

<programlisting>class RadioButtons : public Gtk::Window
{
public:
    RadioButtons();

protected:
    Gtk::RadioButton m_rb1, m_rb2, m_rb3;
};

RadioButtons::RadioButtons()
  : m_rb1("button1"),
    m_rb2("button2"),
    m_rb3("button3")
{
    Gtk::RadioButton::Group group = m_rb1.get_group();
    m_rb2.set_group(group);
    m_rb3.set_group(group);
}</programlisting>
<para>
We told <application>gtkmm</application> to put all three <classname>RadioButton</classname>s in the
same group by obtaining the group with <methodname>get_group()</methodname> and using
<methodname>set_group()</methodname> to tell the other
<classname>RadioButton</classname>s to share that group.
</para>

<para>
Note that you can't just do
<programlisting>m_rb2.set_group(m_rb1.get_group()); //doesn't work</programlisting>
because the group is modified by <methodname>set_group()</methodname> and therefore
non-const.
</para>


<para>
The second way to set up radio buttons is to make a group first, and
then add radio buttons to it. Here's an example:
</para>
<programlisting>class RadioButtons : public Gtk::Window
{
public:
    RadioButtons();
};

RadioButtons::RadioButtons()
{
    Gtk::RadioButton::Group group;
    Gtk::RadioButton *m_rb1 = Gtk::manage(
      new Gtk::RadioButton(group,"button1"));
    Gtk::RadioButton *m_rb2 = manage(
      new Gtk::RadioButton(group,"button2"));
      Gtk::RadioButton *m_rb3 = manage(
        new Gtk::RadioButton(group,"button3"));
}</programlisting>

<para>
We made a new group by simply declaring a variable, <literal>group</literal>,
of type <classname>Gtk::RadioButton::Group</classname>. Then we made three radio
buttons, using a constructor to make each of them part of
<literal>group</literal>.
</para>
</sect2>

<sect2 id="radiobutton-methods"><title>Methoden</title>
<para>
<classname>RadioButtons</classname> are "off" when created; this means that
when you first make a group of them, they will all be off. Don't forget to turn
one of them on using <methodname>set_active()</methodname>:
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1RadioButton.html">Referenz</ulink></para>

</sect2>

<sect2 id="radiobutton-example"><title>Beispiel</title>
<para>
The following example demonstrates the use of
<classname>RadioButton</classname>s:
</para>

<figure id="figure-radiobutton">
  <title>RadioButton</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/radiobuttons.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/buttons/radiobutton?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>radiobuttons.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_RADIOBUTTONS_H
#define GTKMM_EXAMPLE_RADIOBUTTONS_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/radiobutton.h&gt;
#include &lt;gtkmm/separator.h&gt;

class RadioButtons : public Gtk::Window
{
public:
  RadioButtons();
  virtual ~RadioButtons();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::VBox m_Box_Top, m_Box1, m_Box2;
  Gtk::RadioButton m_RadioButton1, m_RadioButton2, m_RadioButton3;
  Gtk::HSeparator m_Separator;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLE_RADIOBUTTONS_H
</programlisting>
<para>File: <filename>radiobuttons.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "radiobuttons.h"


RadioButtons::RadioButtons() :
  m_Box1(false, 10),
  m_Box2(false, 10),
  m_RadioButton1("button1"),
  m_RadioButton2("button2"),
  m_RadioButton3("button3"),
  m_Button_Close("close")
{
  // Set title and border of the window
  set_title("radio buttons");
  set_border_width(0);

  // Put radio buttons 2 and 3 in the same group as 1:
  Gtk::RadioButton::Group group = m_RadioButton1.get_group();
  m_RadioButton2.set_group(group);
  m_RadioButton3.set_group(group);

  // Add outer box to the window (because the window
  // can only contain a single widget)
  add(m_Box_Top);

  //Put the inner boxes and the separator in the outer box:
  m_Box_Top.pack_start(m_Box1);
  m_Box_Top.pack_start(m_Separator);
  m_Box_Top.pack_start(m_Box2);

  // Set the inner boxes' borders
  m_Box2.set_border_width(10);
  m_Box1.set_border_width(10);

  // Put the radio buttons in Box1:
  m_Box1.pack_start(m_RadioButton1);
  m_Box1.pack_start(m_RadioButton2);
  m_Box1.pack_start(m_RadioButton3);

  // Set the second button active
  m_RadioButton2.set_active();

  // Put Close button in Box2:
  m_Box2.pack_start(m_Button_Close);

  // Make the button the default widget
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  // Connect the clicked signal of the button to
  // RadioButtons::on_button_clicked()
  m_Button_Close.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;RadioButtons::on_button_clicked) );

  // Show all children of the window
  show_all_children();
}

RadioButtons::~RadioButtons()
{
}

void RadioButtons::on_button_clicked()
{
  hide(); //to close the application.
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "radiobuttons.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  RadioButtons buttons;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(buttons);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>


<chapter id="chapter-range-widgets">
<title>Range Widgets</title>

<para>
<classname>Gtk::Scale</classname> and <classname>Gtk::Scrollbar</classname>
both inherit from <classname>Gtk::Range</classname> and share much
functionality. They contain a "trough" and a "slider" (sometimes called a
"thumbwheel" in other GUI environments). Dragging the slider with the pointer
moves it within the trough, while clicking in the trough advances the slider
towards the location of the click, either completely, or by a designated
amount, depending on which mouse button is used. This should be familiar
scrollbar behaviour.
</para>

<para>
As will be explained in the <link linkend="chapter-adjustment">Adjustment</link>
section, all Range widgets are associated with a
<classname>Adjustment</classname> object. To change the lower, upper, and
current values used by the widget you need to use the methods of its
<classname>Adjustment</classname>, which you can get with the
<methodname>get_adjustment()</methodname> method. The <classname>Range</classname>
widgets' default constructors create an <classname>Adjustment</classname>
automatically, or you can specify an existing
<classname>Adjustment</classname>, maybe to share it with another widget. See
the <link linkend="chapter-adjustment">Adjustments</link> section for further
details.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Range.html">Referenz</ulink></para>

<sect1 id="sec-scrollbar-widgets">
<title>Rollbalken-Widgets</title>

<para>
These are standard scrollbars. They should be used only to scroll another
widget, such as, a <classname>Gtk::Entry</classname>, or a
<classname>Gtk::Viewport</classname>, though it's usually easier to use the
<classname>Gtk::ScrolledWindow</classname> widget in most cases.
</para>

<para>
There are horizontal and vertical scrollbar classes -
<classname>Gtk::HScrollbar</classname> and
<classname>Gtk::VScrollbar</classname>.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scrollbar.html">Referenz</ulink></para>

</sect1>

<sect1 id="sec-scale-widgets">
<title>Scale Widgets</title>

<para>
<classname>Gtk::Scale</classname> widgets (or "sliders") allow the user to
visually select and manipulate a value within a specific range. You
might use one, for instance, to adjust the
magnification level on a zoomed preview of a picture, or to control
the brightness of a colour, or to specify the number of minutes of
inactivity before a screensaver takes over the screen.
</para>

<para>
As with <classname>Scrollbar</classname>s, there are separate widget types for
horizontal and vertical widgets - <classname>Gtk::HScale</classname> and
<classname>Gtk::VScale</classname>. The default constructors create an
<classname>Adjustment</classname> with all of its values set to
<literal>0.0</literal>. This isn't useful so you will need to set some
<classname>Adjustment</classname> details to get meaningful behaviour.
</para>

<sect2 id="scale-useful-methods">
<title>Nützliche Methoden</title>

<para>
<classname>Scale</classname> widgets can display their current value as a number
next to the trough. By default they show the value, but you can change this
with the <methodname>set_draw_value()</methodname> method.
</para>

<para>
The value displayed by a scale widget is rounded to one decimal point
by default, as is the <literal>value</literal> field in its
<classname>Gtk::Adjustment</classname>. You can change this with the
<methodname>set_digits()</methodname> method.
</para>

<para>
Also, the value can be drawn in different positions relative to the trough,
specified by the <methodname>set_value_pos()</methodname> method.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scale.html">Referenz</ulink></para>

</sect2>
</sect1>

<sect1 id="sec-range-update-policies">
<title>Update Policies</title>

<para>
The <emphasis>update policy</emphasis> of a <classname>Range</classname> widget
defines at what points during user interaction it will change the
<literal>value</literal> field of its <classname>Gtk::Adjustment</classname> and
emit the <literal>value_changed</literal> signal. The update policies,
set with the <methodname>set_update_policy()</methodname> method, are:

<itemizedlist>
<listitem>

<para>
<literal>Gtk::UPDATE_CONTINUOUS</literal> - This is the default. The
<literal>value_changed</literal> signal is emitted continuously, i.e. whenever the
slider is moved by even the tiniest amount.
</para>
</listitem>
<listitem>

<para>
<literal>Gtk::UPDATE_DISCONTINUOUS</literal> - The <literal>value_changed</literal> signal is
only emitted once the slider has stopped moving and the user has
released the mouse button.
</para>
</listitem>
<listitem>

<para>
<literal>Gtk::UPDATE_DELAYED</literal> - The <literal>value_changed</literal> signal is emitted
when the user releases the mouse button, or if the slider stops moving
for a short period of time.
</para>
</listitem>

</itemizedlist>

</para>
</sect1>

<sect1 id="sec-range-example">
<title>Beispiel</title>

<para>
This example displays a window with three range widgets all connected
to the same adjustment, along with a couple of controls for adjusting
some of the parameters mentioned above and in the section on
adjustments, so you can see how they affect the way these widgets work
for the user.
</para>

<figure id="figure-range-widgets">
  <title>Range Widgets</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/range_widgets.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/range_widgets?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_RANGEWIDGETS_H
#define GTKMM_EXAMPLE_RANGEWIDGETS_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_toggled();
  void on_menu_position(Gtk::PositionType type);
  void on_adjustment1_value_changed();
  void on_adjustment2_value_changed();
  void on_button_quit();

  //Child widgets:
  Gtk::VBox m_VBox_Top, m_VBox2, m_VBox_HScale;
  Gtk::HBox m_HBox_Scales, m_HBox_Digits, m_HBox_PageSize;

  Glib::RefPtr&lt;Gtk::Adjustment&gt; m_adjustment, m_adjustment_digits, m_adjustment_pagesize;

  Gtk::VScale m_VScale;
  Gtk::HScale m_HScale, m_Scale_Digits, m_Scale_PageSize;

  Gtk::HSeparator m_Separator;

  Gtk::CheckButton m_CheckButton;

  Gtk::HScrollbar m_Scrollbar;

  Gtk::Menu m_Menu_Position;

  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLE_RANGEWIDGETS_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
:
  m_VBox2(false, 20),
  m_VBox_HScale(false, 10),
  m_HBox_Scales(false, 10),
  m_HBox_Digits(false, 10),
  m_HBox_PageSize(false, 10),

  // Value, lower, upper, step_increment, page_increment, page_size:
  // Note that the page_size value only makes a difference for
  // scrollbar widgets, and the highest value you'll get is actually
  // (upper - page_size).
  m_adjustment( Gtk::Adjustment::create(0.0, 0.0, 101.0, 0.1, 1.0, 1.0) ),
  m_adjustment_digits( Gtk::Adjustment::create(1.0, 0.0, 5.0) ),
  m_adjustment_pagesize( Gtk::Adjustment::create(1.0, 1.0, 101.0) ),

  m_VScale(m_adjustment),
  m_HScale(m_adjustment),
  m_Scale_Digits(m_adjustment_digits),
  m_Scale_PageSize(m_adjustment_pagesize),

  // A checkbutton to control whether the value is displayed or not:
  m_CheckButton("Display value on scale widgets", 0),

  // Reuse the same adjustment again.
  // Notice how this causes the scales to always be updated
  // continuously when the scrollbar is moved.
  m_Scrollbar(m_adjustment),

  m_Button_Quit("Quit")
{
  set_title("range controls");

  //VScale:
  m_VScale.set_digits(1);
  m_VScale.set_value_pos(Gtk::POS_TOP);
  m_VScale.set_draw_value();

  //HScale:
  m_HScale.set_digits(1);
  m_HScale.set_value_pos(Gtk::POS_TOP);
  m_HScale.set_draw_value();
  m_HScale.set_size_request(200, 30);

  add(m_VBox_Top);
  m_VBox_Top.pack_start(m_VBox2);
  m_VBox2.set_border_width(10);
  m_VBox2.pack_start(m_HBox_Scales);

  //Put VScale and HScale (above scrollbar) side-by-side.
  m_HBox_Scales.pack_start(m_VScale);
  m_HBox_Scales.pack_start(m_VBox_HScale);

  m_VBox_HScale.pack_start(m_HScale);

  //Scrollbar:
  m_VBox_HScale.pack_start(m_Scrollbar);

  //CheckButton:
  m_CheckButton.set_active();
  m_CheckButton.signal_toggled().connect( sigc::mem_fun(*this,
    &amp;ExampleWindow::on_checkbutton_toggled) );
  m_VBox2.pack_start(m_CheckButton);

  //Menus:
  Gtk::MenuItem* item = Gtk::manage(new Gtk::MenuItem("Top"));
  item-&gt;signal_activate().connect(
    sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_menu_position), Gtk::POS_TOP));
  m_Menu_Position.append(*item);

  item = Gtk::manage(new Gtk::MenuItem("Bottom"));
  item-&gt;signal_activate().connect(
    sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_menu_position), Gtk::POS_BOTTOM));
  m_Menu_Position.append(*item);

  item = Gtk::manage(new Gtk::MenuItem("Left"));
  item-&gt;signal_activate().connect(
    sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_menu_position), Gtk::POS_LEFT));
  m_Menu_Position.append(*item);

  item = Gtk::manage(new Gtk::MenuItem("Right"));
  item-&gt;signal_activate().connect(
    sigc::bind(sigc::mem_fun(*this,
      &amp;ExampleWindow::on_menu_position), Gtk::POS_RIGHT));
  m_Menu_Position.append(*item);

  //Digits:
  m_HBox_Digits.pack_start(
    *Gtk::manage(new Gtk::Label("Scale Digits:", 0)), Gtk::PACK_SHRINK);
  m_Scale_Digits.set_digits(0);
  m_adjustment_digits-&gt;signal_value_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_adjustment1_value_changed));
  m_HBox_Digits.pack_start(m_Scale_Digits);

  //Page Size:
  m_HBox_PageSize.pack_start(
    *Gtk::manage(new Gtk::Label("Scrollbar Page Size:", 0)),
    Gtk::PACK_SHRINK);
  m_Scale_PageSize.set_digits(0);
  m_adjustment_pagesize-&gt;signal_value_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_adjustment2_value_changed));
  m_HBox_PageSize.pack_start(m_Scale_PageSize);

  m_VBox2.pack_start(m_HBox_Digits);
  m_VBox2.pack_start(m_HBox_PageSize);
  m_VBox_Top.pack_start(m_Separator, Gtk::PACK_SHRINK);
  m_VBox_Top.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);

  m_Button_Quit.set_can_default();
  m_Button_Quit.grab_default();
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_quit));
  m_Button_Quit.set_border_width(10);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbutton_toggled()
{
  m_VScale.set_draw_value(m_CheckButton.get_active());
  m_HScale.set_draw_value(m_CheckButton.get_active());
}

void ExampleWindow::on_menu_position(Gtk::PositionType postype)
{
  m_VScale.set_value_pos(postype);
  m_HScale.set_value_pos(postype);
}

void ExampleWindow::on_adjustment1_value_changed()
{
  const double val = m_adjustment_digits-&gt;get_value();
  m_VScale.set_digits((int)val);
  m_HScale.set_digits((int)val);
}

void ExampleWindow::on_adjustment2_value_changed()
{
  const double val = m_adjustment_pagesize-&gt;get_value();
  m_adjustment-&gt;set_page_size(val);
  m_adjustment-&gt;set_page_increment(val);

  // Note that we don't have to emit the "changed" signal
  // because gtkmm does this for us.
}

void ExampleWindow::on_button_quit()
{
  hide();
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

</chapter>

<chapter id="chapter-misc-widgets">
<title>Verschiedene Widgets</title>

<sect1 id="sec-labels">
<title>Bezeichnung</title>

<para>
Labels are the  main method of placing non-editable text in windows, for
instance to place a title next to a <classname>Entry</classname> widget. You
can specify the text in the constructor, or later with the
<methodname>set_text()</methodname> or set_markup() methods.
</para>

<para>
The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks ("\n") in the label string.
</para>

<para>
The label text can be justified using the <methodname>set_justify()</methodname>
method. The widget is also capable of word-wrapping, which can be activated
with <methodname>set_line_wrap()</methodname>.
</para>

<para>
Gtk::Label support some simple formatting, for instance allowing you to make some
text bold, colored, or larger. You can do this by providing a string to
<methodname>set_markup()</methodname>, using the <ulink url="http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html">Pango Markup syntax</ulink>. For instance,
<code>
&lt;b&gt;bold text&lt;/b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt;
</code>
.</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Label.html">Referenz</ulink></para>

<sect2 id="label-example"><title>Beispiel</title>
<para>
Below is a short example to illustrate these functions. This example
makes use of the Frame widget to better demonstrate the label styles.
 (The Frame widget is explained in the <link linkend="sec-frame">Frame</link> section.)
</para>

<figure id="figure-label">
  <title>Bezeichnung</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/label.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/label?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::HBox m_HBox;
  Gtk::VBox m_VBox, m_VBox2;
  Gtk::Frame m_Frame_Normal, m_Frame_Multi, m_Frame_Left, m_Frame_Right,
    m_Frame_LineWrapped, m_Frame_FilledWrapped, m_Frame_Underlined;
  Gtk::Label m_Label_Normal, m_Label_Multi, m_Label_Left, m_Label_Right,
    m_Label_LineWrapped, m_Label_FilledWrapped, m_Label_Underlined;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
:
  m_HBox(false, 5),
  m_VBox(false, 5),
  m_Frame_Normal("Normal Label"),
  m_Frame_Multi("Multi-line Label"),
  m_Frame_Left("Left Justified Label"),
  m_Frame_Right("Right Justified Label"),
  m_Frame_LineWrapped("Line wrapped label"),
  m_Frame_FilledWrapped("Filled, wrapped label"),
  m_Frame_Underlined("Underlined label"),
  m_Label_Normal("_This is a Normal label", true),
  m_Label_Multi("This is a Multi-line label.\nSecond line\nThird line"),
  m_Label_Left("This is a Left-Justified\nMulti-line label.\nThird line"),
  m_Label_Right("This is a Right-Justified\n"
          "Multi-line label.\nFourth line, (j/k)"),
  m_Label_Underlined("This label is underlined!\n"
          "This one is underlined in quite a funky fashion")
{
  set_title("Label");
  set_border_width(5);

  add(m_HBox);

  m_HBox.pack_start(m_VBox, Gtk::PACK_SHRINK);

  m_Frame_Normal.add(m_Label_Normal);
  m_VBox.pack_start(m_Frame_Normal, Gtk::PACK_SHRINK);

  m_Frame_Multi.add(m_Label_Multi);
  m_VBox.pack_start(m_Frame_Multi, Gtk::PACK_SHRINK);

  m_Label_Left.set_justify(Gtk::JUSTIFY_LEFT);
  m_Frame_Left.add(m_Label_Left);
  m_VBox.pack_start(m_Frame_Left, Gtk::PACK_SHRINK);

  m_Label_Right.set_justify(Gtk::JUSTIFY_RIGHT);
  m_Frame_Right.add(m_Label_Right);
  m_VBox.pack_start(m_Frame_Right, Gtk::PACK_SHRINK);

  m_HBox.pack_start(m_VBox2, Gtk::PACK_SHRINK);

  m_Label_LineWrapped.set_text(
          "This is an example of a line-wrapped label.  It " \
          /* add a big space to the next line to test spacing */ \
          "should not be taking up the entire             "
          "width allocated to it, but automatically " \
          "wraps the words to fit.  " \
          "The time has come, for all good men, to come to " \
          "the aid of their party.  " \
          "The sixth sheik's six sheep's sick.\n" \
          "     It supports multiple paragraphs correctly, " \
          "and  correctly   adds " \
          "many          extra  spaces. ");
  m_Label_LineWrapped.set_line_wrap();
  m_Frame_LineWrapped.add(m_Label_LineWrapped);
  m_VBox2.pack_start(m_Frame_LineWrapped, Gtk::PACK_SHRINK);

  m_Label_FilledWrapped.set_text(
          "This is an example of a line-wrapped, filled label.  " \
          "It should be taking " \
          "up the entire              width allocated to it.  " \
          "Here is a sentence to prove " \
          "my point.  Here is another sentence. " \
          "Here comes the sun, do de do de do.\n" \
          "    This is a new paragraph.\n" \
          "    This is another newer, longer, better " \
          "paragraph.  It is coming to an end, " \
          "unfortunately.");
  m_Label_FilledWrapped.set_justify(Gtk::JUSTIFY_FILL);
  m_Label_FilledWrapped.set_line_wrap();
  m_Frame_FilledWrapped.add(m_Label_FilledWrapped);
  m_VBox2.pack_start(m_Frame_FilledWrapped, Gtk::PACK_SHRINK);

  m_Label_Underlined.set_justify(Gtk::JUSTIFY_LEFT);
  m_Label_Underlined.set_pattern (
          "_________________________ _ _________ _ ______"
          "     __ _______ ___");
  m_Frame_Underlined.add(m_Label_Underlined);
  m_VBox2.pack_start(m_Frame_Underlined, Gtk::PACK_SHRINK);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

<sect1 id="sec-text-entry">
<title>Eintrag</title>

<sect2 id="sec-text-entry-simple">
<title>Simple Use</title>

<para>
Entry widgets allow the user to enter text. You can change the contents with the <methodname>set_text()</methodname> method,
and read the current contents with the <methodname>get_text()</methodname> method.
</para>

<para>
Occasionally you might want to make an <classname>Entry</classname> widget
read-only. This can be done by passing <literal>false</literal> to the
<methodname>set_editable()</methodname> method.
</para>

<para>
For the input of passwords, passphrases and other information you don't want
echoed on the screen, calling <methodname>set_visibility()</methodname> with
<literal>false</literal> will cause the text to be hidden.
</para>

<para>
You might want to be notified whenever the user types in a text entry widget.
<classname>Gtk::Entry</classname> provides two signals,
<literal>activate</literal> and <literal>changed</literal>, for just this
purpose. <literal>activate</literal> is emitted when the user presses the
enter key in a text-entry widget; <literal>changed</literal> is emitted when
the text in the widget changes. You can use these, for instance, to validate
or filter the text the user types.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Entry.html">Referenz</ulink></para>

<sect3 id="entry-example"><title>Simple Entry Example</title>
<para>
This example uses <classname>Gtk::Entry</classname>. It also has two
<classname>CheckButton</classname>s, with which you can toggle the editable and
visible flags.
</para>

<figure id="figure-entry-simple">
  <title>Eintrag</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/entry.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/entry/simple?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbox_editable_toggled();
  void on_checkbox_visibility_toggled();
  void on_button_close();

  //Child widgets:
  Gtk::HBox m_HBox;
  Gtk::VBox m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
  Gtk::CheckButton m_CheckButton_Editable, m_CheckButton_Visible;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Button_Close("Close"),
  m_CheckButton_Editable("Editable"),
  m_CheckButton_Visible("Visible")
{
  set_size_request(200, 100);
  set_title("Gtk::Entry");

  add(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("hello");
  m_Entry.set_text(m_Entry.get_text() + " world");
  m_Entry.select_region(0, m_Entry.get_text_length());
  m_VBox.pack_start(m_Entry);

  // Note that add() can also be used instead of pack_xxx()
  m_VBox.add(m_HBox);

  m_HBox.pack_start(m_CheckButton_Editable);
  m_CheckButton_Editable.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbox_editable_toggled) );
  m_CheckButton_Editable.set_active(true);

  m_HBox.pack_start(m_CheckButton_Visible);
  m_CheckButton_Visible.signal_toggled().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbox_visibility_toggled) );
  m_CheckButton_Visible.set_active(true);

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.pack_start(m_Button_Close);
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbox_editable_toggled()
{
  m_Entry.set_editable(m_CheckButton_Editable.get_active());
}

void ExampleWindow::on_checkbox_visibility_toggled()
{
  m_Entry.set_visibility(m_CheckButton_Visible.get_active());
}

void ExampleWindow::on_button_close()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-text-entry-completion">
<title>Vervollständigung des Eintrags</title>
<para>A <classname>Entry</classname> widget can offer a drop-down list of
pre-existing choices based on the first few characters typed by the user. For
instance, a search dialog could suggest text from previous searches.
</para>

<para>To enable this functionality, you must create a
<classname>EntryCompletion</classname> object, and provide it to the
<classname>Entry</classname> widget via the
<methodname>set_completion()</methodname> method.</para>

<para>The <classname>EntryCompletion</classname> may use a
<classname>TreeModel</classname> containing possible entries, specified with
<methodname>set_model()</methodname>. You should then call
<methodname>set_text_column()</methodname> to specify which of your model columns
should be used to match possible text entries.</para>

<para>Alternatively, if a complete list of possible entries
would be too large or too inconvenient to generate, a callback slot may instead
be specified with <methodname>set_match_func()</methodname>. That callback
function. This is also useful if you wish to match on a part of the string other
than the start.</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1EntryCompletion.html">Referenz</ulink></para>

<sect3 id="entry-completion-example"><title>Beispiel für die Vervollständigung eines Eintrags</title>
<para>
This example creates a <classname>Gtk::EntryCompletion</classname> and associates
it with a <classname>Gtk::Entry</classname> widget. The completion uses a
<classname>Gtk::TreeModel</classname> of possible entries, and some additional
actions.
</para>

<figure id="figure-entry-completion">
  <title>Vervollständigung des Eintrags</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/entry_completion.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/entry/completion?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_close();

  void on_completion_action_activated(int index);

  //See the comment in the implementation:
  //bool on_completion_match(const Glib::ustring&amp; key, const Gtk::TreeModel::const_iterator&amp; iter);


  //Tree model columns, for the EntryCompletion's filter model:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  typedef std::map&lt;int, Glib::ustring&gt; type_actions_map;
  type_actions_map m_CompletionActions;
  
  //Child widgets:
  Gtk::HBox m_HBox;
  Gtk::VBox m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Label m_Label;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow() :
    m_Label("Press a or b to see a list of possible completions and actions."),
    m_Button_Close("Close")
{
  //set_size_request(200, 100);
  set_title("Gtk::EntryCompletion");

  add(m_VBox);
  m_VBox.pack_start(m_Entry, Gtk::PACK_SHRINK);

  m_VBox.pack_start(m_Label, Gtk::PACK_EXPAND_WIDGET);

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.pack_start(m_Button_Close, Gtk::PACK_SHRINK);
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  //Add an EntryCompletion:
  Glib::RefPtr&lt;Gtk::EntryCompletion&gt; completion =
      Gtk::EntryCompletion::create();
  m_Entry.set_completion(completion);

  //Create and fill the completion's filter model
  Glib::RefPtr&lt;Gtk::ListStore&gt; refCompletionModel =
      Gtk::ListStore::create(m_Columns);
  completion-&gt;set_model(refCompletionModel);

  // For more complex comparisons, use a filter match callback, like this.
  // See the comment below for more details:
  //completion-&gt;set_match_func( sigc::mem_fun(*this,
              //&amp;ExampleWindow::on_completion_match) );

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Alan Zebedee";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Adrian Boo";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Bob McRoberts";

  row = *(refCompletionModel-&gt;append());
  row[m_Columns.m_col_id] = 4;
  row[m_Columns.m_col_name] = "Bob McBob";

  //Tell the completion what model column to use to
  //- look for a match (when we use the default matching, instead of
  //  set_match_func().
  //- display text in the entry when a match is found.
  completion-&gt;set_text_column(m_Columns.m_col_name);

  //Add actions to the completion:
  //These are just extra items shown at the bottom of the list of possible
  //completions.

  //Remember them for later.
  m_CompletionActions[0] = "Use Wizard";
  m_CompletionActions[1] = "Browse for Filename";

  for(type_actions_map::iterator iter = m_CompletionActions.begin();
          iter != m_CompletionActions.end(); ++iter)
  {
    int position = iter-&gt;first;
    Glib::ustring title = iter-&gt;second;
    completion-&gt;insert_action_text(title, position);
  }

  completion-&gt;signal_action_activated().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_completion_action_activated) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_close()
{
  hide();
}

/* You can do more complex matching with a handler like this.
 * For instance, you could check for substrings inside the string instead of the start,
 * or you could look for the key in extra model columns as well as the model column that will be displayed.
 * The code here is not actually more complex - it's a reimplementation of the default behaviour.
 *
bool ExampleWindow::on_completion_match(const Glib::ustring&amp; key, const
        Gtk::TreeModel::const_iterator&amp; iter)
{
  if(iter)
  {
    Gtk::TreeModel::Row row = *iter;

    Glib::ustring::size_type key_length = key.size();
    Glib::ustring filter_string = row[m_Columns.m_col_name];

    Glib::ustring filter_string_start = filter_string.substr(0, key_length);
    //The key is lower-case, even if the user input is not.
    filter_string_start = filter_string_start.lowercase();

    if(key == filter_string_start)
      return true; //A match was found.
  }

  return false; //No match.
}
*/

void ExampleWindow::on_completion_action_activated(int index)
{
  type_actions_map::iterator iter = m_CompletionActions.find(index);
  if(iter != m_CompletionActions.end()) //If it's in the map
  {
    Glib::ustring title = iter-&gt;second;
    std::cout &lt;&lt; "Action selected: " &lt;&lt; title &lt;&lt; std::endl;
  }
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>
</sect2>

<sect2 id="sec-text-entry-icons">
<title>Entry Icons</title>
<para>An <classname>Entry</classname> widget can show an icon at the start or
end of the text area. The icon can be specifed by methods such as
<methodname>set_icon_from_pixbuf()</methodname> or
<methodname>set_icon_from_stock()</methodname>. An application can respond to the
user pressing the icon by handling the
<methodname>signal_icon_press</methodname> signal.</para>

<sect3 id="entry-icon-example"><title>Entry Icon Example</title>
<para>
This example shows a <classname>Gtk::Entry</classname> widget with a stock
search icon, and prints text to the terminal when the icon is pressed.
</para>

<figure id="figure-entry-icon">
  <title>Entry with Icon</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/entry_icon.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/entry/icon?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_icon_pressed(Gtk::EntryIconPosition icon_pos, const GdkEventButton* event);
  void on_button_close();

  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Button_Close("Close")
{
  set_title("Gtk::Entry");

  add(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("Hello world");
  m_VBox.pack_start(m_Entry, Gtk::PACK_SHRINK);

  m_Entry.set_icon_from_stock(Gtk::Stock::FIND);
  m_Entry.signal_icon_press().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_icon_pressed) );
 

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.pack_start(m_Button_Close, Gtk::PACK_SHRINK);
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_icon_pressed(Gtk::EntryIconPosition /* icon_pos */, const GdkEventButton* /* event */)
{
  std::cout &lt;&lt; "Icon pressed." &lt;&lt; std::endl;
}

void ExampleWindow::on_button_close()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>
</sect2>

<sect2 id="sec-text-entry-progress">
<title>Entry Progress</title>
<para>An <classname>Entry</classname> widget can show a progress bar inside the
text area, under the entered text. The progress bar will be shown if the
<methodname>set_progress_fraction()</methodname> or
<methodname>set_progress_pulse_step()</methodname> methods are called.</para>

<sect3 id="entry-progress-example"><title>Entry Progress Example</title>
<para>
This example shows a <classname>Gtk::Entry</classname> widget with a progress
bar.
</para>

<figure id="figure-entry-progress">
  <title>Entry with Progress Bar</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/entry_progress.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/entry/progress?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  bool on_timeout();
  void on_button_close();

  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::Entry m_Entry;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Button_Close("Close")
{
  set_title("Gtk::Entry");

  add(m_VBox);

  m_Entry.set_max_length(50);
  m_Entry.set_text("Hello world");
  m_VBox.pack_start(m_Entry, Gtk::PACK_SHRINK);

  //Change the progress fraction every 0.1 second:
  Glib::signal_timeout().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_timeout), 
    100
  );

  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox.pack_start(m_Button_Close, Gtk::PACK_SHRINK);
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

bool ExampleWindow::on_timeout()
{
  static double fraction = 0;
  m_Entry.set_progress_fraction(fraction);

  fraction += 0.01;
  if(fraction &gt; 1)
    fraction = 0;

  return true;
}

void ExampleWindow::on_button_close()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>
</sect2>

</sect1>

<sect1 id="sec-spinbutton">
<title>SpinButton</title>

<para>
A <classname>SpinButton</classname> allows the user to select a value from a
range of numeric values. It has an Entry widget with up and down arrow buttons
at the side. Clicking the buttons causes the value to 'spin' up and down across
the range of possible values. The <classname>Entry</classname> widget may also
be used to enter a value directly.
</para>

<para>
The value can have an adjustable number of decimal places, and the step size is
configurable. <classname>SpinButton</classname>s have an 'auto-repeat' feature
as well: holding down one of the arrows can optionally cause the value to
change more quickly the longer the arrow is held down.
</para>

<para>
<classname>SpinButton</classname>s use an <link linkend="chapter-adjustment">Adjustment</link> object to hold information about
the range of values. These Adjustment attributes are used by the Spin Button
like so:
<itemizedlist>
<listitem>

<para>
 <literal>value</literal>: value for the Spin Button
</para>
</listitem>
<listitem>

<para>
 <literal>lower</literal>: lower range value
</para>
</listitem>
<listitem>

<para>
 <literal>upper</literal>: upper range value
</para>
</listitem>
<listitem>
<para>
 <literal>step_increment</literal>: value to increment/decrement when pressing
mouse button 1 on a button
</para>
</listitem>
<listitem>

<para>
 <literal>page_increment</literal>: value to increment/decrement when pressing
mouse button 2 on a button
</para>
</listitem>
<listitem>

<para>
 <literal>page_size</literal>: unused
</para>
</listitem>

</itemizedlist>
</para>

<para>
Additionally, mouse button 3 can be used to jump directly to the
<literal>upper</literal> or <literal>lower</literal> values.
</para>

<para>
The <classname>SpinButton</classname> can create a default
<classname>Adjustment</classname>, which you can access via the
<methodname>get_adjustment()</methodname> method, or you can specify an existing
<classname>Adjustment</classname> in the constructor.
</para>


<sect2 id="spinbutton-methods"><title>Methoden</title>

<para>
The number of decimal places can be altered using the
<methodname>set_digits()</methodname> method.
</para>

<para>
You can set the spinbutton's value using the <methodname>set_value()</methodname>
method, and retrieve it with <methodname>get_value()</methodname>.
</para>

<para>
The <methodname>spin()</methodname> method 'spins' the
<classname>SpinButton</classname>, as if one of its arrows had been clicked.
You need to specify a <classname>Gtk::SpinType</classname> to specify the
direction or new position.
</para>

<para>
To prevent the user from typing non-numeric characters into the entry box, pass
<literal>true</literal> to the <methodname>set_numeric()</methodname> method.
</para>

<para>
To make the <classname>SpinButton</classname> 'wrap' between its upper and
lower bounds, use the <methodname>set_wrap()</methodname> method.
</para>

<para>
To force it to snap to the nearest <literal>step_increment</literal>,
use <methodname>set_snap_to_ticks()</methodname>.
</para>

<para>
You can modify the update policy using the
<methodname>set_update_policy()</methodname> method, specifying either
<literal>Gtk::UPDATE_ALWAYS</literal> or
<literal>Gtk::UPDATE_IF_VALID</literal>.
<literal>Gtk::UPDATE_ALWAYS</literal> causes the
<classname>SpinButton</classname> to ignore errors encountered while converting
the text in the entry box to a numeric value. This setting also therefore
allows the <classname>SpinButton</classname> to accept non-numeric values. You
can force an immediate update using the <methodname>update()</methodname> method.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1SpinButton.html">Referenz</ulink></para>

</sect2>

<sect2 id="spinbutton-example"><title>Beispiel</title>

<para>
Here's an example of a <classname>SpinButton</classname> in action:
</para>

<figure id="figure-spinbutton">
  <title>SpinButton</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/spinbutton.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/spinbutton?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_snap();
  void on_checkbutton_numeric();
  void on_spinbutton_digits_changed();
  void on_button_close();

  enum enumValueFormats
  {
    VALUE_FORMAT_INT,
    VALUE_FORMAT_FLOAT
  };
  void on_button_getvalue(enumValueFormats display);

  //Child widgets:
  Gtk::Frame m_Frame_NotAccelerated, m_Frame_Accelerated;
  Gtk::HBox m_HBox_NotAccelerated, m_HBox_Accelerated,
    m_HBox_Buttons;
  Gtk::VBox m_VBox_Main, m_VBox, m_VBox_Day, m_VBox_Month, m_VBox_Year,
    m_VBox_Accelerated, m_VBox_Value, m_VBox_Digits;
  Gtk::Label m_Label_Day, m_Label_Month, m_Label_Year,
    m_Label_Value, m_Label_Digits,
    m_Label_ShowValue;
  Glib::RefPtr&lt;Gtk::Adjustment&gt; m_adjustment_day, m_adjustment_month, m_adjustment_year,
    m_adjustment_value, m_adjustment_digits;
  Gtk::SpinButton m_SpinButton_Day, m_SpinButton_Month, m_SpinButton_Year,
    m_SpinButton_Value, m_SpinButton_Digits;
  Gtk::CheckButton m_CheckButton_Snap, m_CheckButton_Numeric;
  Gtk::Button m_Button_Int, m_Button_Float, m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;
#include &lt;cstdio&gt;

ExampleWindow::ExampleWindow()
:
  m_Frame_NotAccelerated("Not accelerated"),
  m_Frame_Accelerated("Accelerated"),
  m_VBox_Main(false, 5),
  m_Label_Day("Day: "),
  m_Label_Month("Month: "),
  m_Label_Year("Year: "),
  m_Label_Value("Value: "),
  m_Label_Digits("Digits: "),
  m_adjustment_day( Gtk::Adjustment::create(1.0, 1.0, 31.0, 1.0, 5.0, 0.0) ),
  m_adjustment_month( Gtk::Adjustment::create(1.0, 1.0, 12.0, 1.0, 5.0, 0.0) ),
  m_adjustment_year( Gtk::Adjustment::create(1998.0, 0.0, 2100.0, 1.0, 100.0, 0.0) ),
  m_adjustment_value( Gtk::Adjustment::create(0.0, -10000.0, 10000.0, 0.5, 100.0, 0.0) ),
  m_adjustment_digits( Gtk::Adjustment::create(2.0, 1.0, 5.0, 1.0, 1.0, 0.0) ),
  m_SpinButton_Day(m_adjustment_day),
  m_SpinButton_Month(m_adjustment_month),
  m_SpinButton_Year(m_adjustment_year),
  m_SpinButton_Value(m_adjustment_value, 1.0, 2),
  m_SpinButton_Digits(m_adjustment_digits),
  m_CheckButton_Snap("Snap to 0.5-ticks"),
  m_CheckButton_Numeric("Numeric only input mode"),
  m_Button_Int("Value as Int"),
  m_Button_Float("Value as Float"),
  m_Button_Close("Close")
{
  set_title("SpinButton");

  m_VBox_Main.set_border_width(10);
  add(m_VBox_Main);

  m_VBox_Main.pack_start(m_Frame_NotAccelerated);

  m_VBox.set_border_width(5);
  m_Frame_NotAccelerated.add(m_VBox);

  /* Day, month, year spinners */

  m_VBox.pack_start(m_HBox_NotAccelerated, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Label_Day.set_alignment(Gtk::ALIGN_START);
  m_VBox_Day.pack_start(m_Label_Day);

  m_SpinButton_Day.set_wrap();

  m_VBox_Day.pack_start(m_SpinButton_Day);

  m_HBox_NotAccelerated.pack_start(m_VBox_Day, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Label_Month.set_alignment(Gtk::ALIGN_START);
  m_VBox_Month.pack_start(m_Label_Month);

  m_SpinButton_Month.set_wrap();
  m_VBox_Month.pack_start(m_SpinButton_Month);

  m_HBox_NotAccelerated.pack_start(m_VBox_Month, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Label_Year.set_alignment(Gtk::ALIGN_START);
  m_VBox_Year.pack_start(m_Label_Year);

  m_SpinButton_Year.set_wrap();
  m_SpinButton_Year.set_size_request(55, -1);
  m_VBox_Year.pack_start(m_SpinButton_Year);

  m_HBox_NotAccelerated.pack_start(m_VBox_Year, Gtk::PACK_EXPAND_WIDGET, 5);

  //Accelerated:
  m_VBox_Main.pack_start(m_Frame_Accelerated);

  m_VBox_Accelerated.set_border_width(5);
  m_Frame_Accelerated.add(m_VBox_Accelerated);

  m_VBox_Accelerated.pack_start(m_HBox_Accelerated, Gtk::PACK_EXPAND_WIDGET, 5);

  m_HBox_Accelerated.pack_start(m_VBox_Value, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Label_Value.set_alignment(Gtk::ALIGN_START);
  m_VBox_Value.pack_start(m_Label_Value);

  m_SpinButton_Value.set_wrap();
  m_SpinButton_Value.set_size_request(100, -1);
  m_VBox_Value.pack_start(m_SpinButton_Value);

  m_HBox_Accelerated.pack_start(m_VBox_Digits, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Label_Digits.set_alignment(Gtk::ALIGN_START);
  m_VBox_Digits.pack_start(m_Label_Digits);

  m_SpinButton_Digits.set_wrap();
  m_adjustment_digits-&gt;signal_value_changed().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_spinbutton_digits_changed) );

  m_VBox_Digits.pack_start(m_SpinButton_Digits);


  //CheckButtons:
  m_VBox_Accelerated.pack_start(m_CheckButton_Snap);
  m_CheckButton_Snap.set_active();
  m_CheckButton_Snap.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_snap) );

  m_VBox_Accelerated.pack_start(m_CheckButton_Numeric);
  m_CheckButton_Numeric.set_active();
  m_CheckButton_Numeric.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_numeric) );


  //Buttons:
  m_VBox_Accelerated.pack_start (m_HBox_Buttons, Gtk::PACK_SHRINK, 5);

  m_Button_Int.signal_clicked().connect( sigc::bind( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_getvalue), VALUE_FORMAT_INT) );
  m_HBox_Buttons.pack_start(m_Button_Int, Gtk::PACK_EXPAND_WIDGET, 5);

  m_Button_Float.signal_clicked().connect( sigc::bind( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_getvalue), VALUE_FORMAT_FLOAT) );
  m_HBox_Buttons.pack_start(m_Button_Float, Gtk::PACK_EXPAND_WIDGET, 5);

  m_VBox_Accelerated.pack_start(m_Label_ShowValue);
  m_Label_ShowValue.set_text("0");

  //Close button:
  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_VBox_Main.pack_start(m_Button_Close, Gtk::PACK_SHRINK);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}


void ExampleWindow::on_button_close()
{
  hide();
}

void ExampleWindow::on_checkbutton_snap()
{
  m_SpinButton_Value.set_snap_to_ticks( m_CheckButton_Snap.get_active() );
}

void ExampleWindow::on_checkbutton_numeric()
{
  m_SpinButton_Value.set_numeric( m_CheckButton_Numeric.get_active() );
}

void ExampleWindow::on_spinbutton_digits_changed()
{
  m_SpinButton_Value.set_digits( m_SpinButton_Digits.get_value_as_int() );
}

void ExampleWindow::on_button_getvalue(enumValueFormats display)
{
  gchar buf[32];

  if (display == VALUE_FORMAT_INT)
    sprintf (buf, "%d", m_SpinButton_Value.get_value_as_int());
  else
    sprintf (buf, "%0.*f", m_SpinButton_Value.get_digits(),
            m_SpinButton_Value.get_value());

  m_Label_ShowValue.set_text(buf);
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

<sect1 id="sec-progressbar">
<title>ProgressBar</title>

<para>
Progress bars are used to show the status of an ongoing operation. For
instance, a <classname>ProgressBar</classname> can show how much of a task has
been completed.
</para>

<para>
To change the value shown, use the <methodname>set_fraction()</methodname> method,
passing a double between 0 and 1 to provide the new percentage.
</para>

<para>
where <literal>percentage</literal> is a number, from 0 to 1, indicating what
fraction of the bar should be filled.
</para>

<para>
A <classname>ProgressBar</classname>is horizontal and left-to-right by default,
but you can change it to a vertical progress bar by using the
<methodname>set_orientation()</methodname> method.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ProgressBar.html">Referenz</ulink></para>

<sect2 id="progressbar-activity-mode">
<title>Aktivitätsmodus</title>
<para>
Besides indicating the amount of progress that has occured, the
progress bar can also be used to indicate that there is some activity;
this is done by placing the progress bar in <emphasis>activity mode</emphasis>. In
this mode, the progress bar displays a small rectangle which moves
back and forth. Activity mode is useful in situations where the
progress of an operation cannot be calculated as a value range (e.g.,
receiving a file of unknown length).
</para>

<para>
To do this, you need to call the <methodname>pulse()</methodname> method at regular
intervals. You can also choose the step size, with the
<methodname>set_pulse_step()</methodname> method.
</para>

<para>
When in continuous mode, the progress bar can also display a configurable text
string within its trough, using the <methodname>set_text()</methodname> method.
</para>
</sect2>

<sect2 id="progressbar-example"><title>Beispiel</title>

<figure id="figure-progressbar">
  <title>ProgressBar</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/progressbar.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/progressbar?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_checkbutton_text();
  void on_checkbutton_activity();
  void on_checkbutton_orientation();
  virtual bool on_timeout();
  void on_button_close();

  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::Alignment m_Alignment;
  Gtk::Table m_Table;
  Gtk::ProgressBar m_ProgressBar;
  Gtk::HSeparator m_Separator;
  Gtk::CheckButton m_CheckButton_Text, m_CheckButton_Activity, m_CheckButton_Inverted;
  Gtk::Button m_Button_Close;

  int m_connection_id_timeout;
  bool m_bActivityMode;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_VBox(false, 5),
  m_Alignment(0.5, 0.5, 0, 0),
  m_Table(2, 2, true),
  m_CheckButton_Text("Show text"),
  m_CheckButton_Activity("Activity mode"),
  m_CheckButton_Inverted("Right to Left"),
  m_Button_Close("Close"),
  m_bActivityMode(false)
{
  set_resizable();
  set_title("Gtk::ProgressBar");

  m_VBox.set_border_width(10);
  add(m_VBox);

  m_VBox.pack_start(m_Alignment, Gtk::PACK_SHRINK, 5);
  m_Alignment.add(m_ProgressBar);

  //Add a timer callback to update the value of the progress bar:
  m_connection_id_timeout = Glib::signal_timeout().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_timeout), 50 );

  m_VBox.pack_start(m_Separator, Gtk::PACK_SHRINK);
  m_VBox.pack_start(m_Table);

  //Add a check button to select displaying of the trough text:
  m_Table.attach(m_CheckButton_Text, 0, 1, 0, 1, Gtk::EXPAND | Gtk::FILL,
          Gtk::EXPAND | Gtk::FILL, 5, 5);
  m_CheckButton_Text.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_text) );

  //Add a check button to select displaying of the trough text:
  m_Table.attach(m_CheckButton_Activity, 0, 1, 1, 2, Gtk::EXPAND | Gtk::FILL,
          Gtk::EXPAND | Gtk::FILL, 5, 5);
  m_CheckButton_Activity.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_activity) );

  //Add a check button to toggle activity mode:
  m_Table.attach(m_CheckButton_Inverted, 0, 1, 2, 3, Gtk::EXPAND | Gtk::FILL,
          Gtk::EXPAND | Gtk::FILL, 5, 5);
  m_CheckButton_Inverted.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_checkbutton_orientation) );

  //Add a button to exit the program.
  m_VBox.pack_start(m_Button_Close, Gtk::PACK_SHRINK);
  m_Button_Close.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close) );
  m_Button_Close.set_can_default();
  m_Button_Close.grab_default();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_checkbutton_text()
{
  const Glib::ustring text = m_ProgressBar.get_text();

  if(!text.empty())
    m_ProgressBar.set_text("");
  else
    m_ProgressBar.set_text("some text");
}

void ExampleWindow::on_checkbutton_activity()
{
  m_bActivityMode = m_CheckButton_Activity.get_active();

  if(m_bActivityMode)
    m_ProgressBar.pulse();
  else
    m_ProgressBar.set_fraction(0.0);
}

void ExampleWindow::on_checkbutton_orientation()
{
  const bool inverted = m_CheckButton_Inverted.get_active();
  m_ProgressBar.set_inverted(inverted);
}

void ExampleWindow::on_button_close()
{
  hide();
}

/* Update the value of the progress bar so that we get
 * some movement */
bool ExampleWindow::on_timeout()
{
  if(m_bActivityMode)
    m_ProgressBar.pulse();
  else
  {
    double new_val = m_ProgressBar.get_fraction() + 0.01;

    if(new_val &gt; 1.0)
      new_val = 0.0;

    //Set the new value:
    m_ProgressBar.set_fraction(new_val);
  }

  //As this is a timeout function, return true so that it
  //continues to get called
  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>


<sect1 id="sec-infobar">
<title>InfoBar</title>

<para>
An <classname>InfoBar</classname> may show small items of information or to ask brief questions. Unlike a <classname>Dialog</classname>, it appears at the top of the current window instead of opening a new window. Its API is very similar to the <link linkend="chapter-dialogs">Gtk::Dialog</link> API.</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1InfoBar.html">Referenz</ulink></para>

<sect2 id="infobar-example"><title>Beispiel</title>

<figure id="figure-infobar">
  <title>InfoBar</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/infobar.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/infobar?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_infobar_response(int response);
  void on_button_quit();
  void on_button_clear();
  void on_textbuffer_changed();

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;
  
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer;

  Gtk::InfoBar m_InfoBar;
  Gtk::Label m_Message_Label;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit, m_Button_Clear;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_VBox(false, 6),
  m_Button_Quit(Gtk::Stock::QUIT),
  m_Button_Clear("Clear")
{
  set_title("Gtk::InfoBar example");
  set_border_width(6);
  set_default_size(400, 200);

  add(m_VBox);

  // Add the message label to the InfoBar:
  Gtk::Container* infoBarContainer =
    dynamic_cast&lt;Gtk::Container*&gt;(m_InfoBar.get_content_area());
  if (infoBarContainer)
    infoBarContainer-&gt;add(m_Message_Label);

  // Add an ok button to the InfoBar:
  m_InfoBar.add_button(Gtk::Stock::OK, 0);

  // Add the InfoBar to the vbox:
  m_VBox.pack_start(m_InfoBar, Gtk::PACK_SHRINK);

  // Create the buffer and set it for the TextView:
  m_refTextBuffer = Gtk::TextBuffer::create();
  m_TextView.set_buffer(m_refTextBuffer);

  // Add the TreeView, inside a ScrolledWindow:
  m_ScrolledWindow.add(m_TextView);

  // Show the scrollbars only when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);

  // Add button box:
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Clear, Gtk::PACK_SHRINK);
  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_spacing(6);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);

  // Connect signals:
  m_InfoBar.signal_response().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_infobar_response) );
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
  m_Button_Clear.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_clear) );
  m_refTextBuffer-&gt;signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_textbuffer_changed) );

  show_all_children();

  // Keep the InfoBar hidden until a message needs to be shown:
  m_InfoBar.hide();

  // Make the clear button insensitive until text is typed in the buffer.  When
  // the button is sensitive and it is pressed, the InfoBar is displayed with a
  // message.
  m_Button_Clear.set_sensitive(false);
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_infobar_response(int)
{
  // Clear the message and hide the info bar:
  m_Message_Label.set_text("");
  m_InfoBar.hide();
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_button_clear()
{
  m_refTextBuffer-&gt;set_text("");
  m_Message_Label.set_text("Cleared the text.");
  m_InfoBar.set_message_type(Gtk::MESSAGE_INFO);
  m_InfoBar.show();
}

void ExampleWindow::on_textbuffer_changed()
{
  m_Button_Clear.set_sensitive(m_refTextBuffer-&gt;size() &gt; 0);
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

<sect1 id="sec-tooltips">
<title>Minihilfen</title>

<para>
Tooltips are the little information windows that pop up when you leave your
pointer over a widget for a few seconds. Use
<methodname>set_tooltip_text()</methodname> to set a text string as a tooltip
on any <classname>Widget</classname>. <classname>Gtk::ToolItem</classname>s are
not <classname>Widget</classname>s, but have the same method for convenience.
<classname>Gtk::Tooltip</classname> is used for more advanced tooltip usage,
such as showing an image as well as text.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Widget.html">Widget-Referenz</ulink></para>
<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Tooltip.html">Minihilfen-Referenz</ulink></para>

<sect2 id="tooltip-example"><title>Beispiel</title>

<figure id="figure-tooltip">
  <title>Tooltip</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/tooltip.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/tooltips?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:

  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Methods:
  void prepare_textview();
  void connect_signals();

  //Signal handlers:
  void on_markup_checkbutton_click();
  bool on_textview_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip);
  bool on_button_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip);

  //Child widgets:
  Gtk::VBox m_vbox;

  Gtk::CheckButton m_checkbutton;
  Gtk::Label m_label;

  Gtk::ScrolledWindow m_scrolled_window;
  Gtk::TextView m_text_view;
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_ref_text_buffer;
  Glib::RefPtr&lt;Gtk::TextTag&gt; m_ref_bold_tag;

  Gtk::Button m_button;
  Gtk::Window m_button_tooltip_window;

};

#endif // GTKMM_EXAMPLEWINDOW_H

</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

#include &lt;vector&gt;

const Glib::ustring app_title = "gtkmm tooltips example";
const Glib::ustring non_markedup_tip = "A tooltip without markup.";
const Glib::ustring markedup_tip = "&lt;i&gt;Markup&lt;/i&gt; in a tooltip.";

ExampleWindow::ExampleWindow()
  :
  m_vbox(false, 3),
  m_checkbutton("Click to alternate markup in tooltip"),
  m_label("A label"),
  m_button("Custom widget in tooltip window"),
  m_button_tooltip_window(Gtk::WINDOW_POPUP)
{
  //Set up window and the top-level container:
  set_title(app_title);
  set_border_width(10);

  add(m_vbox);

  //Check button with markup in tooltip:
  m_checkbutton.set_tooltip_text(non_markedup_tip);
  m_vbox.pack_start(m_checkbutton);

  //Label:
  m_label.set_tooltip_text("Another tooltip");
  m_vbox.pack_start(m_label);

  //Textview:
  prepare_textview();

  //Button:
  // set_tooltip_window(), like set_tooltip_text(),
  // will call set_has_tooltip() for us.
  m_button.set_tooltip_window(m_button_tooltip_window);
  m_vbox.pack_start(m_button);

  //Button's custom tooltip window:
  m_button_tooltip_window.set_default_size(250, 30);
  Gtk::Label* label =
    Gtk::manage(new Gtk::Label("A label in a custom tooltip window"));
  label-&gt;show();
  m_button_tooltip_window.add(*label);

  connect_signals();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::prepare_textview()
{
  Gtk::TextIter iter;
  std::vector&lt; Glib::RefPtr&lt;Gtk::TextTag&gt; &gt; tags;

  //Set up a scrolled window:
  m_scrolled_window.add(m_text_view);
  m_scrolled_window.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
  m_vbox.pack_start(m_scrolled_window);

  //Create a text buffer with some text:
  m_ref_text_buffer = Gtk::TextBuffer::create();

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert(iter, "Hover over the text ");

  //Insert some text with a tag.
  //In the tooltip signal handler below, we will show a tooltip
  //when mouse pointer is above this tagged text.
  m_ref_bold_tag = m_ref_text_buffer-&gt;create_tag("bold");
  m_ref_bold_tag-&gt;set_property("weight", Pango::WEIGHT_BOLD);

  tags.push_back(m_ref_bold_tag);

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert_with_tags(iter, "in bold", tags);

  iter = m_ref_text_buffer-&gt;end();
  m_ref_text_buffer-&gt;insert(iter, " to see its' tooltip");

  m_text_view.set_buffer(m_ref_text_buffer);

  m_text_view.set_size_request(320, 50);

  //When only connecting to the query-tooltip signal, and not using any
  //of set_tooltip_text(), set_tooltip_markup() or set_tooltip_window(),
  //we need to explicitly tell GTK+ that the widget has a tooltip which
  //we'll show.
  m_text_view.set_has_tooltip();
}

void ExampleWindow::connect_signals()
{
  m_checkbutton.signal_clicked().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_markup_checkbutton_click));

  m_text_view.signal_query_tooltip().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_textview_query_tooltip));

  m_button.signal_query_tooltip().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_button_query_tooltip));
}

void ExampleWindow::on_markup_checkbutton_click()
{
  if (m_checkbutton.get_active() == true)
  {
    m_checkbutton.set_tooltip_markup(markedup_tip);
  }
  else
  {
    m_checkbutton.set_tooltip_markup(non_markedup_tip);
  }
}

bool ExampleWindow::on_textview_query_tooltip(int x, int y, bool keyboard_tooltip, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp; tooltip)
{
  Gtk::TextIter iter;

  if (keyboard_tooltip)
  {
    int offset = m_ref_text_buffer-&gt;property_cursor_position().get_value();
    iter = m_ref_text_buffer-&gt;get_iter_at_offset(offset);
  }
  else
  {
    int mouse_x, mouse_y, trailing;
    m_text_view.window_to_buffer_coords(Gtk::TEXT_WINDOW_TEXT,
                                        x, y, mouse_x, mouse_y);
    m_text_view.get_iter_at_position(iter, trailing, mouse_x, mouse_y);
  }

  //Show a tooltip if the cursor or mouse pointer is over the text
  //with the specific tag:
  if (iter.has_tag(m_ref_bold_tag))
  {
    tooltip-&gt;set_markup("&lt;b&gt;Information&lt;/b&gt; attached to a text tag");
    tooltip-&gt;set_icon_from_stock (Gtk::Stock::INFO, Gtk::ICON_SIZE_MENU);
  }
  else
  {
    return false;
  }

  return true;
}

bool ExampleWindow::on_button_query_tooltip(int, int, bool, const Glib::RefPtr&lt;Gtk::Tooltip&gt;&amp;)
{
  //We already have a custom window ready, just return true to show it:
  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>

<chapter id="chapter-container-widgets">
<title>Container-Widgets</title>

<para>
All container widgets derive from <classname>Gtk::Container</classname>, not
always directly. Some container widgets, such as
<classname>Gtk::Table</classname> can hold many child widgets, so these
typically have more complex interfaces. Others, such as
<classname>Gtk::Frame</classname> contain only one child widget.
</para>

<sect1 id="sec-single-item-containers">
<title>Single-item Containers</title>

<para>
The single-item container widgets derive from <classname>Gtk::Bin</classname>,
which provides the <methodname>add()</methodname> and <methodname>remove()</methodname>
methods for the child widget. Note that <classname>Gtk::Button</classname> and
<classname>Gtk::Window</classname> are technically single-item containers, but
we have discussed them already elsewhere.
</para>

<para>
We also discuss the <classname>Gtk::Paned</classname> widget, which allows you
to divide a window into two separate "panes". This widget actually contains
two child widgets, but the number is fixed so it seems appropriate.
</para>

<sect2 id="sec-frame">
<title>Rahmen</title>

<para>
Frames can enclose one or a group of widgets within a box, optionally with a
title. For instance, you might place a group of
<classname>RadioButton</classname>s or <classname>CheckButton</classname>s in a
<classname>Frame</classname>.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Frame.html">Referenz</ulink></para>

<sect3 id="frame-example"><title>Beispiel</title>

<figure id="figure-frame">
  <title>Rahmen</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/frame.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/frame?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::Frame m_Frame;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
{
 /* Set some window properties */
  set_title("Frame Example");
  set_size_request(300, 300);

  /* Sets the border width of the window. */
  set_border_width(10);

  add(m_Frame);

  /* Set the frames label */
  m_Frame.set_label("Gtk::Frame Widget");

  /* Align the label at the right of the frame */
  //m_Frame.set_label_align(Gtk::ALIGN_END, Gtk::ALIGN_START);

  /* Set the style of the frame */
  m_Frame.set_shadow_type(Gtk::SHADOW_ETCHED_OUT);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>


<sect2 id="sec-paned">
<title>Paned</title>

<para>
Panes divide a widget into two halves, separated by a moveable divider. There
are two such widgets: <classname>Gtk::HPaned</classname> adds a horizontal
divider, and <classname>Gtk::VPaned</classname> adds a vertical one. Other
than the names and the orientations, there's no difference between the two.
</para>

<para>
Unlike the other widgets in this chapter, pane widgets contain not one but two
child widgets, one in each pane. Therefore, you should use
<methodname>add1()</methodname> and <methodname>add2()</methodname> instead of the
<methodname>add()</methodname> method.
</para>

<para>
You can adjust the position of the divider using the
<methodname>set_position()</methodname> method, and you will probably need to do
so.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Paned.html">Referenz</ulink></para>

<sect3 id="paned-example"><title>Beispiel</title>

<figure id="figure-paned">
  <title>Paned</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/paned.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/paned?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>messageslist.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_MESSAGESLIST_H
#define GTKMM_EXAMPLE_MESSAGESLIST_H

#include &lt;gtkmm.h&gt;

class MessagesList: public Gtk::ScrolledWindow
{
public:
  MessagesList();
  virtual ~MessagesList();

  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_text); }

    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  };

  ModelColumns m_Columns;

protected:
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refListStore; //The Tree Model.
  Gtk::TreeView m_TreeView; //The Tree View.
};
#endif //GTKMM_EXAMPLE_MESSAGESLIST_H
</programlisting>
<para>File: <filename>messagetext.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_MESSAGETEXT_H
#define GTKMM_EXAMPLE_MESSAGETEXT_H

#include &lt;gtkmm.h&gt;

class MessageText : public Gtk::ScrolledWindow
{
public:
  MessageText();
  virtual ~MessageText();

  void insert_text();

protected:
  Gtk::TextView m_TextView;
};

#endif //GTKMM_EXAMPLE_MESSAGETEXT_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include "messageslist.h"
#include "messagetext.h"
#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::VPaned m_VPaned;
  MessagesList m_MessagesList;
  MessageText m_MessageText;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>messagetext.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "messagetext.h"

MessageText::MessageText()
{
  set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  add(m_TextView);
  insert_text();

  show_all_children();
}

MessageText::~MessageText()
{
}

void MessageText::insert_text()
{
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; refTextBuffer = m_TextView.get_buffer();

  Gtk::TextBuffer::iterator iter = refTextBuffer-&gt;get_iter_at_offset(0);
  refTextBuffer-&gt;insert(iter,
    "From: pathfinder@nasa.gov\n"
    "To: mom@nasa.gov\n"
    "Subject: Made it!\n"
    "\n"
    "We just got in this morning. The weather has been\n"
    "great - clear but cold, and there are lots of fun sights.\n"
    "Sojourner says hi. See you soon.\n"
    " -Path\n");
}
</programlisting>
<para>File: <filename>messageslist.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "messageslist.h"
#include &lt;sstream&gt;

MessagesList::MessagesList()
{
  /* Create a new scrolled window, with scrollbars only if needed */
  set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  add(m_TreeView);

  /* create list store */
  m_refListStore = Gtk::ListStore::create(m_Columns);

  m_TreeView.set_model(m_refListStore);

  /* Add some messages to the window */
  for(int i = 0; i &lt; 10; ++i)
  {
    std::ostringstream text;
    text &lt;&lt; "message #" &lt;&lt; i;

    Gtk::TreeModel::Row row = *(m_refListStore-&gt;append());
    row[m_Columns.m_col_text] = text.str();
  }

  //Add the Model's column to the View's columns:
  m_TreeView.append_column("Messages", m_Columns.m_col_text);

  show_all_children();
}

MessagesList::~MessagesList()
{
}
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
{
  set_title ("Paned Windows");
  set_border_width(10);
  set_default_size(450, 400);

  /* Add a vpaned widget to our toplevel window */
  add(m_VPaned);

  /* Now add the contents of the two halves of the window */
  m_VPaned.add1(m_MessagesList);
  m_VPaned.add2(m_MessageText);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-scrolledwindow">
<title>ScrolledWindow</title>

<para>
<classname>ScrolledWindow</classname> widgets create a scrollable
area. You can insert any type of widget into a
<classname>ScrolledWindow</classname> window, and it will be accessible
regardless of its size by using the scrollbars. Note that
<classname>ScrolledWindow</classname> is not a
<classname>Gtk::Window</classname> despite the slightly misleading name.
</para>

<para>
Scrolled windows have <emphasis>scrollbar policies</emphasis> which determine
whether the <classname>Scrollbar</classname>s will be displayed. The policies
can be set with the <methodname>set_policy()</methodname> method. The policy may be
one of <literal>Gtk::POLICY_AUTOMATIC</literal> or
<literal>Gtk::POLICY_ALWAYS</literal>.
<literal>Gtk::POLICY_AUTOMATIC</literal> will cause the scrolled window
to display the scrollbar only if the contained widget is larger than the
visible area. <literal>Gtk::POLICY_ALWAYS</literal> will cause the
scrollbar to be displayed always.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ScrolledWindow.html">Referenz</ulink></para>

<sect3 id="scrolledwindow-example"><title>Beispiel</title>

<para>
Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react.
</para>

<figure id="figure-scrolledwindow">
  <title>ScrolledWindow</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/scrolledwindow.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/scrolledwindow?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Dialog
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_close();

  //Child widgets:
  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::Table m_Table;
  Gtk::Button m_Button_Close;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;cstdio&gt;

ExampleWindow::ExampleWindow()
: m_Table(10, 10),
  m_Button_Close("Close")
{
  set_title("Gtk::ScrolledWindow example");
  set_border_width(0);
  set_size_request(300, 300);

  m_ScrolledWindow.set_border_width(10);

  /* the policy is one of Gtk::POLICY AUTOMATIC, or Gtk::POLICY_ALWAYS.
   * Gtk::POLICY_AUTOMATIC will automatically decide whether you need
   * scrollbars, whereas Gtk::POLICY_ALWAYS will always leave the scrollbars
   * there.  The first one is the horizontal scrollbar, the second,
   * the vertical. */
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);

  get_vbox()-&gt;pack_start(m_ScrolledWindow);

  /* set the spacing to 10 on x and 10 on y */
  m_Table.set_row_spacings(10);
  m_Table.set_col_spacings(10);

  /* pack the table into the scrolled window */
  m_ScrolledWindow.add(m_Table);

  /* this simply creates a grid of toggle buttons on the table
   * to demonstrate the scrolled window. */
  for(int i = 0; i &lt; 10; i++)
  {
     for(int j = 0; j &lt; 10; j++)
     {
        char buffer[32];
        sprintf(buffer, "button (%d,%d)\n", i, j);
        Gtk::Button* pButton = Gtk::manage(new Gtk::ToggleButton(buffer));
        m_Table.attach(*pButton, i, i + 1, j, j + 1);
     }
  }

  /* Add a "close" button to the bottom of the dialog */
  m_Button_Close.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_close));

  /* this makes it so the button is the default. */
  m_Button_Close.set_can_default();

  Gtk::Box* pBox = get_action_area();
  if(pBox)
    pBox-&gt;pack_start(m_Button_Close);

  /* This grabs this button to be the default button. Simply hitting
   * the "Enter" key will cause this button to activate. */
  m_Button_Close.grab_default();

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_close()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-aspectframe">
<title>AspectFrame</title>

<para>
The <classname>AspectFrame</classname> widget looks like a
<classname>Frame</classname> widget, but it also enforces the <emphasis>aspect
    ratio</emphasis> (the ratio of the width to the height) of the child
widget, adding extra space if necessary. For instance, this would allow you to
display a photograph without allowing the user to distort it horizontally or
vertically while resizing.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1AspectFrame.html">Referenz</ulink></para>

<sect3 id="aspectframe-example">
<title>Beispiel</title>
<para>
The following program uses a <classname>Gtk::AspectFrame</classname> to present a
drawing area whose aspect ratio will always be 2:1, no matter how the user
resizes the top-level window.
</para>

<figure id="figure-aspectframe">
  <title>AspectFrame</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/aspectframe.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/aspectframe?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  //Child widgets:
  Gtk::AspectFrame m_AspectFrame;
  Gtk::DrawingArea m_DrawingArea;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_AspectFrame("2x1", /* label */
    Gtk::ALIGN_CENTER, /* center x */
    Gtk::ALIGN_CENTER, /* center y */
    2.0, /* xsize/ysize = 2 */
    false /* ignore child's aspect */)
{
  set_title("Aspect Frame");
  set_border_width(10);

  // Add a child widget to the aspect frame */
  // Ask for a 200x200 window, but the AspectFrame will give us a 200x100
  // window since we are forcing a 2x1 aspect ratio */
  m_DrawingArea.set_size_request(200, 200);
  m_AspectFrame.add(m_DrawingArea);

  // Add the aspect frame to our toplevel window:
  add(m_AspectFrame);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect3>

</sect2>


<sect2 id="sec-alignment">
<title>Alignment</title>

<para>
The <classname>Alignment</classname> widget allows you to place a widget at a
position and size relative to the size of the <classname>Alignment</classname>
widget itself. For instance, it might be used to center a widget.
</para>

<para>
You need to specify the <classname>Alignment</classname>'s characteristics to
the constructor, or to the <methodname>set()</methodname> method. In particular, you
won't notice much effect unless you specify a number other than 1.0 for the
<literal>xscale</literal> and <literal>yscale</literal> parameters, because 1.0
simply means that the child widget will expand to fill all available space.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Alignment.html">Referenz</ulink></para>

<sect3 id="alignment-example">
<title>Beispiel</title>
<para>
This example right-aligns a button in a window by using an
<classname>Alignment</classname> widget.
</para>

<figure id="figure-alignment">
  <title>Alignment</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/alignment.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/alignment?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::Alignment m_Alignment;
  Gtk::Button m_Button;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Alignment(Gtk::ALIGN_END, Gtk::ALIGN_CENTER, 0.0, 0.0),
  m_Button("Close")
{
  set_title("Gtk::Alignement");
  set_border_width(10);
  set_default_size(200, 50);

  add(m_Alignment);

  m_Alignment.add(m_Button);

  m_Button.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_clicked) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_clicked()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

<para>
See the <link linkend="sec-progressbar">ProgressBar</link> section for another
example that uses an <classname>Alignment</classname>.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="sec-multi-item-containers">
<title>Multiple-item widgets </title>

<para>
Multiple-item widgets inherit from <classname>Gtk::Container</classname>; just
as with <classname>Gtk::Bin</classname>, you use the <methodname>add()</methodname>
and <methodname>remove()</methodname> methods to add and remove contained widgets.
Unlike <methodname>Gtk::Bin::remove()</methodname>, however, the
<methodname>remove()</methodname> method for <classname>Gtk::Container</classname>
takes an argument, specifiying which widget to remove.
</para>

<sect2 id="container-packing">
<title>Packen</title>
<para>
You've probably noticed that <application>gtkmm</application> windows seem "elastic" - they can usually be stretched in many  different ways. This is due to the <emphasis>widget packing</emphasis>
system.
</para>

<para>
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
</para>

<itemizedlist>

<listitem>
<para>The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.</para>
</listitem>

<listitem>
<para>It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.</para>
</listitem>

<listitem>
<para>
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It  requires tedious recalculation of every widget's position.</para>
</listitem>

</itemizedlist>

<para>
<application>gtkmm</application> uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window,
you can arrange your widgets in rows, columns,
and/or tables. <application>gtkmm</application> can size your window automatically, based on the
sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets.
You can perfect your layout by
specifying padding distance and centering values for each of your widgets. <application>gtkmm</application> then uses
all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window. </para>

<para>
<application>gtkmm</application> arranges widgets hierarchically, using <emphasis>containers</emphasis>.
A Container widget contains other widgets. Most <application>gtkmm</application> widgets are
containers. Windows, Notebook tabs, and Buttons are all container widgets.
There are two flavours of containers: single-child containers, which are all
descendants of <classname>Gtk::Bin</classname>, and multiple-child containers,
which are descendants of <classname>Gtk::Container</classname>. Most widgets
in <application>gtkmm</application> are descendants of <classname>Gtk::Bin</classname>, including
<classname>Gtk::Window</classname>.
</para>

<para>
Yes, that's correct: a Window can contain at most one widget. How, then, can
we use a window for anything useful?  By placing a multiple-child container in
the window. The most useful container widgets are
<classname>Gtk:Grid</classname>, <classname>Gtk:VBox</classname>,
<classname>Gtk::HBox</classname>, and <classname>Gtk::Table</classname>.
</para>


<itemizedlist>

<listitem>
<para>
<classname>Gtk::Grid</classname> arranges its child widgets in rows and
columns. Use <methodname>attach()</methodname>,
<methodname>attach_next_to()</methodname> and <methodname>add()</methodname> to
insert child widgets.
</para>
</listitem>

<listitem>
<para>
<classname>Gtk::VBox</classname> and <classname>Gtk::HBox</classname> arrange
their child widgets vertically and horizontally, respectively. Use
<methodname>pack_start()</methodname> and <methodname>pack_end()</methodname> to insert
child widgets.
</para>
</listitem>

<listitem>
<para>
<classname>Gtk::Table</classname> arranges its widgets in a grid. Use
<methodname>attach()</methodname> to insert widgets.
</para>
</listitem>

</itemizedlist>

<para>
 There are several other containers, which we will also discuss.
</para>

<para>
If you've never used a packing toolkit before, it can take some
getting used to. You'll probably find, however, that you don't
need to rely on visual form editors quite as much as you might with
other toolkits.
</para>

</sect2>

<sect2 id="sec-helloworld2">
<title>Ein verbessertes »Hello World«</title>

<para>
Let's take a look at a slightly improved <literal>helloworld</literal>, showing what we've learnt.
</para>

<figure id="figure-helloworld2">
  <title>Hello World 2</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/helloworld2.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/helloworld2?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>helloworld.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_HELLOWORLD_H
#define GTKMM_EXAMPLE_HELLOWORLD_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;

class HelloWorld : public Gtk::Window
{
public:
  HelloWorld();
  virtual ~HelloWorld();

protected:

  // Signal handlers:
  // Our new improved on_button_clicked(). (see below)
  void on_button_clicked(Glib::ustring data);

  // Child widgets:
  Gtk::HBox m_box1;
  Gtk::Button m_button1, m_button2;
};

#endif // GTKMM_EXAMPLE_HELLOWORLD_H
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "helloworld.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  HelloWorld helloworld;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(helloworld);

  return 0;
}
</programlisting>
<para>File: <filename>helloworld.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "helloworld.h"
#include &lt;iostream&gt;

HelloWorld::HelloWorld()
: m_button1("Button 1"),
  m_button2("Button 2")
{
  // This just sets the title of our new window.
  set_title("Hello Buttons!");

  // sets the border width of the window.
  set_border_width(10);

  // put the box into the main window.
  add(m_box1);

  // Now when the button is clicked, we call the "on_button_clicked" function
  // with a pointer to "button 1" as it's argument
  m_button1.signal_clicked().connect(sigc::bind&lt;Glib::ustring&gt;(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1"));

  // instead of gtk_container_add, we pack this button into the invisible
  // box, which has been packed into the window.
  // note that the pack_start default arguments are Gtk::EXPAND | Gtk::FILL, 0
  m_box1.pack_start(m_button1);

  // always remember this step, this tells GTK that our preparation
  // for this button is complete, and it can be displayed now.
  m_button1.show();

  // call the same signal handler with a different argument,
  // passing a pointer to "button 2" instead.
  m_button2.signal_clicked().connect(sigc::bind&lt;-1, Glib::ustring&gt;(
              sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 2"));

  m_box1.pack_start(m_button2);

  // Show the widgets.
  // They will not really be shown until this Window is shown.
  m_button2.show();
  m_box1.show();
}

HelloWorld::~HelloWorld()
{
}

// Our new improved signal handler.  The data passed to this method is
// printed to stdout.
void HelloWorld::on_button_clicked(Glib::ustring data)
{
  std::cout &lt;&lt; "Hello World - " &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}

</programlisting>
<!-- end inserted example code -->

<para>
After building and running this program, try resizing the window to see the
behaviour. Also, try playing with the options to
<methodname>pack_start()</methodname> while reading the <link linkend="sec-boxes">Boxes</link> section.
</para>

</sect2>

<sect2 id="sec-boxes">
<title>Boxes</title>

<para>
Most packing uses boxes as in the above example. These
are invisible containers into which we can pack our widgets. When
packing widgets into a horizontal box, the objects are inserted
horizontally from left to right or right to left depending on whether
<methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> is used.
In a vertical box, widgets are packed from top to bottom or vice
versa. You may use any combination of boxes inside or beside other
boxes to create the desired effect.
</para>

<sect3 id="boxes-adding-widgets"><title>Hinzufügen von Widgets</title>
<sect4 id="per-child-packing-options"><title>Per-child packing options</title>
<para>
The <methodname>pack_start()</methodname> and
<methodname>pack_end()</methodname> methods place widgets inside these
containers. The <methodname>pack_start()</methodname> method will start at
the top and work its way down in a <classname>VBox</classname>, or pack left to
right in an <classname>HBox</classname>.
<methodname>pack_end()</methodname> will do the opposite, packing from
bottom to top in a <classname>VBox</classname>, or right to left in an
<classname>HBox</classname>. Using these methods allows us to right justify or
left justify our widgets. We will use <methodname>pack_start()</methodname>
in most of our examples.
</para>

<para>
There are several options governing how  widgets are to be packed, and this can
be confusing at first. If you have difficulties then it is sometimes a good
idea to play with the <application>glade</application> GUI designer to see what
is possible. You might even decide to use the
<application>Gtk::Builder</application> API to load your GUI at runtime.
</para>

<para>
There are basically five
different styles, as shown in this picture:
</para>

<figure id="figure-box-packing1">
  <title>Box Packing 1</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/box_packing1.png"/>
  </screenshot>
</figure>

<para>
Each line contains one horizontal box (<classname>HBox</classname>) with
several buttons. Each of the buttons on a line is packed into the
<classname>HBox</classname> with the same arguments to the
<methodname>pack_start()</methodname> method).
</para>

<para>
This is the declaration of the <methodname>pack_start()</methodname> method:
</para>
<programlisting>void pack_start(Gtk::Widget&amp; child,
                PackOptions options = PACK_EXPAND_WIDGET,
                guint padding = 0);</programlisting>

<para>
The first argument is the widget you're packing. In our example these are all <classname>Button</classname>s.
</para>

<para>
The <parameter>options</parameter> argument can take one of these three options:
<itemizedlist>
<listitem><para><literal>PACK_SHRINK</literal>: Space is contracted to the child widget size. The widget will take up just-enough space and never expand.</para></listitem>
<listitem><para><literal>PACK_EXPAND_PADDING</literal>: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't change - there will be empty space between the widgets instead. </para></listitem>
<listitem><para><literal>PACK_EXPAND_WIDGET</literal>: Extra space is taken up by increasing the child widget size, without changing the amount of space between widgets.</para></listitem>
</itemizedlist>
</para>

<para>
The <parameter>padding</parameter> argument specifies the width of an extra
border area to leave around the packed widget.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html">Referenz</ulink></para>

</sect4>

<sect4 id="per-container-packing-options"><title>Per-container packing options</title>
<para>
Here's the constructor for the box widgets:
<programlisting>Gtk::Box(bool homogeneous = false, int spacing = 0);</programlisting>
Passing <literal>true</literal> for <parameter>homogeneous</parameter> will
cause all of the contained widgets to be the same size.
<parameter>spacing</parameter> is a (minimum) number of pixels to leave between
each widget.
</para>

<para>
What's the difference between spacing (set when the box is created)
and padding (set when elements are packed)? Spacing is added between
objects, and padding is added on either side of a widget. The following
figure should make it clearer:
</para>

<figure id="figure-box-packing2">
  <title>Box Packing 2</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/box_packing2.png"/>
  </screenshot>
</figure>

</sect4>
</sect3>

<sect3 id="box-packing-example">
<title>Beispiel</title>
<para>
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/box?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>packbox.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_PACKBOX_H
#define GTKMM_EXAMPLE_PACKBOX_H

#include &lt;gtkmm.h&gt;

class PackBox : public Gtk::HBox
{
public:
  PackBox(bool homogeneous, int spacing, Gtk::PackOptions, int padding = 0);
  virtual ~PackBox();

protected:
  Gtk::Button m_button1, m_button2, m_button3;
  Gtk::Button* m_pbutton4;

  char padstr[80];
};

#endif //GTKMM_EXAMPLE_PACKBOX_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "packbox.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow(int which);
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit_clicked();

  //Child widgets:
  Gtk::Button m_button;
  Gtk::VBox m_box1;
  Gtk::HBox m_boxQuit;
  Gtk::Button m_buttonQuit;

  Gtk::Label m_Label1, m_Label2;

  Gtk::HSeparator m_seperator1, m_seperator2, m_seperator3, m_seperator4, m_seperator5;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow(int which)
: m_buttonQuit("Quit")
{
  set_title("Gtk::Box example");

  PackBox *pPackBox1, *pPackBox2, *pPackBox3, *pPackBox4, *pPackBox5;

  switch(which)
  {
    case 1:
    {
      m_Label1.set_text("Gtk::HBox(false, 0);");

      // Align the label to the left side.  We'll discuss this function and
      // others in the section on Widget Attributes.
      m_Label1.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);

      // Pack the label into the vertical box (vbox box1).  Remember that
      // widgets added to a vbox will be packed one on top of the other in
      // order.
      m_box1.pack_start(m_Label1, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_SHRINK, padding = 0
      pPackBox1 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK));
      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_EXPAND_PADDING, padding = 0
      pPackBox2 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox2, Gtk::PACK_SHRINK);

      // Create a PackBox - homogeneous = false, spacing = 0,
      // options = Gtk::PACK_EXPAND_WIDGET, padding = 0
      pPackBox3 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox3, Gtk::PACK_SHRINK);

      // pack the separator into the vbox.  Remember each of these
      // widgets are being packed into a vbox, so they'll be stacked
      // vertically.
      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);

      // create another new label, and show it.
      m_Label2.set_text("Gtk::HBox(true, 0);");
      m_Label2.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label2, Gtk::PACK_SHRINK);

      // Args are: homogeneous, spacing, options, padding
      pPackBox4 = Gtk::manage(new PackBox(true, 0, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox4, Gtk::PACK_SHRINK);

      // Args are: homogeneous, spacing, options, padding
      pPackBox5 = Gtk::manage(new PackBox(true, 0, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox5, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator2, Gtk::PACK_SHRINK, 5);

      break;
    }

    case 2:
    {

      m_Label1.set_text("Gtk::HBox(false, 10);");
      m_Label1.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label1, Gtk::PACK_SHRINK);

      pPackBox1 = Gtk::manage(new PackBox(false, 10, Gtk::PACK_EXPAND_PADDING));
      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      pPackBox2 = Gtk::manage(new PackBox(false, 10, Gtk::PACK_EXPAND_WIDGET));
      m_box1.pack_start(*pPackBox2, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);


      m_Label2.set_text("Gtk::HBox(false, 0);");
      m_Label2.set_alignment(Gtk::ALIGN_START, Gtk::ALIGN_START);
      m_box1.pack_start(m_Label2, Gtk::PACK_SHRINK);

      pPackBox3 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK, 10));
      m_box1.pack_start(*pPackBox3, Gtk::PACK_SHRINK);

      pPackBox4 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_EXPAND_WIDGET, 10));
      m_box1.pack_start(*pPackBox4, Gtk::PACK_SHRINK);

      m_box1.pack_start(m_seperator2, Gtk::PACK_SHRINK, 5);

      break;
    }

    case 3:
    {
      // This demonstrates the ability to use Gtk::Box::pack_end() to
      // right justify widgets.  First, we create a new box as before.
      pPackBox1 = Gtk::manage(new PackBox(false, 0, Gtk::PACK_SHRINK));

      // create the label that will be put at the end.
      m_Label1.set_text("end");

      // pack it using pack_end(), so it is put on the right side
      // of the PackBox.
      pPackBox1-&gt;pack_end(m_Label1, Gtk::PACK_SHRINK);

      m_box1.pack_start(*pPackBox1, Gtk::PACK_SHRINK);

      // this explicitly sets the separator to 400 pixels wide by 5 pixels
      // high.  This is so the hbox we created will also be 400 pixels wide,
      // and the "end" label will be separated from the other labels in the
      // hbox.  Otherwise, all the widgets in the hbox would be packed as
      // close together as possible.
      m_seperator1.set_size_request(400, 5);

      // pack the separator into ourselves
      m_box1.pack_start(m_seperator1, Gtk::PACK_SHRINK, 5);

      break;
    }

    default:
    {
      std::cerr &lt;&lt; "Unexpected command-line option." &lt;&lt; std::endl;
      break;
    }
  }

  // Connect the signal to hide the window:
  m_buttonQuit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit_clicked) );

  // pack the button into the quitbox.
  // The last 2 arguments to Box::pack_start are: options, padding.
  m_boxQuit.pack_start(m_buttonQuit, Gtk::PACK_EXPAND_PADDING);
  m_box1.pack_start(m_boxQuit, Gtk::PACK_SHRINK);

  // pack the vbox (box1) which now contains all our widgets, into the
  // main window.
  add(m_box1);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit_clicked()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using std::atoi;

int main(int argc, char *argv[])
{
  Gtk::Main main_instance(argc, argv);

  if(argc != 2)
  {
    std::cerr &lt;&lt; "usage: packbox num, where num is 1, 2, or 3." &lt;&lt; std::endl;
    return 1;
  }

  ExampleWindow window( atoi(argv[1]) );
  Gtk::Main::run(window); //Shows the window and returns when it is closed.

  return 0;
}
</programlisting>
<para>File: <filename>packbox.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "packbox.h"
#include &lt;cstdio&gt; //For sprintf().

PackBox::PackBox(bool homogeneous, int spacing, Gtk::PackOptions options,
        int padding) :
  Gtk::HBox(homogeneous, spacing),
  m_button1("box.pack_start("),
  m_button2("button,"),
  m_button3((options == Gtk::PACK_SHRINK) ? "Gtk::PACK_SHRINK" :
            ((options == Gtk::PACK_EXPAND_PADDING) ?
             "Gtk::PACK_EXPAND_PADDING" : "Gtk::PACK_EXPAND_WIDGET"))
{
  pack_start(m_button1, options, padding);
  pack_start(m_button2, options, padding);
  pack_start(m_button3, options, padding);

  sprintf(padstr, "%d);", padding);

  m_pbutton4 = new Gtk::Button(padstr);
  pack_start(*m_pbutton4, options, padding);
}

PackBox::~PackBox()
{
  delete m_pbutton4;
}

</programlisting>
<!-- end inserted example code -->
</sect3>

</sect2>

<sect2 id="sec-buttonbox">
<title>ButtonBoxes</title>

<para>
Button boxes are a convenient way to quickly arrange a group of buttons. They
come in both horizontal (<classname>Gtk::HButtonBox</classname>) and vertical
(<classname>Gtk::VButtonBox</classname>) flavours. They are exactly alike,
except in name and orientation.
</para>

<para>
<classname>ButtonBox</classname>es help to make applications appear consistent
because they use standard settings, such as inter-button spacing and packing.
</para>

<para>
Buttons are added to a <classname>ButtonBox</classname> with the
<methodname>add()</methodname> method.
</para>

<para>
Button boxes support several layout styles. The style can be retrieved and
changed using <methodname>get_layout()</methodname> and
<methodname>set_layout()</methodname>.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ButtonBox.html">Referenz</ulink></para>

<sect3 id="buttonbox-example">
<title>Beispiel</title>

<figure id="figure-buttonbox">
  <title>ButtonBox</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/buttonbox.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/buttonbox?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplebuttonbox.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_BUTTONBOX_H
#define GTKMM_EXAMPLE_BUTTONBOX_H

#include &lt;gtkmm.h&gt;

class ExampleButtonBox : public Gtk::Frame
{
public:
  ExampleButtonBox(bool horizontal,
       const Glib::ustring&amp; title,
       gint spacing,
       Gtk::ButtonBoxStyle layout);

protected:
  Gtk::Button m_Button_OK, m_Button_Cancel, m_Button_Help;
};

#endif //GTKMM_EXAMPLE_BUTTONBOX_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_clicked();

  //Child widgets:
  Gtk::VBox m_VBox_Main, m_VBox;
  Gtk::HBox m_HBox;
  Gtk::Frame m_Frame_Horizontal, m_Frame_Vertical;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplebuttonbox.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplebuttonbox.h"

ExampleButtonBox::ExampleButtonBox(bool horizontal,
       const Glib::ustring&amp; title,
       gint spacing,
       Gtk::ButtonBoxStyle layout)
: Gtk::Frame(title),
  m_Button_OK("OK"),
  m_Button_Cancel("Cancel"),
  m_Button_Help("Help")
{
  Gtk::ButtonBox* bbox = 0;

  if(horizontal)
    bbox = Gtk::manage( new Gtk::HButtonBox() );
  else
    bbox = Gtk::manage( new Gtk::VButtonBox() );

  bbox-&gt;set_border_width(5);

  add(*bbox);

  /* Set the appearance of the Button Box */
  bbox-&gt;set_layout(layout);
  bbox-&gt;set_spacing(spacing);

  bbox-&gt;add(m_Button_OK);
  bbox-&gt;add(m_Button_Cancel);
  bbox-&gt;add(m_Button_Help);
}

</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include "examplebuttonbox.h"

ExampleWindow::ExampleWindow()
: m_Frame_Horizontal("Horizontal Button Boxes"),
  m_Frame_Vertical("Vertical Button Boxes")
{
  set_title("Gtk::ButtonBox");
  add(m_VBox_Main);

  m_VBox_Main.pack_start(m_Frame_Horizontal, Gtk::PACK_EXPAND_WIDGET, 10);

  //The horizontal ButtonBoxes:
  m_VBox.set_border_width(10);
  m_Frame_Horizontal.add(m_VBox);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Spread (spacing 40)", 40,
                  Gtk::BUTTONBOX_SPREAD)),
          Gtk::PACK_EXPAND_WIDGET, 0);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Edge (spacing 30)", 30,
                  Gtk::BUTTONBOX_EDGE)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "Start (spacing 20)", 20,
                  Gtk::BUTTONBOX_START)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_VBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(true, "end (spacing 10)", 10,
                  Gtk::BUTTONBOX_END)),
          Gtk::PACK_EXPAND_WIDGET, 5);


  //The vertical ButtonBoxes:
  m_VBox_Main.pack_start(m_Frame_Vertical, Gtk::PACK_EXPAND_WIDGET, 10);

  m_HBox.set_border_width(10);
  m_Frame_Vertical.add(m_HBox);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Spread (spacing 5)", 5,
                  Gtk::BUTTONBOX_SPREAD)),
          Gtk::PACK_EXPAND_WIDGET, 0);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Edge (spacing 30)", 30,
                  Gtk::BUTTONBOX_EDGE)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_HBox.pack_start(*Gtk::manage(
              new ExampleButtonBox(false, "Start (spacing 20)", 20,
                  Gtk::BUTTONBOX_START)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  m_HBox.pack_start(*Gtk::manage(new ExampleButtonBox(false, "End (spacing 10)",
                  10, Gtk::BUTTONBOX_END)),
          Gtk::PACK_EXPAND_WIDGET, 5);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_clicked()
{
  hide();
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-grid">
<title>Grid</title>

<para>
A <classname>Grid</classname> dynamically lays out child widgets in rows and
columns. The dimensions of the grid do not need to be specified in the constructor.
</para>

<para>
Child widgets can span multiple rows or columns, using
<methodname>attach()</methodname>, or added next to an existing widget inside
the grid with <methodname>attach_next_to()</methodname>. Individual rows and columns of the grid can be set to have uniform height or width with
<methodname>set_row_homogeneous()</methodname> and
<methodname>set_column_homogeneous()</methodname>.
</para>
<para>You can set the <emphasis>margin</emphasis> and <emphasis>expand</emphasis> properties of the
child <classname>Widget</classname>s to control their spacing and their behaviour when the Grid is resized.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html">Referenz</ulink></para>

<sect3 id="grid-example"><title>Beispiel</title>
<para>
This example creates a window with three buttons in a grid.
The first two buttons are in the upper row, from left to right. A
third button is attached underneath the first button, in a new lower row,
spanning two columns.
</para>

<figure id="figure-grid">
  <title>Grid</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/grid.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/grid?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_quit();
  void on_button_numbered(const Glib::ustring&amp; data);

  // Child widgets:
  Gtk::Grid m_grid;
  Gtk::Button m_button_1, m_button_2, m_button_quit;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_button_1("button 1"),
  m_button_2("button 2"),
  m_button_quit("Quit")
{
  set_title("Gtk::Grid");
  set_border_width(12);

  add(m_grid);

  m_grid.add(m_button_1);
  m_grid.add(m_button_2);
  m_grid.attach_next_to(m_button_quit, m_button_1, Gtk::POS_BOTTOM, 2, 1);

  m_button_1.signal_clicked().connect(
    sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_button_numbered), "button 1") );
  m_button_2.signal_clicked().connect(
    sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_button_numbered), "button 2") );

  m_button_quit.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void
ExampleWindow::on_button_numbered(const Glib::ustring&amp; data)
{
  std::cout &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  // Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-table">
<title>Tabelle</title>

<para>
Tables allows us to place widgets in a grid, similar to <classname>Gtk::Grid</classname>.
</para>

<sect3 id="table-constructor"><title>Konstruktor</title>
<para>
The grid's dimensions need to be specified in the constructor:
</para>
<programlisting>Gtk::Table(int rows = 1, int columns = 1, bool homogeneous = false);</programlisting>

<para>
The first argument is the number of rows to make in the table, while the
second, obviously, is the number of columns. If
<parameter>homogeneous</parameter> is <literal>true</literal>, the table cells
will all be the same size (the size of the largest widget in the table).
</para>

<para>
The rows and columns are indexed starting at 0. If you specify
<parameter>rows</parameter> = 2 and <parameter>columns</parameter> = 2, the
layout would look something like this:
</para>

<programlisting>
 0          1          2
0+----------+----------+
 |          |          |
1+----------+----------+
 |          |          |
2+----------+----------+
</programlisting>

<para>
Note that the coordinate system starts in the upper left hand corner.
</para>
</sect3>

<sect3 id="table-adding-widgets"><title>Hinzufügen von Widgets</title>
<para>
To place a widget into a box, use the following method:
</para>
<programlisting>void Gtk::Table::attach(Gtk::Widget&amp; child,
                        guint left_attach, guint right_attach,
                        guint top_attach, guint bottom_attach,
                        guint xoptions = Gtk::FILL | Gtk::EXPAND,
                        guint yoptions = Gtk::FILL | Gtk::EXPAND,
                        guint xpadding = 0, guint ypadding = 0);</programlisting>
<para>
The first argument is the widget you wish to place in the table.
</para>

<para>
The <parameter>left_attach</parameter> and
<parameter>right_attach</parameter> arguments specify where to place the
widget, and how many boxes to use. For example, if you want a button in the
lower-right cell of a 2 x 2 table, and want it to occupy that cell
<emphasis>only</emphasis>, then <parameter>left_attach</parameter> would
be 1, <parameter>right_attach</parameter> 2,
<parameter>top_attach</parameter> 1, and
<parameter>bottom_attach</parameter> 2. If, on the other hand, you
wanted a widget to take up the entire top row of our 2 x 2 table, you'd set
<parameter>left_attach</parameter> = 0,
<parameter>right_attach</parameter> = 2,
<parameter>top_attach</parameter> = 0, and
<parameter>bottom_attach</parameter> = 1.
</para>

<para>
<parameter>xoptions</parameter> and <parameter>yoptions</parameter> are used to
specify packing options and may be bitwise ORed together to allow multiple
options. These options are:
</para>

<para>
<variablelist>

<varlistentry>
<term><literal>Gtk::FILL</literal></term>
<listitem>
<para>
If the table box is larger than the widget, and
<literal>Gtk::FILL</literal> is specified, the widget will expand to use all the room available.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>Gtk::SHRINK</literal></term>
<listitem>
<para>
If the table widget is allocated less
space than it requested (because the user resized the window),
then the widgets will normally just disappear off the bottom of the
window. If <literal>Gtk::SHRINK</literal> is specified, the widgets
will shrink with the table.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>Gtk::EXPAND</literal></term>
<listitem>
<para>This will cause the table to expand to use up anyremaining space in the window.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
The padding arguments work just as they do for
<methodname>pack_start()</methodname>.
</para>
</sect3>

<sect3 id="table-other-methods"><title>Weitere Methoden</title>

<para>
<methodname>set_row_spacing()</methodname> and
<methodname>set_col_spacing()</methodname> set the spacing between
the rows at the specified row or column. Note that for columns, the space goes
to the right of the column, and for rows, the space goes below the row.
</para>

<para>
You can also set a consistent spacing for all rows and/or columns with
<methodname>set_row_spacings()</methodname> and
<methodname>set_col_spacings()</methodname>. Note that with these calls, the last
row and last column do not get any spacing.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Table.html">Referenz</ulink></para>

</sect3>

<sect3 id="table-example"><title>Beispiel</title>
<para>
In the following example, we make a window with three buttons in a 2 x 2
table. The first two buttons will be placed in the upper row. A
third button is placed in the lower row, spanning both columns.
</para>

<figure id="figure-table">
  <title>Tabelle</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/table.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/table?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_button_numbered(Glib::ustring data);

  //Child widgets:
  Gtk::Table m_Table;
  Gtk::Button m_Button_1, m_Button_2, m_Button_Quit;

};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Table(2, 2, true),
  m_Button_1("button 1"),
  m_Button_2("button 2"),
  m_Button_Quit("Quit")
{
  set_title("Gtk::Table");
  set_border_width(20);

  add(m_Table);

  m_Table.attach(m_Button_1, 0, 1, 0, 1);
  m_Table.attach(m_Button_2, 1, 2, 0, 1);
  m_Table.attach(m_Button_Quit, 0, 2, 1, 2);

  m_Button_1.signal_clicked().connect(
          sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_numbered), "button 1") );
  m_Button_2.signal_clicked().connect(
          sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_button_numbered), "button 2") );

  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void
ExampleWindow::on_button_numbered(Glib::ustring data)
{
  std::cout &lt;&lt; "Hello again - " &lt;&lt; data &lt;&lt; " was pressed" &lt;&lt; std::endl;
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-notebook">
<title>Reitermappe</title>

<para>
A <classname>Notebook</classname> has a set of stacked
<literal>pages</literal>, each of which contains widgets. Labelled
<literal>tabs</literal> allow the user to select the pages.
<classname>Notebook</classname>s allow several sets of widgets to be placed in a
small space, by only showing one page at a time. For instance, they are often
used in preferences dialogs.
</para>

<para>
Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</methodname>
and <methodname>insert_page()</methodname> methods to add tabbed pages to the
<literal>Notebook</literal>, supplying the child widget and the name for the
tab.
</para>

<para>
To discover the currently visible page, use the
<methodname>get_current_page()</methodname> method. This returns the page number,
and then calling <methodname>get_nth_page()</methodname> with that number will give
you a pointer to the actual child widget.
</para>

<para>
To programmatically change the selected page, use the
<methodname>set_current_page()</methodname> method.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook.html">Referenz</ulink></para>

<sect3 id="notebook-example"><title>Beispiel</title>

<figure id="figure-notebook">
  <title>Reitermappe</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/notebook.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/notebook/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_notebook_switch_page(Gtk::Widget* page, guint page_num);

  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::Notebook m_Notebook;
  Gtk::Label m_Label1, m_Label2;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Label1("Contents of tab 1"),
  m_Label2("Contents of tab 2"),
  m_Button_Quit("Quit")
{
  set_title("Gtk::Notebook example");
  set_border_width(10);
  set_default_size(400, 200);


  add(m_VBox);

  //Add the Notebook, with the button underneath:
  m_Notebook.set_border_width(10);
  m_VBox.pack_start(m_Notebook);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Add the Notebook pages:
  m_Notebook.append_page(m_Label1, "First");
  m_Notebook.append_page(m_Label2, "Second");

  m_Notebook.signal_switch_page().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_notebook_switch_page) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_notebook_switch_page(Gtk::Widget* /* page */, guint page_num)
{
  std::cout &lt;&lt; "Switched to tab with index " &lt;&lt; page_num &lt;&lt; std::endl;

  //You can also use m_Notebook.get_current_page() to get this index.
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

<sect2 id="sec-assistant">
<title>Assistent</title>

<para>
An <classname>Assistant</classname> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with <methodname>set_page_type()</methodname>.
</para>

<para>
Use the <methodname>append_page()</methodname>, <methodname>prepend_page</methodname> and <methodname>insert_page()</methodname> methods to add pages to the <classname>Assistant</classname>, supplying the child widget for each page.
</para>

<para>
To determine the currently-visible page, use the <methodname>get_current_page()</methodname> method, and pass the result to <methodname>get_nth_page()</methodname>, which returns a pointer to the actual widget. To programmatically change the current page, use the <methodname>set_current_page()</methodname> method.
</para>

<para>
To set the title of a page, use the <methodname>set_page_title()</methodname> method. The header and side images of a page can be set with the <methodname>set_page_header_image()</methodname> and <methodname>set_page_side_image()</methodname> methods.
</para>

<para>
To add widgets to the action area, use the <methodname>add_action_widget()</methodname> method. They will be packed alongside the default buttons. Use the <methodname>remove_action_widget()</methodname> method to remove widgets.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant.html">Referenz</ulink></para>

<sect3 id="assistant-example"><title>Beispiel</title>

<figure id="figure-assistant">
  <title>Assistent</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/assistant.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/assistant/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>exampleassistant.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEASSISTANT_H
#define GTKMM_EXAMPLEASSISTANT_H

#include &lt;gtkmm.h&gt;

class ExampleAssistant : public Gtk::Assistant
{
public:
  ExampleAssistant();
  virtual ~ExampleAssistant();

  void get_result(bool&amp; check_state, Glib::ustring&amp; entry_text);

private:
  // Signal handlers:
  void on_assistant_apply();
  void on_assistant_cancel();
  void on_assistant_close();
  void on_assistant_prepare(Gtk::Widget* widget);
  void on_entry_changed();

  // Member functions:
  void print_status();

  // Child widgets:
  Gtk::HBox m_box;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
};

#endif /* GTKMM_EXAMPLEASSISTANT_H */
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include "exampleassistant.h"
#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:
  // Signal handlers:
  void on_button_clicked();
  void on_assistant_apply();

  // Child widgets:
  Gtk::Table m_table;
  Gtk::Button m_button;
  Gtk::Label m_label1, m_label2;
  Gtk::CheckButton m_check;
  Gtk::Entry m_entry;
  ExampleAssistant m_assistant;
};

#endif /* GTKMM_EXAMPLEWINDOW_H */
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include "exampleassistant.h"

ExampleWindow::ExampleWindow()
: m_table(3, 2),
  m_button("Show the assistant"),
  m_label1("State of assistant checkbutton:"),
  m_label2("Contents of assistant entry:")
{
  set_title("Gtk::Assistant example");
  set_border_width(12);

  m_table.attach(m_button, 0, 2, 0, 1, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_label1, 0, 1, 1, 2, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_label2, 0, 1, 2, 3, Gtk::FILL, Gtk::EXPAND);
  m_table.attach(m_check, 1, 2, 1, 2);
  m_table.attach(m_entry, 1, 2, 2, 3);
  add(m_table);

  m_label1.set_alignment(0.0, 0.5);
  m_label2.set_alignment(0.0, 0.5);

  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_button_clicked));
  m_assistant.signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleWindow::on_assistant_apply));

  m_check.set_sensitive(false);
  m_entry.set_sensitive(false);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_assistant_apply()
{
  bool check_state;
  Glib::ustring entry_text;

  m_assistant.get_result(check_state, entry_text);
  m_check.set_active(check_state);
  m_entry.set_text(entry_text);
}

void ExampleWindow::on_button_clicked()
{
  m_assistant.show();
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  // Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<para>File: <filename>exampleassistant.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "exampleassistant.h"

ExampleAssistant::ExampleAssistant()
: m_box(false, 12),
  m_label1("Type text to allow the assistant to continue:"),
  m_label2("Confirmation page"),
  m_check("Optional extra information")
{
  set_title("Gtk::Assistant example");
  set_border_width(12);
  set_default_size(400, 300);

  m_box.pack_start(m_label1);
  m_box.pack_start(m_entry);

  append_page(m_box);
  append_page(m_check);
  append_page(m_label2);

  set_page_title(*get_nth_page(0), "Page 1");
  set_page_title(*get_nth_page(1), "Page 2");
  set_page_title(*get_nth_page(2), "Confirmation");

  set_page_complete(m_check, true);
  set_page_complete(m_label2, true);

  set_page_type(m_box, Gtk::ASSISTANT_PAGE_INTRO);
  set_page_type(m_label2, Gtk::ASSISTANT_PAGE_CONFIRM);

  signal_apply().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_apply));
  signal_cancel().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_cancel));
  signal_close().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_close));
  signal_prepare().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_assistant_prepare));

  m_entry.signal_changed().connect(sigc::mem_fun(*this,
    &amp;ExampleAssistant::on_entry_changed));

  show_all_children();
}

ExampleAssistant::~ExampleAssistant()
{
}

void ExampleAssistant::get_result(bool&amp; check_state, Glib::ustring&amp; entry_text)
{
  check_state = m_check.get_active();
  entry_text = m_entry.get_text();
}

void ExampleAssistant::on_assistant_apply()
{
  std::cout &lt;&lt; "Apply was clicked";
  print_status();
}

void ExampleAssistant::on_assistant_cancel()
{
  std::cout &lt;&lt; "Cancel was clicked";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_close()
{
  std::cout &lt;&lt; "Assistant was closed";
  print_status();
  hide();
}

void ExampleAssistant::on_assistant_prepare(Gtk::Widget* /* widget */)
{
  set_title(Glib::ustring::compose("Gtk::Assistant example (Page %1 of %2)",
    get_current_page() + 1, get_n_pages()));
}

void ExampleAssistant::on_entry_changed()
{
  // The page is only complete if the entry contains text.
  if(m_entry.get_text_length())
    set_page_complete(m_box, true);
  else
    set_page_complete(m_box, false);
}

void ExampleAssistant::print_status()
{
  std::cout &lt;&lt; ", entry contents: \"" &lt;&lt; m_entry.get_text()
    &lt;&lt; "\", checkbutton status: " &lt;&lt; m_check.get_active() &lt;&lt; std::endl;
}
</programlisting>
<!-- end inserted example code -->

</sect3>

</sect2>

</sect1>

</chapter>

<chapter id="chapter-treeview">

<title>Das TreeView-Widget</title>
<para>
The <classname>Gtk::TreeView</classname> widget can contain lists or trees of
data, in columns.
</para>

<sect1 id="sec-treeview-model">
<title>Das Modell</title>
<para>
Each <classname>Gtk::TreeView</classname> has an associated
<classname>Gtk::TreeModel</classname>, which contains the data displayed by the
<classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> can
be used by more than one <classname>Gtk::TreeView</classname>. For instance,
this allows the same underlying data to be displayed and edited in 2 different
ways at the same time. Or the 2 Views might display different columns from the
same Model data, in the same way that 2 SQL queries (or "views") might
show different fields from the same database table.
</para>
<para>
Although you can theoretically implement your own Model, you will normally use
either the <classname>ListStore</classname> or <classname>TreeStore</classname>
model classes.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModel.html">Referenz</ulink></para>

<sect2 id="treeview-model-liststore">
<title>ListStore, für Zeilen</title>
<para>
The <classname>ListStore</classname> contains simple rows of data, and each row
has no children.
</para>

<figure id="figure-treeview-liststore-model">
  <title>TreeView - ListStore</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_list.png"/>
  </screenshot>
</figure>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ListStore.html">Referenz</ulink></para>

</sect2>

<sect2 id="treeview-model-treestore">
<title>TreeStore, für eine Hierarchie</title>
<para>
The <classname>TreeStore</classname> contains rows of data, and each row may
have child rows.
</para>

<figure id="figure-treeview-treestore-model">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_tree.png"/>
  </screenshot>
</figure>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeStore.html">Referenz</ulink></para>

</sect2>

<sect2 id="treeview-model-columns">
<title>Model Columns</title>
<para>
The <classname>TreeModelColumnRecord</classname> class is used to keep track
of the columns and their data types. You add
<classname>TreeModelColumn</classname> instances to the
<classname>ColumnRecord</classname> and then use those
<classname>TreeModelColumns</classname> when getting and setting the data in
model rows. You will probably find it convenient to derive a new
<classname>TreeModelColumnRecord</classname> which has your
<classname>TreeModelColumn</classname> instances as member data.
</para>

<programlisting>class ModelColumns : public Gtk::TreeModelColumnRecord
{
public:

  ModelColumns()
    { add(m_col_text); add(m_col_number); }

  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  Gtk::TreeModelColumn&lt;int&gt; m_col_number;
};

ModelColumns m_Columns;</programlisting>

<para>
You specify the <classname>ColumnRecord</classname> when creating the Model,
like so:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =
    Gtk::ListStore::create(m_Columns);</programlisting>
<para>Note that the instance (such as m_Columns here) should usually not be static, because it often needs to be instantiated after
glibmm has been instantiated.</para>
</sect2>

<sect2 id="treeview-adding-rows">
<title>Hinzufügen von Zeilen</title>
<para>
Add rows to the model with the <methodname>append()</methodname>,
<methodname>prepend()</methodname>, or <methodname>insert()</methodname> methods.
</para>
<programlisting>Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();</programlisting>
<para>You can dereference the iterator to get the Row:
</para>
<programlisting>Gtk::TreeModel::Row row = *iter;</programlisting>
<sect3 id="treeview-adding-child-rows"><title>Hinzufügen von Unterzeilen</title>
<para>
<classname>Gtk::TreeStore</classname> models can have child items. Add them
with the <methodname>append()</methodname>, <methodname>prepend()</methodname>, or
<methodname>insert()</methodname> methods, like so:
</para>
<programlisting>Gtk::TreeModel::iterator iter_child =
    m_refListStore-&gt;append(row.children());</programlisting>
</sect3>

</sect2>

<sect2 id="treeview-setting-values">
<title>Festlegen von Werten</title>
<para>
You can use the <methodname>operator[]</methodname> override to set the data for a
particular column in the row, specifying the
<classname>TreeModelColumn</classname> used to create the model.
</para>
<programlisting>row[m_Columns.m_col_text] = "sometext";</programlisting>
</sect2>

<sect2 id="treeview-getting-values">
<title>Ermitteln von Werten</title>
<para>
You can use the <methodname>operator[]</methodname> override to get the data in a
particular column in a row, specifiying the
<classname>TreeModelColumn</classname> used to create the model.
</para>
<programlisting>Glib::ustring strText = row[m_Columns.m_col_text];
int number = row[m_Columns.m_col_number];</programlisting>
<para>
The compiler will complain if you use an inappropriate type. For
instance, this would generate a compiler error:
</para>
<programlisting>//compiler error - no conversion from ustring to int.
int number = row[m_Columns.m_col_text];</programlisting>
</sect2>

<sect2 id="treeview-hidden-columns">
<title>»Verborgene« Spalten</title>
<para>
You might want to associate extra data with each row. If so, just add
it as a Model column, but don't add it to the View.
</para>
</sect2>

</sect1>

<sect1 id="sec-treeview">
<title>Die Ansicht</title>
<para>
The View is the actual widget (<classname>Gtk::TreeView</classname>) that
displays the model (<classname>Gtk::TreeModel</classname>) data and allows the
user to interact with it. The View can show all of the model's columns, or just
some, and it can show them in various ways.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeView.html">Referenz</ulink></para>

<sect2 id="sec-treeview-using-a-model">
<title>Verwendung eines Modells</title>
<para>
You can specify a <classname>Gtk::TreeModel</classname> when constructing the
<classname>Gtk::TreeView</classname>, or you can use the
<methodname>set_model()</methodname> method, like so:
</para>
<programlisting>m_TreeView.set_model(m_refListStore);</programlisting>
</sect2>

<sect2 id="treeview-adding-view-columns">
<title>Adding View Columns</title>
<para>
You can use the <methodname>append_column()</methodname> method to  tell the View
that it should display certain Model columns, in a certain order, with a
certain column title.
</para>
<programlisting>m_TreeView.append_column("Messages", m_Columns.m_col_text);</programlisting>
<para>
When using this simple <methodname>append_column()</methodname> override, the
<classname>TreeView</classname> will display the model data with an appropriate
<classname>CellRenderer</classname>. For instance, strings and numbers are
shown in a simple <classname>Gtk::Entry</classname> widget, and booleans are
shown in a <classname>Gtk::CheckButton</classname>. This is usually what you
need. For other column types you must either connect a callback that converts
your type into a string representation, with
<methodname>TreeViewColumn::set_cell_data_func()</methodname>, or derive a custom
<classname>CellRenderer</classname>. Note that (unsigned) short is not
supported by default - You could use (unsigned) int or (unsigned) long as the
column type instead.
</para>
</sect2>

<sect2 id="treeview-multiple-model-columns-per-view-column">
<title>More than one Model Column per View Column</title>
<para>
To render more than one model column in a view column, you need to create the
<classname>TreeView::Column</classname> widget manually, and use
<methodname>pack_start()</methodname> to add the model columns to it.
</para>

<para>
Then use <methodname>append_column()</methodname> to add the view Column to the
View. Notice that <methodname>Gtk::View::append_column()</methodname> is overridden
to accept either a prebuilt <classname>Gtk::View::Column</classname> widget, or
just the <classname>TreeModelColumn</classname> from which it generates an
appropriate <classname>Gtk::View::Column</classname> widget.
</para>
<para>
Here is some example code from
<filename>demos/gtk-demo/example_stockbrowser.cc</filename>, which has a pixbuf
icon and a text name in the same column:
</para>
<programlisting>Gtk::TreeView::Column* pColumn =
    Gtk::manage( new Gtk::TreeView::Column("Symbol") );

// m_columns.icon and m_columns.symbol are columns in the model.
// pColumn is the column in the TreeView:
pColumn-&gt;pack_start(m_columns.icon, false); //false = don't expand.
pColumn-&gt;pack_start(m_columns.symbol);

m_TreeView.append_column(*pColumn);</programlisting>
</sect2>

<sect2 id="treeview-cellrenderer-details">
<title>Specifying CellRenderer details</title>
<para>
The default <classname>CellRenderers</classname> and their default behaviour
will normally suffice, but you might occasionally need finer control. For
instance, this example code from
<filename>demos/gtk-demo/example_treestore.cc</filename>, manually constructs a
<classname>Gtk::CellRenderer</classname> widget and instructs it to render the
data from various model columns through various aspects of its appearance.
</para>
<programlisting>Gtk::CellRendererToggle* pRenderer =
    Gtk::manage( new Gtk::CellRendererToggle() );
int cols_count = m_TreeView.append_column("Alex", *pRenderer);
Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);
if(pColumn)
{
  pColumn-&gt;add_attribute(pRenderer-&gt;property_active(),
      m_columns.alex);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(),
      m_columns.visible);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(),
      m_columns.world);</programlisting>

<para>
    You can also connect to <classname>CellRenderer</classname> signals to detect user
actions. For instance:
</para>
<programlisting>Gtk::CellRendererToggle* pRenderer =
    Gtk::manage( new Gtk::CellRendererToggle() );
pRenderer-&gt;signal_toggled().connect(
    sigc::bind( sigc::mem_fun(*this,
        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)
);</programlisting>
</sect2>

<sect2 id="treeview-editable-cells">
<title>Bearbeitbare Zellen</title>

<sect3 id="treeview-editable-cells-automatic">
<title>Automatically-stored editable cells.</title>
<para>
Cells in a <classname>TreeView</classname> can be edited in-place by the user.
To allow this, use the <classname>Gtk::TreeView</classname>
<methodname>insert_column_editable()</methodname> and
<methodname>append_column_editable()</methodname> methods instead of
<methodname>insert_column()</methodname> and <methodname>append_column()</methodname>.
When these cells are edited the new values will be stored immediately in the
Model. Note that these methods are templates which can only be instantiated for
simple column types such as <classname>Glib::ustring</classname>, int, and
long.
</para>
</sect3>

<sect3 id="treeview-editable-cells-custom">
<title>Implementing custom logic for editable cells.</title>
<para>
However, you might not want the new values to be stored
immediately. For instance, maybe you want to restrict the input to
certain characters or ranges of values.
</para>
<para>
To achieve this, you should use the normal <classname>Gtk::TreeView</classname>
<methodname>insert_column()</methodname> and <methodname>append_column()</methodname>
methods, then use <methodname>get_column_cell_renderer()</methodname> to get the
<classname>Gtk::CellRenderer</classname> used by that column.
</para>
<para>
You should then cast that <classname>Gtk::CellRenderer*</classname> to the
specific <classname>CellRenderer</classname> that you expect, so you can use specific API.
</para>
<para>For instance, for a CellRendererText, you would set the cell's <emphasis>editable</emphasis> property to true, like
so:
</para>
<programlisting>cell.property_editable() = true;</programlisting>
<para>
For a CellRendererToggle, you would set the <emphasis>activatable</emphasis>
property instead.
</para>
<para>You can then connect
to the appropriate "edited" signal. For instance, connect to
<methodname>Gtk::CellRendererText::signal_edited()</methodname>, or
<methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If the column
contains more than one <classname>CellRenderer</classname> then you will need
to use <methodname>Gtk::TreeView::get_column()</methodname> and then call
<methodname>get_cell_renderers()</methodname> on that view Column.
</para>
<para>
In your signal handler, you should examine the new value and then
store it in the Model if that is appropriate for your application.
</para>
</sect3>

</sect2>


</sect1>

<sect1 id="sec-iterating-over-model-rows">
<title>Iterating over Model Rows</title>
<para>
<classname>Gtk::TreeModel</classname> provides a C++ Standard Library-style container of its
children, via the <methodname>children()</methodname> method. You can use the
familiar <methodname>begin()</methodname> and <methodname>end()</methodname> methods
iterator incrementing, like so:
</para>
<programlisting>typedef Gtk::TreeModel::Children type_children; //minimise code length.
type_children children = refModel-&gt;children();
for(type_children::iterator iter = children.begin();
    iter != children.end(); ++iter)
{
  Gtk::TreeModel::Row row = *iter;
  //Do something with the row - see above for set/get.
}</programlisting>

<sect2 id="treeview-row-children">
<title>Row children</title>
<para>
When using a <classname>Gtk::TreeStore</classname>, the rows can have child
rows, which can have their own children in turn. Use
<methodname>Gtk::TreeModel::Row::children()</methodname> to get the container of child <classname>Row</classname>s:
<programlisting>Gtk::TreeModel::Children children = row.children();</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-treeview-selection">
<title>Die Auswahl</title>
<para>
To find out what rows the user has selected, get the
<classname>Gtk::TreeView::Selection</classname> object from the
<classname>TreeView</classname>, like so:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =
    m_TreeView.get_selection();</programlisting>

<sect2 id="treeview-selection-mode">
<title>Einfache oder mehrfache Auswahl</title>
<para>
By default, only single rows can be selected, but you can allow
multiple selection by setting the mode, like so:
<programlisting>refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);</programlisting>
</para>
</sect2>

<sect2 id="treeview-selected-rows">
<title>Die ausgewählten Zeilen</title>
<para>
For single-selection, you can just call <methodname>get_selected()</methodname>,
like so:
</para>
<programlisting>TreeModel::iterator iter = refTreeSelection-&gt;get_selected();
if(iter) //If anything is selected
{
  TreeModel::Row row = *iter;
  //Do something with the row.
}</programlisting>

<para>
For multiple-selection, you need to define a callback, and give it to
<methodname>selected_foreach()</methodname>,
<methodname>selected_foreach_path()</methodname>, or
<methodname>selected_foreach_iter()</methodname>, like so:
</para>
<programlisting>refTreeSelection-&gt;selected_foreach_iter(
    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );

void TheClass::selected_row_callback(
    const Gtk::TreeModel::iterator&amp; iter)
{
  TreeModel::Row row = *iter;
  //Do something with the row.
}</programlisting>

</sect2>

<sect2 id="treeview-selection-changed-signal">
<title>Das »changed«-Signal</title>
<para>
To respond to the user clicking on a row or range of rows, connect to the
signal like so:
</para>
<programlisting>refTreeSelection-&gt;signal_changed().connect(
    sigc::mem_fun(*this, &amp;Example_StockBrowser::on_selection_changed)
);</programlisting>
</sect2>

<sect2 id="treeview-selection-preventing">
<title>Verhindern der Zeilenauswahl</title>
<para>
Maybe the user should not be able to select every item in your list or tree.
For instance, in the gtk-demo, you can select a demo to see the source code,
but it doesn't make any sense to select a demo category.
</para>
<para>
To control which rows can be selected, use the
<methodname>set_select_function()</methodname> method, providing a
<classname>sigc::slot</classname> callback. For instance:
</para>
<programlisting>m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,
    &amp;DemoWindow::select_function) );</programlisting>
<para>
and then
</para>
<programlisting>bool DemoWindow::select_function(
    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
    const Gtk::TreeModel::Path&amp; path, bool)
{
  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);
  return iter-&gt;children().empty(); // only allow leaf nodes to be selected
}</programlisting>
</sect2>

<sect2 id="treeview-selection-changing">
<title>Ändern der Auswahl</title>
<para>
To change the selection, specify a
<classname>Gtk::TreeModel::iterator</classname> or
<classname>Gtk::TreeModel::Row</classname>, like so:
</para>
<programlisting>Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.
if(row)
  refTreeSelection-&gt;select(row);</programlisting>
<para>oder</para>
<programlisting>Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()
if(iter)
  refTreeSelection-&gt;select(iter);</programlisting>
</sect2>

</sect1>


<sect1 id="sec-treeview-sort">
<title>Sortierung</title>
<para>
The standard tree models (<classname>TreeStore</classname> and <classname>ListStore</classname> derive from <classname>TreeSortable</classname>, so they offer sorting functionality. For instance, call <methodname>set_sort_column()</methodname>, to sort the model by the specified column. Or supply a callback function to <methodname>set_sort_func()</methodname> to implement a more complicated sorting algorithm.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeSortable.html">TreeSortable-Referenz</ulink></para>

<sect2 id="treeview-sort-headers">
<title>Sortierung durch Anklicken von Spalten</title>
<para>
So that a user can click on a <classname>TreeView</classname>'s column header to sort the <classname>TreeView</classname>'s contents, call <methodname>Gtk::TreeViewModel::set_sort_column()</methodname>, supplying the model column on which model should be sorted when the header is clicked. For instance:
</para>
<programlisting>Gtk::TreeView::Column* pColumn = treeview.get_column(0);
if(pColumn)
  pColumn-&gt;set_sort_column(m_columns.m_col_id);</programlisting>
</sect2>

<sect2 id="treeview-sort-independent-views">
<title>Independently sorted views of the same model</title>
<para>
The <classname>TreeView</classname> already allows you to show the same <classname>TreeModel</classname> in two <classname>TreeView</classname> widgets. If you need one of these TreeViews to sort the model differently than the other then you should use a <classname>TreeModelSort</classname> instead of just, for instance, <methodname>Gtk::TreeViewModel::set_sort_column()</methodname>. <classname>TreeModelSort</classname> is a model that contains another model, presenting a sorted version of that model. For instance, you might add a sorted version of a model to a <classname>TreeView</classname> like so:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =
    Gtk::TreeModelSort::create(model);
sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);
treeview.set_model(sorted_model);</programlisting>

<para>Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model in order to perform actions on that model. For instance:
</para>
<programlisting>void ExampleWindow::on_button_delete()
{
  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =
      m_treeview.get_selection();
  if(refTreeSelection)
  {
    Gtk::TreeModel::iterator sorted_iter =
        m_refTreeSelection-&gt;get_selected();
    if(sorted_iter)
    {
      Gtk::TreeModel::iterator iter =
          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);
      m_refModel-&gt;erase(iter);
    }
  }
}</programlisting>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModelSort.html">TreeModelSort-Referenz</ulink></para>
</sect2>

</sect1>

<sect1 id="sec-treeview-draganddrop">
<title>Ziehen und Ablegen</title>
<para>
<classname>Gtk::TreeView</classname> already implments simple drag-and-drop
when used with the <classname>Gtk::ListStore</classname> or
<classname>Gtk::TreeStore</classname> models. If necessary, it also allows you
to implement more complex behaviour when items are dragged and dropped, using
the normal <link linkend="chapter-draganddrop">Drag and Drop</link> API.
</para>

<sect2 id="treeview-reorderable-rows">
<title>Neu sortierbare Zeilen</title>
<para>
If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then your
TreeView's items can be moved within the treeview itself. This is demonstrated
in the <classname>TreeStore</classname> example.
</para>
<para>However, this does not allow you any control of which items can be dragged, and where they can be dropped. If you need that extra control then you might create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the <literal>Gtk::TreeDragSource::row_draggable()</literal> and <literal>Gdk::TreeDragDest::row_drop_possible()</literal> virtual methods. You can examine the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow dragging or dropping by return <literal>true</literal> or <literal>false</literal>.</para>
<para>This is demonstrated in the drag_and_drop example.</para>
</sect2>

</sect1>

<sect1 id="sec-treeview-contextmenu">
<title>Popup-Kontextmenü</title>
<para>
Lots of people need to implement right-click context menus for
<classname>TreeView</classname>'s so we will explain how to do that  here to
save you some time. Apart from one or two points, it's  much the same as a
normal context menu, as described in the <link linkend="sec-menus-popup">menus
    chapter</link>.
</para>

<sect2 id="treeview-button-press-event">
<title>Handling <literal>button_press_event</literal></title>
<para>
To detect a click of the right mouse button, you need to handle the
<literal>button_press_event</literal> signal, and check exactly which button
was pressed. Because the <classname>TreeView</classname> normally handles this
signal completely, you need to either override the default signal handler in a
derived <classname>TreeView</classname> class, or use
<methodname>connect_nofify()</methodname> instead of <methodname>connect()</methodname>.
You probably also want to call the default handler before doing anything else,
so that the right-click will cause the row to be selected first.
</para>
<para>This is demonstrated in the Popup Custom Menu example.</para>
</sect2>

</sect1>

<sect1 id="sec-treeview-examples"><title>Beispiele</title>

<sect2 id="liststore-example"><title>ListStore</title>
<para>
This example has a <classname>Gtk::TreeView</classname> widget, with a
<classname>Gtk::ListStore</classname> model.
</para>


<figure id="figure-treeview-liststore">
  <title>TreeView - ListStore</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_list.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/treeview/list/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_number); add(m_col_percentage);}

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;short&gt; m_col_number;
    Gtk::TreeModelColumn&lt;int&gt; m_col_percentage;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (ListStore) example");
  set_border_width(5);
  set_default_size(400, 200);

  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  row[m_Columns.m_col_number] = 10;
  row[m_Columns.m_col_percentage] = 15;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";
  row[m_Columns.m_col_number] = 20;
  row[m_Columns.m_col_percentage] = 40;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";
  row[m_Columns.m_col_number] = 30;
  row[m_Columns.m_col_percentage] = 70;

  //Add the TreeView's view columns:
  //This number will be shown with the default numeric formatting.
  m_TreeView.append_column("ID", m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_Columns.m_col_name);

  m_TreeView.append_column_numeric("Formatted number", m_Columns.m_col_number,
          "%010d" /* 10 digits, using leading zeroes. */);

  //Display a progress bar instead of a decimal number:
  Gtk::CellRendererProgress* cell = Gtk::manage(new Gtk::CellRendererProgress);
  int cols_count = m_TreeView.append_column("Some percentage", *cell);
  Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count - 1);
  if(pColumn)
  {
    pColumn-&gt;add_attribute(cell-&gt;property_value(), m_Columns.m_col_percentage);
  }

  //Make all the columns reorderable:
  //This is not necessary, but it's nice to show the feature.
  //You can use TreeView::set_column_drag_function() to more
  //finely control column drag and drop.
  for(guint i = 0; i &lt; 2; i++)
  {
    Gtk::TreeView::Column* pColumn = m_TreeView.get_column(i);
    pColumn-&gt;set_reorderable();
  }

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="treestore-example"><title>TreeStore</title>

<para>
This example is very similar to the <classname>ListStore</classname> example,
but uses a <classname>Gtk::TreeStore</classname> model instead, and adds
children to the rows.
</para>

<figure id="figure-treeview-treestore">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_tree.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/treeview/tree/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();
  void on_treeview_row_activated(const Gtk::TreeModel::Path&amp; path, Gtk::TreeViewColumn* column);
   
  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refTreeModel;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (TreeStore) example");
  set_border_width(5);
  set_default_size(400, 200);

  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //All the items to be reordered with drag-and-drop:
  m_TreeView.set_reorderable();

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";

  Gtk::TreeModel::Row childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";


  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";

  //Add the TreeView's view columns:
  m_TreeView.append_column("ID", m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_Columns.m_col_name);

  //Connect signal:
  m_TreeView.signal_row_activated().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_treeview_row_activated) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_treeview_row_activated(const Gtk::TreeModel::Path&amp; path,
        Gtk::TreeViewColumn* /* column */)
{
  Gtk::TreeModel::iterator iter = m_refTreeModel-&gt;get_iter(path);
  if(iter)
  {
    Gtk::TreeModel::Row row = *iter;
    std::cout &lt;&lt; "Row activated: ID=" &lt;&lt; row[m_Columns.m_col_id] &lt;&lt; ", Name="
        &lt;&lt; row[m_Columns.m_col_name] &lt;&lt; std::endl;
  }
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="sec-editable-cells-example"><title>Bearbeitbare Zellen</title>

<para>
This example is identical to the <classname>ListStore</classname> example, but
it uses <methodname>TreeView::append_column_editable()</methodname> instead of
<methodname>TreeView::append_column()</methodname>.
</para>

<figure id="figure-treeview-editablecells">
  <title>TreeView - Bearbeitbare Zellen</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_editablecells.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/treeview/editable_cells/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  void treeviewcolumn_validated_on_cell_data(Gtk::CellRenderer* renderer, const Gtk::TreeModel::iterator&amp; iter);
  void cellrenderer_validated_on_editing_started(Gtk::CellEditable* cell_editable, const Glib::ustring&amp; path);
  void cellrenderer_validated_on_edited(const Glib::ustring&amp; path_string, const Glib::ustring&amp; new_text);

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_foo); add(m_col_number); add(m_col_number_validated); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_foo;
    Gtk::TreeModelColumn&lt;int&gt; m_col_number;
    Gtk::TreeModelColumn&lt;int&gt; m_col_number_validated;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;

  //For the validated column:
  //You could also use a CellRendererSpin or a CellRendererProgress:
  Gtk::CellRendererText m_cellrenderer_validated;
  Gtk::TreeView::Column m_treeviewcolumn_validated;
  bool m_validate_retry;
  Glib::ustring m_invalid_text_for_retry;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include "examplewindow.h"

using std::sprintf;
using std::strtol;

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit"),
  m_validate_retry(false)
{
  set_title("Gtk::TreeView Editable Cells example");
  set_border_width(5);
  set_default_size(400, 200);


  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_TreeView.set_model(m_refTreeModel);

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  row[m_Columns.m_col_foo] = true;
  row[m_Columns.m_col_number] = 10;

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";
  row[m_Columns.m_col_foo] = true;
  row[m_Columns.m_col_number] = 20;

  row = *(m_refTreeModel-&gt;append());

  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";
  row[m_Columns.m_col_foo] = false;
  row[m_Columns.m_col_number] = 30;

  //Add the TreeView's view columns:
  //We use the *_editable convenience methods for most of these,
  //because the default functionality is enough:
  m_TreeView.append_column_editable("ID", m_Columns.m_col_id);
  m_TreeView.append_column_editable("Name", m_Columns.m_col_name);
  m_TreeView.append_column_editable("foo", m_Columns.m_col_foo);
  m_TreeView.append_column_numeric_editable("foo", m_Columns.m_col_number,
          "%010d");


  //For this column, we create the CellRenderer ourselves, and connect our own
  //signal handlers, so that we can validate the data that the user enters, and
  //control how it is displayed.
  m_treeviewcolumn_validated.set_title("validated (&lt;10)");
  m_treeviewcolumn_validated.pack_start(m_cellrenderer_validated);
  m_TreeView.append_column(m_treeviewcolumn_validated);

  //Tell the view column how to render the model values:
  m_treeviewcolumn_validated.set_cell_data_func(m_cellrenderer_validated,
          sigc::mem_fun(*this,
              &amp;ExampleWindow::treeviewcolumn_validated_on_cell_data) );

  //Make the CellRenderer editable, and handle its editing signals:
  m_cellrenderer_validated.property_editable() = true;

  m_cellrenderer_validated.signal_editing_started().connect(
          sigc::mem_fun(*this,
        &amp;ExampleWindow::cellrenderer_validated_on_editing_started) );

  m_cellrenderer_validated.signal_edited().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::cellrenderer_validated_on_edited) );

  //If this was a CellRendererSpin then you would have to set the adjustment:
  //m_cellrenderer_validated.property_adjustment() = m_spin_adjustment;

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::treeviewcolumn_validated_on_cell_data(
        Gtk::CellRenderer* /* renderer */,
        const Gtk::TreeModel::iterator&amp; iter)
{
  //Get the value from the model and show it appropriately in the view:
  if(iter)
  {
    Gtk::TreeModel::Row row = *iter;
    int model_value = row[m_Columns.m_col_number_validated];

    //This is just an example.
    //In this case, it would be easier to use append_column_editable() or
    //append_column_numeric_editable()
    char buffer[32];
    sprintf(buffer, "%d", model_value); 

    Glib::ustring view_text = buffer;
    m_cellrenderer_validated.property_text() = view_text;
  }
}

void ExampleWindow::cellrenderer_validated_on_editing_started(
        Gtk::CellEditable* cell_editable, const Glib::ustring&amp; /* path */)
{
  //Start editing with previously-entered (but invalid) text, 
  //if we are allowing the user to correct some invalid data. 
  if(m_validate_retry)
  {
    //This is the CellEditable inside the CellRenderer. 
    Gtk::CellEditable* celleditable_validated = cell_editable;

    //It's usually an Entry, at least for a CellRendererText:
    Gtk::Entry* pEntry = dynamic_cast&lt;Gtk::Entry*&gt;(celleditable_validated);
    if(pEntry)
    {
      pEntry-&gt;set_text(m_invalid_text_for_retry);
      m_validate_retry = false;
      m_invalid_text_for_retry.clear();
    }
  }

}

void ExampleWindow::cellrenderer_validated_on_edited(
        const Glib::ustring&amp; path_string,
        const Glib::ustring&amp; new_text)
{
  Gtk::TreePath path(path_string);

  //Convert the inputed text to an integer, as needed by our model column:
  char* pchEnd = 0;
  int new_value = strtol(new_text.c_str(), &amp;pchEnd, 10);

  if(new_value &gt; 10)
  {
    //Prevent entry of numbers higher than 10.

    //Tell the user:
    Gtk::MessageDialog dialog(*this,
            "The number must be less than 10. Please try again.",
            false, Gtk::MESSAGE_ERROR);
    dialog.run();

    //Start editing again, with the bad text, so that the user can correct it.
    //A real application should probably allow the user to revert to the
    //previous text.

    //Set the text to be used in the start_editing signal handler:
    m_invalid_text_for_retry = new_text;
    m_validate_retry = true;

    //Start editing again:
    m_TreeView.set_cursor(path, m_treeviewcolumn_validated,
            m_cellrenderer_validated, true /* start_editing */);
  }
  else
  {
    //Get the row from the path:
    Gtk::TreeModel::iterator iter = m_refTreeModel-&gt;get_iter(path);
    if(iter)
    {
      Gtk::TreeModel::Row row = *iter;

      //Put the new value in the model:
      row[m_Columns.m_col_number_validated] = new_value;
    }
  }
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="treeview-dnd-example"><title>Ziehen und Ablegen</title>

<para>
This example is much like the <classname>TreeStore</classname> example, but has
2 extra columns to indicate whether the row can be dragged, and whether it can
receive drag-and-dropped rows. It uses a derived
<classname>Gtk::TreeStore</classname> which overrides the virtual functions as
described in the <link linkend="sec-treeview-draganddrop">TreeView Drag and
    Drop</link> section..
</para>

<figure id="figure-treeview-draganddrop">
  <title>TreeView - Ziehen und Ablegen</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_draganddrop.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/treeview/drag_and_drop/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>treemodel_dnd.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_TREEMODEL_DND_H
#define GTKMM_EXAMPLE_TREEMODEL_DND_H

#include &lt;gtkmm.h&gt;

class TreeModel_Dnd : public Gtk::TreeStore
{
protected:
  TreeModel_Dnd();

public:

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); add(m_col_draggable); add(m_col_receivesdrags); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_draggable;
    Gtk::TreeModelColumn&lt;bool&gt; m_col_receivesdrags;
  };

  ModelColumns m_Columns;

  static Glib::RefPtr&lt;TreeModel_Dnd&gt; create();

protected:
  //Overridden virtual functions:
  virtual bool row_draggable_vfunc(const Gtk::TreeModel::Path&amp; path) const;
  virtual bool row_drop_possible_vfunc(const Gtk::TreeModel::Path&amp; dest, const Gtk::SelectionData&amp; selection_data) const;
  
};

#endif //GTKMM_EXAMPLE_TREEMODEL_DND_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "treemodel_dnd.h"


class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();


  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TreeView m_TreeView;
  Glib::RefPtr&lt;TreeModel_Dnd&gt; m_refTreeModel;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>treemodel_dnd.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "treemodel_dnd.h"
#include &lt;iostream&gt;

TreeModel_Dnd::TreeModel_Dnd()
{
  //We can't just call Gtk::TreeModel(m_Columns) in the initializer list
  //because m_Columns does not exist when the base class constructor runs.
  //And we can't have a static m_Columns instance, because that would be
  //instantiated before the gtkmm type system.
  //So, we use this method, which should only be used just after creation:
  set_column_types(m_Columns);
}

Glib::RefPtr&lt;TreeModel_Dnd&gt; TreeModel_Dnd::create()
{
  return Glib::RefPtr&lt;TreeModel_Dnd&gt;( new TreeModel_Dnd() );
}

bool
TreeModel_Dnd::row_draggable_vfunc(const Gtk::TreeModel::Path&amp; path) const
{
  // Make the value of the "draggable" column determine whether this row can
  // be dragged:

  //TODO: Add a const version of get_iter to TreeModel:
  TreeModel_Dnd* unconstThis = const_cast&lt;TreeModel_Dnd*&gt;(this);
  const_iterator iter = unconstThis-&gt;get_iter(path);
  //const_iterator iter = get_iter(path);
  if(iter)
  {
    Row row = *iter;
    bool is_draggable = row[m_Columns.m_col_draggable];
    return is_draggable;
  }

  return Gtk::TreeStore::row_draggable_vfunc(path);
}

bool
TreeModel_Dnd::row_drop_possible_vfunc(const Gtk::TreeModel::Path&amp; dest,
        const Gtk::SelectionData&amp; selection_data) const
{
  //Make the value of the "receives drags" column determine whether a row can be
  //dragged into it:

  //dest is the path that the row would have after it has been dropped:
  //But in this case we are more interested in the parent row:
  Gtk::TreeModel::Path dest_parent = dest;
  bool dest_is_not_top_level = dest_parent.up();
  if(!dest_is_not_top_level || dest_parent.empty())
  {
    //The user wants to move something to the top-level.
    //Let's always allow that.
  }
  else
  {
    //Get an iterator for the row at this path:
    //We must unconst this. This should not be necessary with a future version
    //of gtkmm.
    //TODO: Add a const version of get_iter to TreeModel:
    TreeModel_Dnd* unconstThis = const_cast&lt;TreeModel_Dnd*&gt;(this);
    const_iterator iter_dest_parent = unconstThis-&gt;get_iter(dest_parent);
    //const_iterator iter_dest_parent = get_iter(dest);
    if(iter_dest_parent)
    {
      Row row = *iter_dest_parent;
      bool receives_drags = row[m_Columns.m_col_receivesdrags];
      return receives_drags;
    }
  }

  //You could also examine the row being dragged (via selection_data)
  //if you must look at both rows to see whether a drop should be allowed.
  //You could use
  //TODO: Add const version of get_from_selection_data(): Glib::RefPtr&lt;const
  //Gtk::TreeModel&gt; refThis = Glib::RefPtr&lt;const Gtk::TreeModel&gt;(this);
  //
  //Glib::RefPtr&lt;Gtk::TreeModel&gt; refThis =
  //Glib::RefPtr&lt;Gtk::TreeModel&gt;(const_cast&lt;TreeModel_Dnd*&gt;(this));
  //refThis-&gt;reference(); //, true /* take_copy */)
  //Gtk::TreeModel::Path path_dragged_row;
  //Gtk::TreeModel::Path::get_from_selection_data(selection_data, refThis,
  //path_dragged_row);

  return Gtk::TreeStore::row_drop_possible_vfunc(dest, selection_data);
}

</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit(Gtk::Stock::QUIT)
{
  set_title("Gtk::TreeView (Drag and Drop) example");
  set_border_width(5);
  set_default_size(400, 200);

  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  //Create the Tree model:
  //Use our derived model, which overrides some Gtk::TreeDragDest and
  //Gtk::TreeDragSource virtual functions:
  //The columns are declared in the overridden TreeModel.
  m_refTreeModel = TreeModel_Dnd::create();
  m_TreeView.set_model(m_refTreeModel);

  //Enable Drag-and-Drop of TreeView rows:
  //See also the derived TreeModel's *_vfunc overrides.
  m_TreeView.enable_model_drag_source();
  m_TreeView.enable_model_drag_dest();

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 1;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Billy Bob";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  Gtk::TreeModel::Row childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 11;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Billy Bob Junior";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 12;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Sue Bob";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 2;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Joey Jojo";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  row = *(m_refTreeModel-&gt;append());
  row[m_refTreeModel-&gt;m_Columns.m_col_id] = 3;
  row[m_refTreeModel-&gt;m_Columns.m_col_name] = "Rob McRoberts";
  row[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  row[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_refTreeModel-&gt;m_Columns.m_col_id] = 31;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_name] = "Xavier McRoberts";
  childrow[m_refTreeModel-&gt;m_Columns.m_col_draggable] = true;
  childrow[m_refTreeModel-&gt;m_Columns.m_col_receivesdrags] = true;

  //Add the TreeView's view columns:
  m_TreeView.append_column("ID", m_refTreeModel-&gt;m_Columns.m_col_id);
  m_TreeView.append_column("Name", m_refTreeModel-&gt;m_Columns.m_col_name);
  m_TreeView.append_column_editable("Draggable",
          m_refTreeModel-&gt;m_Columns.m_col_draggable);
  m_TreeView.append_column_editable("Receives Drags",
          m_refTreeModel-&gt;m_Columns.m_col_receivesdrags);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="treeview-popup-menu-example"><title>Popup-Kontextmenü</title>

<para>
This example is much like the <classname>ListStore</classname> example, but
derives a custom <classname>TreeView</classname> in order to override the
<literal>button_press_event</literal>, and also to encapsulate the tree model
code in our derived class. See the <link linkend="sec-treeview-contextmenu">TreeView Popup Context Menu</link>
section.
</para>

<figure id="figure-treeview-popup">
  <title>TreeView - Aufklappendes Kontextmenü</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/treeview_popup.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/treeview/popup/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>treeview_withpopup.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H
#define GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H

#include &lt;gtkmm.h&gt;

class TreeView_WithPopup : public Gtk::TreeView
{
public:
  TreeView_WithPopup();
  virtual ~TreeView_WithPopup();

protected:
  // Override Signal handler:
  // Alternatively, use signal_button_press_event().connect_notify()
  virtual bool on_button_press_event(GdkEventButton *ev);

  //Signal handler for popup menu items:
  void on_menu_file_popup_generic();

  
  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;unsigned int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };
  
  ModelColumns m_Columns;

  //The Tree model:
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;

  Gtk::Menu m_Menu_Popup;
};

#endif //GTKMM_EXAMPLE_TREEVIEW_WITHPOPUP_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "treeview_withpopup.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

 

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  TreeView_WithPopup m_TreeView;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>treeview_withpopup.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "treeview_withpopup.h"
#include &lt;iostream&gt;

TreeView_WithPopup::TreeView_WithPopup()
{
  //Create the Tree model:
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  set_model(m_refTreeModel);

  //Fill the TreeView's model
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "right-click on this";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "or this";

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "or this, for a popup context menu";

  //Add the TreeView's view columns:
  append_column("ID", m_Columns.m_col_id);
  append_column("Name", m_Columns.m_col_name);

  //Fill popup menu:
  Gtk::MenuItem* item = Gtk::manage(new Gtk::MenuItem("_Edit"));
  item-&gt;signal_activate().connect(
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic) );
  m_Menu_Popup.append(*item);
    
  item = Gtk::manage(new Gtk::MenuItem("_Process"));
  item-&gt;signal_activate().connect(
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic) );
  m_Menu_Popup.append(*item);
    
  item = Gtk::manage(new Gtk::MenuItem("_Remove"));
  item-&gt;signal_activate().connect(
    sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_menu_file_popup_generic) );
  m_Menu_Popup.append(*item);

  m_Menu_Popup.accelerate(*this);

#ifndef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
  signal_button_press_event()
    .connect(sigc::mem_fun(*this, &amp;TreeView_WithPopup::on_button_press_event), false);
#endif
}

TreeView_WithPopup::~TreeView_WithPopup()
{
}

bool TreeView_WithPopup::on_button_press_event(GdkEventButton* event)
{
  bool return_value = false;

  //Call base class, to allow normal handling,
  //such as allowing the row to be selected by the right-click:
  return_value = TreeView::on_button_press_event(event);

  //Then do our custom stuff:
  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )
  {
    m_Menu_Popup.popup(event-&gt;button, event-&gt;time);
  }

  return return_value;
}

void TreeView_WithPopup::on_menu_file_popup_generic()
{
  std::cout &lt;&lt; "A popup menu item was selected." &lt;&lt; std::endl;

  Glib::RefPtr&lt;Gtk::TreeView::Selection&gt; refSelection = get_selection();
  if(refSelection)
  {
    Gtk::TreeModel::iterator iter = refSelection-&gt;get_selected();
    if(iter)
    {
      int id = (*iter)[m_Columns.m_col_id];
      std::cout &lt;&lt; "  Selected ID=" &lt;&lt; id &lt;&lt; std::endl;
    }
  }
}
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit")
{
  set_title("Gtk::TreeView (ListStore) example");
  set_border_width(5);
  set_default_size(400, 200);

  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TreeView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>


</sect1>

</chapter>


<chapter id="chapter-combobox">
<title>Kombinierte Auswahlfelder</title>

<para>The <classname>ComboBox</classname> widgets offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information about each item, such as text, a picture, a checkbox, or a progress bar. The <classname>ComboBox</classname> widget usually restricts the user to the available choices, but it can optionally have an <classname>Entry</classname>, allowing the user to enter arbitrary text if the none of the available choices are suitable.
</para>

<para>The list is provided via a <classname>TreeModel</classname>, and columns from this model are added to the ComboBox's view with the <methodname>ComboBox::pack_start()</methodname> method. This provides flexibility and compile-time type-safety, but the <classname>ComboBoxText</classname> class provides a simpler text-based specialization in case that flexibility is not required.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ComboBox.html">Referenz</ulink></para>

<sect1 id="sec-combobox-model">
<title>Das Modell</title>
<para>The model for a ComboBox can be defined and filled exactly as for a <classname>TreeView</classname>. For instance, you might derive a ComboBox class with one integer and one text columns, like so:
</para>
<programlisting>ModelColumns()
{ add(m_col_id); add(m_col_name); }

  Gtk::TreeModelColumn&lt;int&gt; m_col_id;
  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
};

ModelColumns m_columns;</programlisting>

<para>After appending rows to this model, you should provide the model to the <classname>ComboBox</classname> with the <methodname>set_model()</methodname> method. Then use the <methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> methods to specify what methods will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the <classname>TreeModelColumn</classname> to the pack methods, or you may instantiate a specific <classname>CellRenderer</classname> and specify a particular mapping with either <methodname>add_attribute()</methodname> or <methodname>set_cell_data_func()</methodname>. Note that these methods are in the <classname>CellLayout</classname> base class.</para>
</sect1>

<sect1 id="sec-combobox-get">
<title>Das gewählte Objekt</title>
<para>To discover what item, if any, the user has chosen from the ComboBox, call <methodname>ComboBox::get_active()</methodname>. This returns a <classname>TreeModel::iterator</classname> that you can dereference to a <classname>Row</classname> in order to read the values in your columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable description in the Combo. For instance:
</para>
<programlisting>Gtk::TreeModel::iterator iter = m_Combo.get_active();
if(iter)
{
  Gtk::TreeModel::Row row = *iter;

  //Get the data for the selected row, using our knowledge
  //of the tree model:
  int id = row[m_Columns.m_col_id];
  set_something_id_chosen(id); //Your own function.
}
else
  set_nothing_chosen(); //Your own function.</programlisting>
</sect1>

<sect1 id="sec-combobox-changes">
<title>Reaktion auf Änderungen</title>
<para>
You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the "changed" signal. For instance:
</para>
<programlisting>m_combo.signal_changed().connect( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_combo_changed) );</programlisting>
</sect1>

<sect1 id="combobox-example-full"><title>Vollständiges Beispiel</title>

<figure id="figure-combobox-complex">
  <title>ComboBox</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/combobox_complex.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/combobox/complex?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;
#include &lt;gtkmm/liststore.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:  
  //Signal handlers:
  void on_combo_changed();

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_id;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::ComboBox m_Combo;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("ComboBox example");

  //Create the Tree model:
  //m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_Combo.set_model(m_refTreeModel);

  //Fill the ComboBox's Tree Model:
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 1;
  row[m_Columns.m_col_name] = "Billy Bob";
  /*
  Gtk::TreeModel::Row childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";
  */

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 2;
  row[m_Columns.m_col_name] = "Joey Jojo";


  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = 3;
  row[m_Columns.m_col_name] = "Rob McRoberts";

  /*
  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";
  */

  //Add the model columns to the Combo (which is a kind of view),
  //rendering them in the default way:
  m_Combo.pack_start(m_Columns.m_col_id);
  m_Combo.pack_start(m_Columns.m_col_name);

  //Add the ComboBox to the window.
  add(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_changed) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_changed()
{
  Gtk::TreeModel::iterator iter = m_Combo.get_active();
  if(iter)
  {
    Gtk::TreeModel::Row row = *iter;
    if(row)
    {
      //Get the data for the selected row, using our knowledge of the tree
      //model:
      int id = row[m_Columns.m_col_id];
      Glib::ustring name = row[m_Columns.m_col_name];

      std::cout &lt;&lt; " ID=" &lt;&lt; id &lt;&lt; ", name=" &lt;&lt; name &lt;&lt; std::endl;
    }
  }
  else
    std::cout &lt;&lt; "invalid iter" &lt;&lt; std::endl;
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

<sect1 id="combobox-example-simple"><title>Einfaches Textbeispiel</title>

<figure id="figure-combobox-text">
  <title>ComboBox</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/combobox_text.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/combobox/text?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();

  //Child widgets:
  Gtk::ComboBoxText m_Combo;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("ComboBoxText example");

  //Fill the combo:
  m_Combo.append("something");
  m_Combo.append("something else");
  m_Combo.append("something or other");

  add(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_combo_changed) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_changed()
{
  Glib::ustring text = m_Combo.get_active_text();
  if(!(text.empty()))
    std::cout &lt;&lt; "Combo changed: " &lt;&lt; text &lt;&lt; std::endl;
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

<sect1 id="sec-comboboxentry">
<title>ComboBox with an Entry</title>

<para>A <classname>ComboBox</classname> may contain an <classname>Entry</classname> widget for entering of arbitrary text, by specifying true for the constructor's <literal>has_entry</literal> parameter.</para>

<sect2 id="sec-comboboxentry-text-column">
<title>Die Textspalte</title>
<para>So that the Entry can interact with the drop-down list of choices, you must specify which of your model columns is the text column, with <methodname>set_text_column()</methodname>. For instance:
<programlisting>m_combo.set_text_column(m_columns.m_col_name);</programlisting>
</para>
<para>
When you select a choice from the drop-down menu, the value from this column will be placed in the <classname>Entry</classname>.
</para>
</sect2>

<sect2 id="sec-comboboxentry-model">
<title>Der Eintrag</title>
<para>Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has inputted. Therefore, you should retrieve the <classname>Entry</classname> widget with the <methodname>ComboBoxEntry::get_entry()</methodname> method and call <methodname>get_text()</methodname> on that.
</para>
</sect2>

<sect2 id="comboboxentry-example-full"><title>Vollständiges Beispiel</title>

<figure id="figure-comboboxentry-complex">
  <title>ComboBoxEntry</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/comboboxentry_complex.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/combobox/entry_complex?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/combobox.h&gt;
#include &lt;gtkmm/liststore.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();

  //Tree model columns:
  class ModelColumns : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumns()
    { add(m_col_id); add(m_col_name); }

    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_id; //The data to choose - this must be text.
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumns m_Columns;

  //Child widgets:
  Gtk::ComboBox m_Combo;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModel;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Combo(true /* has_entry */)
{
  set_title("ComboBox example");

  //Create the Tree model:
  //m_refTreeModel = Gtk::TreeStore::create(m_Columns);
  m_refTreeModel = Gtk::ListStore::create(m_Columns);
  m_Combo.set_model(m_refTreeModel);

  //Fill the ComboBox's Tree Model:
  Gtk::TreeModel::Row row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "1";
  row[m_Columns.m_col_name] = "Billy Bob";
  /*
  Gtk::TreeModel::Row childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 11;
  childrow[m_Columns.m_col_name] = "Billy Bob Junior";

  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 12;
  childrow[m_Columns.m_col_name] = "Sue Bob";
  */

  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "2";
  row[m_Columns.m_col_name] = "Joey Jojo";


  row = *(m_refTreeModel-&gt;append());
  row[m_Columns.m_col_id] = "3";
  row[m_Columns.m_col_name] = "Rob McRoberts";

  /*
  childrow = *(m_refTreeModel-&gt;append(row.children()));
  childrow[m_Columns.m_col_id] = 31;
  childrow[m_Columns.m_col_name] = "Xavier McRoberts";
  */

  //Add the model columns to the Combo (which is a kind of view),
  //rendering them in the default way:
  //This is automatically rendered when we use set_entry_text_column().
  //m_Combo.pack_start(m_Columns.m_col_id);
  m_Combo.pack_start(m_Columns.m_col_name);

  m_Combo.set_entry_text_column(m_Columns.m_col_id);

  //Add the ComboBox to the window.
  add(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_combo_changed) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_changed()
{
  Gtk::Entry* entry = m_Combo.get_entry();
  //Note: to get changes only when the entry has been completed,
  //instead of on every key press, connect to Entry::signal_changed()
  //instead of ComboBoxEntry::signal_changed.

  if(entry)
  {
    std::cout &lt;&lt; " ID=" &lt;&lt; entry-&gt;get_text() &lt;&lt; std::endl;
  }
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="comboboxentry-example-simple"><title>Einfaches Textbeispiel</title>

<figure id="figure-comboboxentry-text">
  <title>ComboBoxEntryText</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/comboboxentry_text.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/combobox/entry_text?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/comboboxtext.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_combo_changed();

  //Child widgets:
  Gtk::ComboBoxText m_Combo;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Combo(true /* has_entry */)
{
  set_title("ComboBoxText example");

  //Fill the combo:
  m_Combo.append("something");
  m_Combo.append("something else");
  m_Combo.append("something or other");

  add(m_Combo);

  //Connect signal handler:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_combo_changed) );

  m_Combo.property_has_frame() = false;
  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_changed()
{
  Glib::ustring text = m_Combo.get_active_text();
  if(!(text.empty()))
    std::cout &lt;&lt; "Combo changed: " &lt;&lt; text &lt;&lt; std::endl;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>




</sect1>

</chapter>


<chapter id="chapter-textview">
<title>TextView</title>
<para>
The <classname>TextView</classname> widget can be used to display and edit
large amounts of formatted text. Like the <classname>TreeView</classname>, it
has a model/view design. In this case the <classname>TextBuffer</classname> is
the model.
</para>

<sect1 id="sec-textview-buffer">
<title>Der Puffer</title>
<para>
<classname>Gtk::TextBuffer</classname> is a model containing the data for the
<classname>Gtk::TextView</classname>, like the
<classname>Gtk::TreeModel</classname> used by <classname>Gtk::TreeView</classname>.
This allows two or more <classname>Gtk::TextView</classname>s to share the same
<classname>TextBuffer</classname>, and allows those TextBuffers to be displayed
slightly differently. Or you could maintain several
<classname>Gtk::TextBuffer</classname>s and choose to display each one at different
times in the same <classname>Gtk::TextView</classname> widget.
</para>
<para>
The <classname>TextView</classname> creates its own default
<classname>TextBuffer</classname>, which you can access via the
<methodname>get_buffer()</methodname> method.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextBuffer.html">Referenz</ulink></para>

<sect2 id="textview-iterators">
<title>Iterators</title>
<para>
</para>
</sect2>

<sect2 id="textview-formatting">
<title>Tags und Formatierung</title>

<sect3 id="textview-formatting-tags">
<title>Tags</title>
<para>
To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =
    Gtk::TextBuffer::Tag::create();
refTagMatch-&gt;property_background() = "orange";</programlisting>
<para>
You can specify a name for the <classname>Tag</classname> when using the
<methodname>create()</methodname> method, but it is not necessary.
</para>

<para>
The <classname>Tag</classname> class has many other properties.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTag.html">Referenz</ulink></para>

</sect3>

<sect3 id="textview-formatting-tagtable">
<title>TagTable</title>

<para>
Each <classname>Gtk::TextBuffer</classname> uses a
<classname>Gtk::TextBuffer::TagTable</classname>, which contains the
<classname>Tag</classname>s for that buffer. 2 or more
<classname>TextBuffer</classname>s may share the same
<classname>TagTable</classname>. When you create <classname>Tag</classname>s
you should add them to the <classname>TagTable</classname>. For instance:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =
    Gtk::TextBuffer::TagTable::create();
refTagTable-&gt;add(refTagMatch);
//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,
//for use after creation of the buffer.
Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =
    Gtk::TextBuffer::create(refTagTable);</programlisting>

<para>
You can also use <methodname>get_tag_table()</methodname> to get, and maybe modify,
the <classname>TextBuffer</classname>'s default <classname>TagTable</classname>
instead of creating one explicitly.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTagTable.html">Referenz</ulink></para>

</sect3>

<sect3 id="textview-formatting-applying-tags">
<title>Anwenden von Tags</title>
<para>
If you have created a <classname>Tag</classname> and added it to the
<classname>TagTable</classname>, you may apply that tag to part of the
<classname>TextBuffer</classname> so that some of the text is displayed with that
formatting. You define the start and end of the range of text by specifying
<classname>Gtk::TextBuffer::iterator</classname>s. For instance:
</para>
<programlisting>refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);</programlisting>
<para>
Or you could specify the tag when first inserting the text:
refBuffer-&gt;insert_with_tag(iter, "Some text", refTagMatch);
</para>

<para>
You can apply more than one <classname>Tag</classname> to the same text, by
using <methodname>apply_tag()</methodname> more than once, or by using
<methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s might
specify different values for the same properties, but you can resolve these
conflicts by using <methodname>Tag::set_priority()</methodname>.
</para>

</sect3>
</sect2>

<sect2 id="textview-marks">
<title>Markierungen</title>
<para>
<classname>TextBuffer</classname> iterators are generally invalidated when the
text changes, but you can use a <classname>Gtk::TextBuffer::Mark</classname> to
remember a position in these situations. For instance,
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =
    refBuffer-&gt;create_mark(iter);</programlisting>

<para>
You can then use the <methodname>get_iter()</methodname> method later to create an
iterator for the <classname>Mark</classname>'s new position.
</para>

<para>
There are two built-in <classname>Mark</classname>s - <literal>insert</literal>
and <literal>select_bound</literal>, which you can access with
<classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> and
<methodname>get_selection_bound()</methodname> methods.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextMark.html">Referenz</ulink></para>

</sect2>

<sect2 id="textview-view">
<title>Die Ansicht</title>
<para>
As mentioned above, each <classname>TextView</classname> has a
<classname>TextBuffer</classname>, and one or more
<classname>TextView</classname> can share the same
<classname>TextBuffer</classname>.
</para>

<para>
Like the <classname>TreeView</classname>, you should probably put your
<classname>TextView</classname> inside a <classname>ScrolledWindow</classname>
to allow the user to see and move around the whole text area with
scrollbars.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextView.html">Referenz</ulink></para>

<sect3 id="textview-default-formatting">
<title>Standardformatierung</title>
<para>
<classname>TextView</classname> has various methods which allow you to change
the presentation of the buffer for this particular view. Some of these may be
overridden by the <classname>Gtk::TextTag</classname>s in the buffer, if they
specify the same things. For instance, <methodname>set_left_margin()</methodname>,
<methodname>set_right_margin()</methodname>, <methodname>set_indent()</methodname>,
etc.
</para>
</sect3>

<sect3 id="textview-scrolling">
<title>Rollen</title>
<para>
<classname>Gtk::TextView</classname> has various
<methodname>scroll_to_*()</methodname> methods. These allow you to ensure that a
particular part of the text buffer is visible. For instance, your application's
Find feature might use <methodname>Gtk::TextView::scroll_to_iter()</methodname> to
show the found text.
</para>
</sect3>

</sect2>


</sect1>

<sect1 id="sec-widgets-and-childanchors">
<title>Widgets und ChildAnchors</title>
<para>
You can embed widgets, such as <classname>Gtk::Button</classname>s, in the
text. Each such child widget needs a <classname>ChildAnchor</classname>.
ChildAnchors are associated with <classname>iterators</classname>. For
instance, to create a child anchor at a particular position, use
<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:
</para>
<programlisting>Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =
    refBuffer-&gt;create_child_anchor(iter);</programlisting>

<para>
Then, to add a widget at that position, use
<methodname>Gtk::TextView::add_child_at_anchor()</methodname>:
</para>
<programlisting>m_TextView.add_child_at_anchor(m_Button, refAnchor);</programlisting>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextChildAnchor.html">Referenz</ulink></para>

</sect1>

<sect1 id="sec-textview-examples"><title>Beispiele</title>

<sect2 id="textview-example-simple"><title>Einfaches Beispiel</title>

<figure id="figure-textview">
  <title>TextView</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/textview.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/textview/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  void fill_buffers();
  
  //Signal handlers:
  void on_button_quit();
  void on_button_buffer1();
  void on_button_buffer2();

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;
  
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer1, m_refTextBuffer2;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit, m_Button_Buffer1, m_Button_Buffer2;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit(Gtk::Stock::QUIT),
  m_Button_Buffer1("Use buffer 1"),
  m_Button_Buffer2("Use buffer 2")
{
  set_title("Gtk::TextView example");
  set_border_width(5);
  set_default_size(400, 200);


  add(m_VBox);

  //Add the TreeView, inside a ScrolledWindow, with the button underneath:
  m_ScrolledWindow.add(m_TextView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_VBox.pack_start(m_ScrolledWindow);

  //Add buttons:
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Buffer1, Gtk::PACK_SHRINK);
  m_ButtonBox.pack_start(m_Button_Buffer2, Gtk::PACK_SHRINK);
  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(5);
  m_ButtonBox.set_spacing(5);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);

  //Connect signals:
  m_Button_Quit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );
  m_Button_Buffer1.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_buffer1) );
  m_Button_Buffer2.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_buffer2) );

  fill_buffers();
  on_button_buffer1();

  show_all_children();
}

void ExampleWindow::fill_buffers()
{
  m_refTextBuffer1 = Gtk::TextBuffer::create();
  m_refTextBuffer1-&gt;set_text("This is the text from TextBuffer #1.");

  m_refTextBuffer2 = Gtk::TextBuffer::create();
  m_refTextBuffer2-&gt;set_text(
          "This is some alternative text, from TextBuffer #2.");

}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

void ExampleWindow::on_button_buffer1()
{
  m_TextView.set_buffer(m_refTextBuffer1);
}

void ExampleWindow::on_button_buffer2()
{
  m_TextView.set_buffer(m_refTextBuffer2);
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>

<chapter id="chapter-menus-and-toolbars">
<title>Menüs und Werkzeugleisten</title>

<para>
There are specific APIs for Menus and toolbars, but you should usually deal
with them together, using the <classname>UIManager</classname> to define
<classname>Action</classname>s which you can then arrange in menu and toolbars.
In this way you can handle activation of the action instead of responding to
the menu and toolbar items separately. And you can enable or disable both the
menu and toolbar item via the action.
</para>
<para>
This involves the use of the <classname>Gtk::ActionGroup</classname>,
<classname>Gtk::Action</classname>, and <classname>UIManager</classname>
classes, all of which should be instantiated via their
<methodname>create()</methodname> methods, which return
<classname>RefPtr</classname>s.
</para>

<sect1 id="sec-actions">
<title>Aktionen</title>
<para>
First create the <classname>Action</classname>s and add them to an
<classname>ActionGroup</classname>, with
<methodname>ActionGroup::add()</methodname>.
</para>

<para>
The arguments to <methodname>Action::create()</methodname> specify the action's
name and how it will appear in menus and toolbars. Use stock items where
possible so that you don't need to specify the label, accelerator, icon, and
tooltips, and so you can use pre-existing translations.
</para>
<para>
You can also specify a signal handler when calling
<methodname>ActionGroup::add()</methodname>. This signal handler will be called
when the action is activated via either a menu item or a toolbar button.
</para>
<para>Note that you must specify actions for sub menus as well as menu items.</para>

<para>Zum Beispiel:</para>
<programlisting>m_refActionGroup = Gtk::ActionGroup::create();

m_refActionGroup-&gt;add( Gtk::Action::create("MenuFile", "_File") );
m_refActionGroup-&gt;add( Gtk::Action::create("New", Gtk::Stock::NEW),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );
m_refActionGroup-&gt;add( Gtk::Action::create("ExportData", "Export Data"),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );
m_refActionGroup-&gt;add( Gtk::Action::create("Quit", Gtk::Stock::QUIT),
  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );</programlisting>

<para>Note that this is where we specify the names of the actions as they will be seen by users in menus and toolbars. Therefore, this is where you should make strings translatable, by putting them inside the _() macro. When we use the Gtk::Stock items, of course, translations are automatically available.</para>
</sect1>


<sect1 id="sec-uimanager">
<title>UIManager</title>
<para>
Next you should create a <classname>UIManager</classname> and add the
<classname>ActionGroup</classname> to the <classname>UIManager</classname> with
<methodname>insert_action_group()</methodname> At this point is also a good idea to
tell the parent window to respond to the specified keyboard shortcuts, by using
<methodname>add_accel_group()</methodname>.
</para>

<para>Zum Beispiel,</para>
<programlisting>Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =
    Gtk::UIManager::create();
m_refUIManager-&gt;insert_action_group(m_refActionGroup);
add_accel_group(m_refUIManager-&gt;get_accel_group());</programlisting>
<para>
Then, you can define the actual visible layout of the menus and toolbars, and
add the UI layout to the <classname>UIManager</classname>. This "ui
string" uses an XML format, in which you should mention the names of the
actions that you have already created. For instance:
</para>
<programlisting>Glib::ustring ui_info =
    "&lt;ui&gt;"
    "  &lt;menubar name='MenuBar'&gt;"
    "    &lt;menu action='MenuFile'&gt;"
    "      &lt;menuitem action='New'/&gt;"
    "      &lt;menuitem action='Open'/&gt;"
    "      &lt;separator/&gt;"
    "      &lt;menuitem action='Quit'/&gt;"
    "    &lt;/menu&gt;"
    "    &lt;menu action='MenuEdit'&gt;"
    "      &lt;menuitem action='Cut'/&gt;"
    "      &lt;menuitem action='Copy'/&gt;"
    "      &lt;menuitem action='Paste'/&gt;"
    "    &lt;/menu&gt;"
    "  &lt;/menubar&gt;"
    "  &lt;toolbar  name='ToolBar'&gt;"
    "    &lt;toolitem action='Open'/&gt;"
    "    &lt;toolitem action='Quit'/&gt;"
    "  &lt;/toolbar&gt;"
    "&lt;/ui&gt;";

m_refUIManager-&gt;add_ui_from_string(ui_info);</programlisting>

<para>Remember that these names are just the identifiers that we used when creating the actions. They are not the text that the user will see in the menus and toolbars. We provided those human-readable names when we created the actions.</para>
<para>
To instantiate a <classname>Gtk::MenuBar</classname> or
<classname>Gtk::Toolbar</classname> which you can actually show, you should use
the <methodname>UIManager::get_widget()</methodname> method, and then add the widget
to a container. For instance:
</para>
<programlisting>Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget("/MenuBar");
pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);</programlisting>

</sect1>


<sect1 id="sec-menus-popup"><title>Kontextmenüs</title>
<para>
<classname>Menus</classname> are normally just added to a window, but they can
also be displayed temporarily as the result of a mouse button click. For
instance, a context menu might be displayed when the user clicks their right
mouse button.
</para>

<para>The UI layout for a popup menu should use the <literal>popup</literal> node. For instance:
</para>
<programlisting>Glib::ustring ui_info =
    "&lt;ui&gt;"
    "  &lt;popup name='PopupMenu'&gt;"
    "    &lt;menuitem action='ContextEdit'/&gt;"
    "    &lt;menuitem action='ContextProcess'/&gt;"
    "    &lt;menuitem action='ContextRemove'/&gt;"
    "  &lt;/popup&gt;"
    "&lt;/ui&gt;";

m_refUIManager-&gt;add_ui_from_string(ui_info);</programlisting>

<para>
To show the popup menu, use <classname>Gtk::Menu</classname>'s
<methodname>popup()</methodname> method, providing the button identifier and the
time of activation, as provided by the <literal>button_press_event</literal>
signal, which you will need to handle anyway. For instance:
</para>
<programlisting>bool ExampleWindow::on_button_press_event(GdkEventButton* event)
{
  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
      (event-&gt;button == 3) )
  {
    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);
    return true; //It has been handled.
  }
  else
    return false;
}</programlisting>

</sect1>

<sect1 id="sec-menus-examples">
    <title>Beispiele</title>

<sect2 id="menu-example-main"><title>Hauptmenü-Beispiel</title>

<figure id="figure-menus-mainmenu">
  <title>Hauptmenü</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/main_menu.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/menus/main_menu/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_menu_file_new_generic();
  void on_menu_file_quit();
  void on_menu_others();

  void on_menu_choices_one();
  void on_menu_choices_two();

  //Child widgets:
  Gtk::VBox m_Box;

  Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager;
  Glib::RefPtr&lt;Gtk::ActionGroup&gt; m_refActionGroup;
  Glib::RefPtr&lt;Gtk::RadioAction&gt; m_refChoiceOne, m_refChoiceTwo;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
{
  set_title("main menu example");
  set_default_size(200, 200);

  add(m_Box); // put a MenuBar at the top of the box and other stuff below it.

  //Create actions for menus and toolbars:
  m_refActionGroup = Gtk::ActionGroup::create();

  //File|New sub menu:
  m_refActionGroup-&gt;add(Gtk::Action::create("FileNewStandard",
              Gtk::Stock::NEW, "_New", "Create a new file"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new_generic));

  m_refActionGroup-&gt;add(Gtk::Action::create("FileNewFoo",
              Gtk::Stock::NEW, "New Foo", "Create a new foo"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new_generic));

  m_refActionGroup-&gt;add(Gtk::Action::create("FileNewGoo",
              Gtk::Stock::NEW, "_New Goo", "Create a new goo"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new_generic));

  //File menu:
  m_refActionGroup-&gt;add(Gtk::Action::create("FileMenu", "File"));
  //Sub-menu.
  m_refActionGroup-&gt;add(Gtk::Action::create("FileNew", Gtk::Stock::NEW));
  m_refActionGroup-&gt;add(Gtk::Action::create("FileQuit", Gtk::Stock::QUIT),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_quit));

  //Edit menu:
  m_refActionGroup-&gt;add(Gtk::Action::create("EditMenu", "Edit"));
  m_refActionGroup-&gt;add(Gtk::Action::create("EditCopy", Gtk::Stock::COPY),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));
  m_refActionGroup-&gt;add(Gtk::Action::create("EditPaste", Gtk::Stock::PASTE),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));
  m_refActionGroup-&gt;add(Gtk::Action::create("EditSomething", "Something"),
          Gtk::AccelKey("&lt;control&gt;&lt;alt&gt;S"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others));


  //Choices menu, to demonstrate Radio items
  m_refActionGroup-&gt;add( Gtk::Action::create("ChoicesMenu", "Choices") );
  Gtk::RadioAction::Group group_userlevel;
  m_refChoiceOne = Gtk::RadioAction::create(group_userlevel, "ChoiceOne", "One");
  m_refActionGroup-&gt;add(m_refChoiceOne,
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_choices_one) );
  m_refChoiceTwo = Gtk::RadioAction::create(group_userlevel, "ChoiceTwo", "Two");
  m_refActionGroup-&gt;add(m_refChoiceTwo,
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_choices_two) );

  //Help menu:
  m_refActionGroup-&gt;add( Gtk::Action::create("HelpMenu", "Help") );
  m_refActionGroup-&gt;add( Gtk::Action::create("HelpAbout", Gtk::Stock::HELP),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_others) );

  m_refUIManager = Gtk::UIManager::create();
  m_refUIManager-&gt;insert_action_group(m_refActionGroup);

  add_accel_group(m_refUIManager-&gt;get_accel_group());

  //Layout the actions in a menubar and toolbar:
  Glib::ustring ui_info = 
        "&lt;ui&gt;"
        "  &lt;menubar name='MenuBar'&gt;"
        "    &lt;menu action='FileMenu'&gt;"
        "      &lt;menu action='FileNew'&gt;"
        "        &lt;menuitem action='FileNewStandard'/&gt;"
        "        &lt;menuitem action='FileNewFoo'/&gt;"
        "        &lt;menuitem action='FileNewGoo'/&gt;"
        "      &lt;/menu&gt;"
        "      &lt;separator/&gt;"
        "      &lt;menuitem action='FileQuit'/&gt;"
        "    &lt;/menu&gt;"
        "    &lt;menu action='EditMenu'&gt;"
        "      &lt;menuitem action='EditCopy'/&gt;"
        "      &lt;menuitem action='EditPaste'/&gt;"
        "      &lt;menuitem action='EditSomething'/&gt;"
        "    &lt;/menu&gt;"
        "    &lt;menu action='ChoicesMenu'&gt;"
        "      &lt;menuitem action='ChoiceOne'/&gt;"
        "      &lt;menuitem action='ChoiceTwo'/&gt;"
        "    &lt;/menu&gt;"
        "    &lt;menu action='HelpMenu'&gt;"
        "      &lt;menuitem action='HelpAbout'/&gt;"
        "    &lt;/menu&gt;"
        "  &lt;/menubar&gt;"
        "  &lt;toolbar  name='ToolBar'&gt;"
        "    &lt;toolitem action='FileNewStandard'/&gt;"
        "    &lt;toolitem action='FileQuit'/&gt;"
        "  &lt;/toolbar&gt;"
        "&lt;/ui&gt;";

  try
  {
    m_refUIManager-&gt;add_ui_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt;  ex.what();
  }

  //Get the menubar and toolbar widgets, and add them to a container widget:
  Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget("/MenuBar");
  if(pMenubar)
    m_Box.pack_start(*pMenubar, Gtk::PACK_SHRINK);

  Gtk::Widget* pToolbar = m_refUIManager-&gt;get_widget("/ToolBar") ;
  if(pToolbar)
    m_Box.pack_start(*pToolbar, Gtk::PACK_SHRINK);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_menu_file_quit()
{
  hide(); //Closes the main window to stop the Gtk::Main::run().
}

void ExampleWindow::on_menu_file_new_generic()
{
   std::cout &lt;&lt; "A File|New menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_others()
{
  std::cout &lt;&lt; "A menu item was selected." &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_choices_one()
{
  Glib::ustring message;
  if(m_refChoiceOne-&gt;get_active())
    message = "Choice 1 was selected.";
  else
    message = "Choice 1 was deselected";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_choices_two()
{
  Glib::ustring message;
  if(m_refChoiceTwo-&gt;get_active())
    message = "Choice 2 was selected.";
  else
    message = "Choice 2 was deselected";

  std::cout &lt;&lt; message &lt;&lt; std::endl;
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="menu-example-popup"><title>Kontextmenü-Beispiel</title>

<figure id="figure-menus-popup">
  <title>Kontextmenü</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/menu_popup.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/menus/popup/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  virtual bool on_button_press_event(GdkEventButton* event);
  void on_menu_file_popup_generic();

  //Child widgets:
  Gtk::VBox m_Box;
  Gtk::EventBox m_EventBox;
  Gtk::Label m_Label;

  Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager;
  Glib::RefPtr&lt;Gtk::ActionGroup&gt; m_refActionGroup;

  Gtk::Menu* m_pMenuPopup;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_Label("Right-click to see the popup menu."),
  m_pMenuPopup(0)
  /* m_Image(Gtk::Stock::DIALOG_QUESTION, Gtk::ICON_SIZE_MENU) */
{
  set_title("popup example");
  set_default_size(200, 200);

  add(m_Box);

  //Add an event box that can catch button_press events:
  m_Box.pack_start(m_EventBox);
  m_EventBox.signal_button_press_event().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_press_event) );

  m_EventBox.add(m_Label);

  //Create actions:

  //Fill menu:

  m_refActionGroup = Gtk::ActionGroup::create();

  //File|New sub menu:
  //These menu actions would normally already exist for a main menu, because a
  //context menu should not normally contain menu items that are only available
  //via a context menu.
  m_refActionGroup-&gt;add(Gtk::Action::create("ContextMenu", "Context Menu"));

  m_refActionGroup-&gt;add(Gtk::Action::create("ContextEdit", "Edit"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  m_refActionGroup-&gt;add(Gtk::Action::create("ContextProcess", "Process"),
          Gtk::AccelKey("&lt;control&gt;P"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  m_refActionGroup-&gt;add(Gtk::Action::create("ContextRemove", "Remove"),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic));

  //TODO:
  /*
    //Add a ImageMenuElem:
    menulist.push_back( Gtk::Menu_Helpers::ImageMenuElem("_Something", m_Image,
      sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_popup_generic) ) ) ;
  */

  m_refUIManager = Gtk::UIManager::create();
  m_refUIManager-&gt;insert_action_group(m_refActionGroup);

  add_accel_group(m_refUIManager-&gt;get_accel_group());

  //Layout the actions in a menubar and toolbar:
  Glib::ustring ui_info =
        "&lt;ui&gt;"
        "  &lt;popup name='PopupMenu'&gt;"
        "    &lt;menuitem action='ContextEdit'/&gt;"
        "    &lt;menuitem action='ContextProcess'/&gt;"
        "    &lt;menuitem action='ContextRemove'/&gt;"
        "  &lt;/popup&gt;"
        "&lt;/ui&gt;";

  try
  {
    m_refUIManager-&gt;add_ui_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt;  ex.what();
  }

  //Get the menu:
  m_pMenuPopup = dynamic_cast&lt;Gtk::Menu*&gt;(
          m_refUIManager-&gt;get_widget("/PopupMenu")); 
  if(!m_pMenuPopup)
    g_warning("menu not found");

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_menu_file_popup_generic()
{
   std::cout &lt;&lt; "A popup menu item was selected." &lt;&lt; std::endl;
}

bool ExampleWindow::on_button_press_event(GdkEventButton* event)
{
  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )
  {
    if(m_pMenuPopup)
      m_pMenuPopup-&gt;popup(event-&gt;button, event-&gt;time);

    return true; //It has been handled.
  }
  else
    return false;
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>

<chapter id="chapter-toolpalette">
<title>ToolPalette</title>

<para>A <classname>ToolPalette</classname> is similar to a <classname>Toolbar</classname> but can contain a grid of items, categorized into groups. The user may hide or expand each group. As in a toolbar, the items may be displayed as only icons, as only text, or as icons with text.
</para>
<para>The <classname>ToolPalette</classname>'s items might be dragged or simply activated. For instance, the user might drag objects to a canvas to create new items there. Or the user might click an item to activate a certain brush size in a drawing application.</para>
<para><classname>ToolItemGroup</classname>s should be added to the tool pallete via the base class's <function>Gtk::Container::add()</function> method, for instance like so:
</para>
<para>
<programlisting>
Gtk::ToolItemGroup* group_brushes =
  Gtk::manage(new Gtk::ToolItemGroup("Brushes"));
m_ToolPalette.add(*group_brushes);
</programlisting>
</para>
<para>
<classname>Gtk::ToolItem</classname>s can then be added to the group. For instance, like so:
</para>
<para>
<programlisting>
Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, "Big"));
button-&gt;set_tooltip_text("Big Brush);
group_brushes-&gt;insert(*button);
</programlisting>
</para>
<para>You might then handle the <classname>ToolButton</classname>'s <literal>clicked</literal> signal. Alternatively, you could allow the item to be dragged to another widget, by calling <methodname>Gtk::ToolPalette::add_drag_dest()</methodname> and then using <methodname>Gtk::ToolPalette::get_drag_item()</methodname> in the other widget's <literal>drag_data_received</literal> signal handler.</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToolPalette.html">ToolPalette Reference</ulink></para>
<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToolItemGroup.html">ToolItemGroup Reference</ulink></para>
<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ToolItem.html">ToolItem Reference</ulink></para>

<sect1 id="toolpallete-dranganddrop">
<title>Ziehen und Ablegen</title>
<para>Call <methodname>add_drag_dest()</methodname> to allow items or groups to be dragged from the tool palette to a particular destination widget. You can then use <methodname>get_drag_item()</methodname> to discover which ToolItem or ToolItemGroup is being dragged. You can use <literal>dynamic_cast</literal> to discover whether is it an item or a group. For instance, you might use this in your <literal>drag_data_received</literal> signal handler, to add a dropped item, or to show a suitable icon while dragging.</para>
<para>See the <link linkend="chapter-draganddrop">Drag and Drop</link> chapter for general advice about Drag and Drop with gtkmm.</para>
</sect1>

<sect1 id="toolpalette-example"><title>Beispiel für ToolPalette</title>

<para>This example adds a <classname>ToolPalette</classname> and a <classname>DrawingArea</classname> to a window and allows the user to drag icons from the tool palette to the drawing area. The tool palette contains several groups of items. The combo boxes allow the user to change the style and orientation of the tool palette.</para>

<figure id="figure-toolpalette">
  <title>ToolPalette</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/toolpalette.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/toolpalette/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>canvas.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_CANVAS_H
#define GTKMM_EXAMPLE_CANVAS_H

#include &lt;gtkmm.h&gt;

// This little canvas class is only here 
// because gtkmm does not have a canvas class yet.
// Applications should probably use GooCanvas::Canvas (goocanvasmm) instead.
class Canvas : public Gtk::DrawingArea
{
public:
  Canvas();
  virtual ~Canvas();

private:

  class CanvasItem
  {
  public:
    CanvasItem(Gtk::Widget* canvas, Gtk::ToolButton* button, double x, double y)
    {
      const Gtk::StockID stock_id(button-&gt;get_stock_id()); 
      this-&gt;pixbuf = canvas-&gt;render_icon_pixbuf(stock_id, Gtk::ICON_SIZE_DIALOG);
      this-&gt;x = x;
      this-&gt;y = y;
    }

    Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf;
    double x, y;
  };

  void item_draw(const CanvasItem *item,
    const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr,
    bool preview);

  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);
  virtual void on_drag_data_received(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, 
    int x, int y, const Gtk::SelectionData&amp; selection_data, guint info, guint time);
  virtual bool on_drag_motion(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int x, int y, guint time);
  virtual bool on_drag_drop(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int x, int y, guint time);
  virtual void on_drag_leave(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, guint time);

  bool m_drag_data_requested_for_drop; //So we know what to do in on_drag_data_received().
  CanvasItem* m_drop_item;
  
  typedef std::vector&lt;CanvasItem*&gt; type_vec_items;
  type_vec_items m_canvas_items;
};

#endif //GTKMM_EXAMPLE_CANVAS_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "canvas.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

private:

  void load_stock_items();
  void load_toggle_items();
  void load_special_items();

  //Signal handlers:
  void on_combo_orientation_changed();
  void on_combo_style_changed();

  //Tree model columns:
  class ModelColumnsOrientation : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumnsOrientation()
    { add(m_col_value); add(m_col_name); }

    Gtk::TreeModelColumn&lt;Gtk::Orientation&gt; m_col_value;
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumnsOrientation m_ColumnsOrientation;

  //Tree model columns:
  class ModelColumnsStyle : public Gtk::TreeModel::ColumnRecord
  {
  public:

    ModelColumnsStyle()
    { add(m_col_value); add(m_col_name); }

    Gtk::TreeModelColumn&lt;int&gt; m_col_value; //We use int to also allow -1
    Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
  };

  ModelColumnsStyle m_ColumnsStyle;


  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::HBox m_HBox;
  Gtk::ComboBox m_ComboOrientation;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModelOrientation;
  Gtk::ComboBox m_ComboStyle;
  Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTreeModelStyle;
  Gtk::ToolPalette m_ToolPalette;
  Gtk::ScrolledWindow m_ScrolledWindowPalette;
  Gtk::ScrolledWindow m_ScrolledWindowCanvas;
  Canvas m_Canvas;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

static bool sort_predicate(const Gtk::StockID&amp; a, const Gtk::StockID&amp; b)
{
  return a.get_string() &lt; b.get_string();
}


void ExampleWindow::load_stock_items()
{
  Gtk::ToolItemGroup* group_af = 
    Gtk::manage(new Gtk::ToolItemGroup("Stock Icons (A-F)"));
  m_ToolPalette.add(*group_af);
  Gtk::ToolItemGroup* group_gn = 
    Gtk::manage(new Gtk::ToolItemGroup("Stock Icons (G-N)"));
  m_ToolPalette.add(*group_gn);
  Gtk::ToolItemGroup* group_or = 
    Gtk::manage(new Gtk::ToolItemGroup("Stock Icons (O-R)"));
  m_ToolPalette.add(*group_or);
  Gtk::ToolItemGroup* group_sz = 
    Gtk::manage(new Gtk::ToolItemGroup("Stock Icons (S-Z)"));
  m_ToolPalette.add(*group_sz);

  // Obtain the IDs of all stock items:
  typedef std::vector&lt;Gtk::StockID&gt; type_vecIDs;
  type_vecIDs vecIDs = Gtk::Stock::get_ids();

  std::sort(vecIDs.begin(), vecIDs.end(), &amp;sort_predicate);

  Gtk::ToolItemGroup* group = 0;

  // Iterate through them, populating the ListStore as appropriate:
  for(type_vecIDs::const_iterator iterIDs = vecIDs.begin(); iterIDs != vecIDs.end(); ++iterIDs)
  {
    const Gtk::StockID&amp; stockid = *iterIDs;
    const Glib::ustring str = stockid.get_string();
    if(str.size() &lt; 4)
      continue;

    switch(str[4])
    {
      case 'a':
        group = group_af;
        break;
      case 'g':
        group = group_gn;
        break;
      case 'o':
        group = group_or;
        break;
      case 's':
        group = group_sz;
        break;
      default:
        //Use the previous group
        //(They are sorted.)
        break;
    }

    if(!group)
      continue;

    Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(stockid));
    button-&gt;set_tooltip_text(str);
    button-&gt;set_is_important();
    group-&gt;insert(*button);

    Gtk::StockItem stockitem;
    if(!Gtk::StockItem::lookup(stockid, stockitem) || 
      stockitem.get_label().empty())
        button-&gt;set_label(str);
  }
}


void ExampleWindow::load_toggle_items()
{
  Gtk::ToolItemGroup* group = 
    Gtk::manage(new Gtk::ToolItemGroup("Radio Item"));
  m_ToolPalette.add(*group);

  Gtk::RadioToolButton::Group radio_group;

  for(int i = 1; i &lt;= 10; ++i)
  {
    const Glib::ustring label = Glib::ustring::compose("#%1", i);
    Gtk::RadioToolButton* button = Gtk::manage(new Gtk::RadioToolButton());
    button-&gt;set_group(radio_group);
    button-&gt;set_label(label);
   
    group-&gt;insert(*button);
  }
}


static Gtk::ToolItem* create_entry_item(const Glib::ustring&amp; text)
{
  Gtk::Entry* entry = Gtk::manage(new Gtk::Entry());
  entry-&gt;set_text(text);
  entry-&gt;set_width_chars(5);

  Gtk::ToolItem* item = Gtk::manage(new Gtk::ToolItem());
  item-&gt;add(*entry);

  return item;
}

void ExampleWindow::load_special_items()
{
  Gtk::ToolItemGroup* group = Gtk::manage(new Gtk::ToolItemGroup());

  Gtk::Button *label_button = Gtk::manage(new Gtk::Button("Advanced Features"));
  label_button-&gt;show();
  group-&gt;set_label_widget(*label_button);
  m_ToolPalette.add(*group);

  Gtk::ToolItem* item = create_entry_item ("homogeneous=false");
  group-&gt;insert(*item);
  //TODO: Add Gtk::Container::set_child_property().
  gtk_container_child_set (GTK_CONTAINER (group-&gt;gobj()), GTK_WIDGET (item-&gt;gobj()),
                           "homogeneous", FALSE, NULL);

  item = create_entry_item ("homogeneous=FALSE, expand=TRUE");
  group-&gt;insert(*item);
  gtk_container_child_set (GTK_CONTAINER (group-&gt;gobj()), GTK_WIDGET (item-&gt;gobj()),
                           "homogeneous", FALSE, "expand", TRUE,
                           NULL);

  item = create_entry_item ("homogeneous=FALSE, expand=TRUE, fill=FALSE");
  group-&gt;insert(*item);
  gtk_container_child_set (GTK_CONTAINER (group-&gt;gobj()), GTK_WIDGET (item-&gt;gobj()),
                           "homogeneous", FALSE, "expand", TRUE,
                           "fill", FALSE, NULL);

  item = create_entry_item ("homogeneous=FALSE, expand=TRUE, new-row=TRUE");
  group-&gt;insert(*item);
  gtk_container_child_set (GTK_CONTAINER (group-&gt;gobj()), GTK_WIDGET (item-&gt;gobj()),
                           "homogeneous", FALSE, "expand", TRUE,
                           "new-row", TRUE, NULL);

  item = Gtk::manage(new Gtk::ToolButton(Gtk::Stock::GO_UP));
  item-&gt;set_tooltip_text("Show on vertical palettes only");
  group-&gt;insert(*item);
  item-&gt;set_visible_horizontal(false);

  item = Gtk::manage(new Gtk::ToolButton(Gtk::Stock::GO_FORWARD));
  item-&gt;set_tooltip_text("Show on horizontal palettes only");
  group-&gt;insert(*item);
  item-&gt;set_visible_vertical(false);

  item = Gtk::manage(new Gtk::ToolButton(Gtk::Stock::FULLSCREEN));
  item-&gt;set_tooltip_text("Expanded this item");
  group-&gt;insert(*item);
  gtk_container_child_set (GTK_CONTAINER (group-&gt;gobj()), GTK_WIDGET (item-&gt;gobj()),
                           "homogeneous", FALSE,
                           "expand", TRUE,
                           NULL);

  item = Gtk::manage(new Gtk::ToolButton(Gtk::Stock::HELP));
  item-&gt;set_tooltip_text("A regular item");
  group-&gt;insert(*item);
}

ExampleWindow::ExampleWindow()
: m_VBox(false, 6),
  m_HBox(false, 6)
{
  set_title("Gtk::ToolPalette example");
  set_size_request(600, 600);
  set_border_width(6);

  add(m_VBox);

  //The Orientation ComboBox:
  m_refTreeModelOrientation = Gtk::ListStore::create(m_ColumnsOrientation);
  Gtk::TreeModel::Row row = *(m_refTreeModelOrientation-&gt;append());
  row[m_ColumnsOrientation.m_col_value] = Gtk::ORIENTATION_HORIZONTAL;
  row[m_ColumnsOrientation.m_col_name] = "Horizontal";\
  row = *(m_refTreeModelOrientation-&gt;append());
  row[m_ColumnsOrientation.m_col_value] = Gtk::ORIENTATION_VERTICAL;
  row[m_ColumnsOrientation.m_col_name] = "Vertical";
  m_ComboOrientation.set_model(m_refTreeModelOrientation);
  m_VBox.pack_start(m_ComboOrientation, Gtk::PACK_SHRINK);
  m_ComboOrientation.pack_start(m_ColumnsOrientation.m_col_name);
  m_ComboOrientation.signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_orientation_changed) );
  m_ComboOrientation.set_active(row);

  //The Style ComboBox:
  m_refTreeModelStyle = Gtk::ListStore::create(m_ColumnsStyle);
  row = *(m_refTreeModelStyle-&gt;append());
  row[m_ColumnsStyle.m_col_value] = Gtk::TOOLBAR_TEXT;
  row[m_ColumnsStyle.m_col_name] = "Text";\
  row = *(m_refTreeModelStyle-&gt;append());
  row[m_ColumnsStyle.m_col_value] = Gtk::TOOLBAR_BOTH;
  row[m_ColumnsStyle.m_col_name] = "Both";
  row = *(m_refTreeModelStyle-&gt;append());
  row[m_ColumnsStyle.m_col_value] = Gtk::TOOLBAR_BOTH_HORIZ;
  row[m_ColumnsStyle.m_col_name] = "Both: Horizontal";
  row = *(m_refTreeModelStyle-&gt;append());
  row[m_ColumnsStyle.m_col_value] = Gtk::TOOLBAR_ICONS;
  row[m_ColumnsStyle.m_col_name] = "Icons";
  row = *(m_refTreeModelStyle-&gt;append());
  row[m_ColumnsStyle.m_col_value] = -1; // A custom meaning for this demo.
  row[m_ColumnsStyle.m_col_name] = "Default";
  m_ComboStyle.set_model(m_refTreeModelStyle);
  m_VBox.pack_start(m_ComboStyle, Gtk::PACK_SHRINK);
  m_ComboStyle.pack_start(m_ColumnsStyle.m_col_name);
  m_ComboStyle.signal_changed().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_combo_style_changed) );
  m_ComboStyle.set_active(row);

  //Add and fill the ToolPalette:
  load_stock_items();
  load_toggle_items();
  load_special_items();

  m_VBox.pack_start(m_HBox, Gtk::PACK_EXPAND_WIDGET);

  m_ScrolledWindowPalette.set_policy(Gtk::POLICY_NEVER, Gtk::POLICY_AUTOMATIC);
  m_ScrolledWindowPalette.set_border_width(6);
  m_ScrolledWindowPalette.add(m_ToolPalette);
  m_HBox.pack_start(m_ScrolledWindowPalette);

  on_combo_orientation_changed();

  m_ScrolledWindowCanvas.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
  m_ScrolledWindowCanvas.set_border_width(6);
  m_ScrolledWindowCanvas.add(m_Canvas);
  m_ScrolledWindowCanvas.set_size_request(200, -1);
  m_HBox.pack_start(m_ScrolledWindowCanvas);

  m_ToolPalette.add_drag_dest(m_Canvas,
    Gtk::DEST_DEFAULT_HIGHLIGHT, Gtk::TOOL_PALETTE_DRAG_ITEMS, Gdk::ACTION_COPY);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_combo_orientation_changed()
{
  Gtk::TreeModel::iterator iter = m_ComboOrientation.get_active();
  if(!iter)
    return;

  Gtk::TreeModel::Row row = *iter;
  const Gtk::Orientation value = row[m_ColumnsOrientation.m_col_value];
 
  m_ToolPalette.set_orientation(value);

  if(value == Gtk::ORIENTATION_HORIZONTAL)
    m_ScrolledWindowPalette.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_NEVER);
  else
    m_ScrolledWindowPalette.set_policy(Gtk::POLICY_NEVER, Gtk::POLICY_AUTOMATIC);
}

void ExampleWindow::on_combo_style_changed()
{
  Gtk::TreeModel::iterator iter = m_ComboStyle.get_active();
  if(!iter)
    return;

  Gtk::TreeModel::Row row = *iter;
  const int value = row[m_ColumnsStyle.m_col_value];
 
  if(value == -1)
    m_ToolPalette.unset_style();
  else
    m_ToolPalette.set_style((Gtk::ToolbarStyle)value);
}

</programlisting>
<para>File: <filename>canvas.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "canvas.h"
#include &lt;iostream&gt;

Canvas::Canvas()
: m_drag_data_requested_for_drop(false),
  m_drop_item()
{
  set_app_paintable();
}

Canvas::~Canvas()
{
  while(!m_canvas_items.empty())
  {
    type_vec_items::iterator iter = m_canvas_items.begin();
    CanvasItem* item = *iter;
    delete item;
    m_canvas_items.erase(iter);
  }

  if(m_drop_item)
    delete m_drop_item;
}

void Canvas::item_draw(const CanvasItem *item,
  const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr,
  bool preview)
{
  if(!item || !item-&gt;pixbuf)
    return;

  const double cx = item-&gt;pixbuf-&gt;get_width();
  const double cy = item-&gt;pixbuf-&gt;get_height();

  Gdk::Cairo::set_source_pixbuf(cr,
    item-&gt;pixbuf,
    item-&gt;x - cx * 0.5, item-&gt;y - cy * 0.5);

  if(preview)
    cr-&gt;paint_with_alpha(0.6);
  else
    cr-&gt;paint();
}

bool Canvas::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  cr-&gt;set_source_rgb(1.0, 1.0, 1.0);
  const Gtk::Allocation allocation = get_allocation();
  cr-&gt;rectangle(0, 0, allocation.get_width(), allocation.get_height());
  cr-&gt;fill();

  for(type_vec_items::iterator iter = m_canvas_items.begin();
    iter != m_canvas_items.end(); ++iter )
  {
    item_draw(*iter, cr, false);
  }

  if(m_drop_item)
    item_draw (m_drop_item, cr, true);

  return true;
}


bool Canvas::on_drag_motion(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context,
  int x, int y, guint time)
{
  m_drag_data_requested_for_drop = false; //It's for drag-motion instead.

  if(m_drop_item)
  {
    // We already have a drop indicator so just update its position.

    m_drop_item-&gt;x = x;
    m_drop_item-&gt;y = y;

    queue_draw();
    context-&gt;drag_status(Gdk::ACTION_COPY, time);
  }
  else
  {
    // Request DnD data for creating a drop indicator.
    // This will cause on_drag_data_received() to be called.
    const Glib::ustring target = drag_dest_find_target(context);

    if (target.empty())
      return false;

    drag_get_data(context, target, time);
  }

  Gtk::DrawingArea::on_drag_motion(context, x, y, time);
  return true;
}


void Canvas::on_drag_data_received(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int x, int y, const Gtk::SelectionData&amp; selection_data, guint info, guint time)
{
  // Find the tool button which is the source of this DnD operation.
  Gtk::Widget* widget = drag_get_source_widget(context);

  Gtk::ToolPalette* drag_palette = dynamic_cast&lt;Gtk::ToolPalette*&gt;(widget);
  while(widget &amp;&amp; !drag_palette)
  {
    widget = widget-&gt;get_parent();
    drag_palette = dynamic_cast&lt;Gtk::ToolPalette*&gt;(widget);
  }

  Gtk::ToolItem* drag_item = 0;
  if(drag_palette)
    drag_item = drag_palette-&gt;get_drag_item(selection_data);

  // Create a drop indicator when a tool button was found:
  Gtk::ToolButton* button = dynamic_cast&lt;Gtk::ToolButton*&gt;(drag_item);
  if(!button)
    return;

  if(m_drop_item)
  {
    delete m_drop_item;
    m_drop_item = 0;
  }

  CanvasItem* item = new CanvasItem(this, button, x, y);

  if(m_drag_data_requested_for_drop)
  {
    m_canvas_items.push_back(item);

    // Signal that the item was accepted and then redraw.
    context-&gt;drag_finish(true /* success */, false /* del */, time);
  }
  else
  {
    m_drop_item = item;

    // We are getting this data due to a request in drag_motion,
    // rather than due to a request in drag_drop, so we are just
    // supposed to call gdk_drag_status (), not actually paste in
    // the data.
    context-&gt;drag_status(Gdk::ACTION_COPY, time);
  }

  queue_draw();

  Gtk::DrawingArea::on_drag_data_received(context, x, y, selection_data, info, time);
}


bool Canvas::on_drag_drop(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int /* x */, int /* y */, guint time)
{
  // Request DnD data for creating a dopped item.
  // This will cause on_drag_data_received() to be called.
  const Glib::ustring target = drag_dest_find_target(context);

  if (target.empty())
    return false;

  m_drag_data_requested_for_drop = true;
  drag_get_data(context, target, time);

  return true;
}

void Canvas::on_drag_leave(const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, guint time)
{
  //This signal is emitted to clean up the item used for drag-motion,
  //either when the cursor moves out of the widget or when we drop.

  if(!m_drop_item)
    return;

  delete m_drop_item;
  m_drop_item = 0;

  queue_draw();

  Gtk::DrawingArea::on_drag_leave(context, time);
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

</chapter>

<chapter id="chapter-adjustment">
<title>Anpassungen</title>

<para>
<application>gtkmm</application> has various widgets that can be visually adjusted using the mouse or
the keyboard, such as the <classname>Range</classname> widgets (described in
the <link linkend="chapter-range-widgets">Range Widgets</link> section). There are
also a few widgets that display some adjustable part of a larger area, such as
the <classname>Viewport</classname> widget. These widgets have
<classname>Gtk::Adjustment</classname> objects that express this common part of
their API.
</para>

<para>
So that applications can react to changes, for instance when a user moves a
scrollbar, <classname>Gtk::Adjustment</classname> has a
<literal>changed</literal> signal. You can then use the
<methodname>get_changed()</methodname> method to discover the new value.
</para>

<sect1 id="sec-creating-adjustment">
<title>Creating an Adjustment</title>

<para>
The <classname>Gtk::Adjustment</classname> constructor is as follows:
</para>

<programlisting>Gtk::Adjustment(float value,
                float lower,
                float upper,
                float step_increment = 1,
                float page_increment = 10,
                float page_size = 0);</programlisting>

<para>
The <parameter>value</parameter> argument is the initial value of the
adjustment, usually corresponding to the topmost or leftmost position of an
adjustable widget. The <parameter>lower</parameter> and
<parameter>upper</parameter> arguments specifies the possible range of values
which the adjustment can hold. The
<parameter>step_increment</parameter> argument specifies the smaller of
the two increments by which the user can change the value, while the
<parameter>page_increment</parameter> is the larger one. The
<parameter>page_size</parameter> argument usually corresponds somehow to
the visible area of a panning widget. The <parameter>upper</parameter> argument
is used to represent the bottom most or right most coordinate in a panning
widget's child.

</para>

</sect1>

<sect1 id="sec-adjustments-easy">
<title>Using Adjustments the Easy Way</title>

<para>
The adjustable widgets can be roughly divided into those which use and
require specific units for these values, and those which treat them as
arbitrary numbers.
</para>
<para>
The group which treats the values as arbitrary numbers includes the
<classname>Range</classname> widgets (<classname>Scrollbars</classname> and
<classname>Scales</classname>, the <classname>Progressbar</classname> widget,
and the <classname>SpinButton</classname> widget). These widgets  are typically
"adjusted" directly by the user with the mouse or keyboard. They will treat the
<parameter>lower</parameter> and <parameter>upper</parameter> values of an
adjustment as a range within which the user can manipulate the adjustment's
<parameter>value</parameter>. By default, they will only modify the
<parameter>value</parameter> of an adjustment.
</para>

<para>
The other group includes the <classname>Viewport</classname> widget and the
<classname>ScrolledWindow</classname> widget. All of these widgets use pixel
values for their adjustments. These are also typically adjusted indirectly
using scrollbars. While all widgets which use adjustments can either create
their own adjustments or use ones you supply, you'll generally want to let this
particular category of widgets create its own adjustments.
</para>

<para>
If you share an adjustment object between a Scrollbar and a TextView
widget, manipulating the scrollbar will automagically adjust the TextView
widget. You can set it up like this:
</para>
<programlisting>// creates its own adjustments
Gtk::TextView textview;
// uses the newly-created adjustment for the scrollbar as well
Gtk::VScrollbar vscrollbar (*(textview.get_vadjustment()));</programlisting>

</sect1>

<sect1 id="sec-adjustment-internals">
<title>Adjustment Internals</title>

<para>
OK, you say, that's nice, but what if I want to create my own handlers to
respond when the user adjusts a <classname>Range</classname> widget or a
<classname>SpinButton</classname>. To access the value of a
<classname>Gtk::Adjustment</classname>, you can use the
<methodname>get_value()</methodname> and <methodname>set_value()</methodname> methods:
</para>

<para>
As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit signals.
This is, of course, how updates happen automatically when you share an
<classname>Adjustment</classname> object between a
<classname>Scrollbar</classname> and another adjustable widget; all adjustable
widgets connect signal handlers to their adjustment's
<literal>value_changed</literal> signal, as can your program.
</para>

<para>
So, for example, if you have a <classname>Scale</classname> widget, and you
want to change the rotation of a picture whenever its value changes, you would
create a signal handler like this:
</para>
<programlisting>void cb_rotate_picture (Gtk::Widget *picture)
{
  picture-&gt;set_rotation (adj-&gt;value);
...</programlisting>
<para>
and connect it to the scale widget's adjustment like this:
</para>
<programlisting>adj.value_changed.connect(sigc::bind&lt;Widget*&gt;(sigc::mem_fun(*this,
    &amp;cb_rotate_picture), picture));</programlisting>

<para>
What if a widget reconfigures the <parameter>upper</parameter> or
<parameter>lower</parameter> fields of its <classname>Adjustment</classname>,
such as when a user adds more text to a text widget?  In this case, it emits
the <literal>changed</literal> signal.
</para>

<para>
<classname>Range</classname> widgets typically connect a handler to this
signal, which changes their appearance to reflect the change - for example, the
size of the slider in a scrollbar will grow or shrink in inverse proportion to
the difference between the <parameter>lower</parameter> and
<parameter>upper</parameter> values of its
<classname>Adjustment</classname>.
</para>

<para>
You probably won't ever need to attach a handler to this signal, unless you're
writing a new type of range widget.
</para>
<programlisting>adjustment-&gt;changed();</programlisting>

</sect1>

</chapter>

<chapter id="chapter-widgets-without-xwindows">
<title>Widgets ohne X-Windows</title>

<para>
Some Widgets do not have an associated X-Window, so they therefore do not
receive X events. This means that the signals described in the  <link linkend="sec-xeventsignals">X event signals</link> section will not be
emitted. If you want to capture events for these widgets you can use a special
container called <classname>Gtk::EventBox</classname>, which is described in
the <link linkend="sec-eventbox">EventBox</link> section.
</para>

<para>Es folgt eine Liste einiger dieser Widgets:</para>
<programlisting>Gtk::Alignment
Gtk::Arrow
Gtk::Bin
Gtk::Box
Gtk::Button
Gtk::CheckButton
Gtk::Fixed
Gtk::Image
Gtk::Item
Gtk::Label
Gtk::MenuItem
Gtk::Notebook
Gtk::Paned
Gtk::Pixmap
Gtk::RadioButton
Gtk::Range
Gtk::ScrolledWindow
Gtk::Separator
Gtk::Table
Gtk::Toolbar
Gtk::AspectFrame
Gtk::Frame
Gtk::VBox
Gtk::HBox
Gtk::VSeparator
Gtk::HSeparator</programlisting>

<para>
These widgets are mainly used for decoration or layout, so you won't often need
to capture events on them. They are intended to have no X-Window in order to improve performance.
</para>

<sect1 id="sec-eventbox">
<title>EventBox</title>

<para>
Some <application>gtkmm</application> widgets don't have associated X windows; they draw on
their parents' windows. Because of this, they cannot receive events.
Also, if they are incorrectly sized, they don't clip, so you can get
messy overwriting etc. To receive events on one of these widgets, you can it
inside an <classname>EventBox</classname> widget and then call
<methodname>Gtk::Widget::set_events()</methodname> on the EventBox before showing it.</para>

<para>Although the name
<classname>EventBox</classname> emphasises the event-handling method, the
widget can also be used for clipping (and more; see the example below).
</para>
<!--
<para>TODO: Why don't they have X Windows - explain clipping.
Also, how does this affect platform such as Windows and MacOS that don't use X.
</para>
-->

<para>
The constructor for <classname>Gtk::EventBox</classname> is:
</para>

<programlisting>Gtk::EventBox();</programlisting>

<para>
A child widget can be added to the <classname>EventBox</classname> using:
</para>

<programlisting>event_box.add(child_widget);</programlisting>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1EventBox.html">Referenz</ulink></para>

<sect2 id="eventbox-example">
<title>Beispiel</title>
<para>
The following example demonstrates both uses of an
<classname>EventBox</classname> - a label is created that is clipped to a small
box, and set up so that a mouse-click on the label causes the program to exit.
Resizing the window reveals varying amounts of the label.
</para>

<figure id="figure-eventbox">
  <title>EventBox</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/eventbox.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/eventbox?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  virtual bool on_eventbox_button_press(GdkEventButton* event);

  //Child widgets:
  Gtk::EventBox m_EventBox;
  Gtk::Label m_Label;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Label("Click here to quit, quit, quit, quit, quit")
{
  set_title ("EventBox");
  set_border_width(10);

  add(m_EventBox);

  m_EventBox.add(m_Label);

  //Clip the label short:
  m_Label.set_size_request(110, 20);

  //And bind an action to it:
  m_EventBox.set_events(Gdk::BUTTON_PRESS_MASK);
  m_EventBox.signal_button_press_event().connect(
    sigc::mem_fun(*this, &amp;ExampleWindow::on_eventbox_button_press) );

  m_EventBox.set_tooltip_text("Click me!");

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

bool ExampleWindow::on_eventbox_button_press(GdkEventButton*)
{
  hide();
  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

</sect1>

</chapter>

<chapter id="chapter-dialogs">
<title>Dialoge</title>

<para>
Dialogs are used as secondary windows, to provide specific information or to
ask questions. <classname>Gtk::Dialog</classname> windows contain a few pre-packed
widgets to ensure consistency, and a <methodname>run()</methodname> method which
blocks until the user dismisses the dialog.
</para>

<para>
There are several derived <classname>Dialog</classname> classes which you might
find useful. <classname>Gtk::MessageDialog</classname> is used for most simple
notifications. But at other times you might need to derive your own dialog
class to provide more complex functionality.
</para>

<para>
To pack widgets into a custom dialog, you should pack them into the
<classname>Gtk::VBox</classname>, available via
<methodname>get_vbox()</methodname>. To just add a <classname>Button</classname>
to the bottom of the <classname>Dialog</classname>, you could use the
<methodname>add_button()</methodname> method.
</para>

<para>
The <methodname>run()</methodname> method returns an <literal>int</literal>. This
may be a value from the <literal>Gtk::ResponseType</literal> if the user
closed the button by clicking a standard button, or it could be the custom
response value that you specified when using <methodname>add_button()</methodname>.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Dialog.html">Referenz</ulink></para>

<sect1 id="sec-dialogs-messagedialog"><title>MessageDialog</title>
<para>
<classname>MessageDialog</classname> is a convenience class, used to create
simple, standard message dialogs, with a message, an icon, and buttons for user
response. You can specify the type of message and the text in the constructor,
as well as specifying standard buttons via the
<literal>Gtk::ButtonsType</literal> enum.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1MessageDialog.html">Referenz</ulink></para>

<sect2 id="messagedialog-example">
<title>Beispiel</title>

<figure id="figure-dialogs-messagedialog">
  <title>MessageDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/dialogs_messagedialog.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/dialogs/messagedialog?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_info_clicked();
  void on_button_question_clicked();

  //Child widgets:
  Gtk::VButtonBox m_ButtonBox;
  Gtk::Button m_Button_Info, m_Button_Question;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/messagedialog.h&gt;
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
: m_Button_Info("Show Info MessageDialog"),
  m_Button_Question("Show Question MessageDialog")
{
  set_title("Gtk::MessageDialog example");

  add(m_ButtonBox);

  m_ButtonBox.pack_start(m_Button_Info);
  m_Button_Info.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_info_clicked) );

  m_ButtonBox.pack_start(m_Button_Question);
  m_Button_Question.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_question_clicked) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_info_clicked()
{
  Gtk::MessageDialog dialog(*this, "This is an INFO MessageDialog");
  dialog.set_secondary_text(
          "And this is the secondary text that explains things.");

  dialog.run();
}

void ExampleWindow::on_button_question_clicked()
{
  Gtk::MessageDialog dialog(*this, "This is a QUESTION MessageDialog",
          false /* use_markup */, Gtk::MESSAGE_QUESTION,
          Gtk::BUTTONS_OK_CANCEL);
  dialog.set_secondary_text(
          "And this is the secondary text that explains things.");

  int result = dialog.run();

  //Handle the response:
  switch(result)
  {
    case(Gtk::RESPONSE_OK):
    {
      std::cout &lt;&lt; "OK clicked." &lt;&lt; std::endl;
      break;
    }
    case(Gtk::RESPONSE_CANCEL):
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

</sect1>

<sect1 id="sec-dialogs-filechooserdialog"><title>FileChooserDialog</title>
<para>
The <classname>FileChooserDialog</classname> is suitable for use with
"Open" or "Save" menu items.
</para>
<para>
Most of the useful member methods for this class are actually in the
<classname>Gtk::FileChooser</classname> base class.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FileChooserDialog.html">Referenz</ulink></para>

<sect2 id="filechooserdialog-example">
<title>Beispiel</title>

<figure id="figure-dialogs-filechooser">
  <title>FileChooser</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/dialogs_filechooser.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/dialogs/filechooserdialog?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_file_clicked();
  void on_button_folder_clicked();

  //Child widgets:
  Gtk::VButtonBox m_ButtonBox;
  Gtk::Button m_Button_File, m_Button_Folder;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
: m_Button_File("Choose File"),
  m_Button_Folder("Choose Folder")
{
  set_title("Gtk::FileSelection example");

  add(m_ButtonBox);

  m_ButtonBox.pack_start(m_Button_File);
  m_Button_File.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_file_clicked) );

  m_ButtonBox.pack_start(m_Button_Folder);
  m_Button_Folder.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_folder_clicked) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_folder_clicked()
{
  Gtk::FileChooserDialog dialog("Please choose a folder",
          Gtk::FILE_CHOOSER_ACTION_SELECT_FOLDER);
  dialog.set_transient_for(*this);

  //Add response buttons the the dialog:
  dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
  dialog.add_button("Select", Gtk::RESPONSE_OK);

  int result = dialog.run();

  //Handle the response:
  switch(result)
  {
    case(Gtk::RESPONSE_OK):
    {
      std::cout &lt;&lt; "Select clicked." &lt;&lt; std::endl;
      std::cout &lt;&lt; "Folder selected: " &lt;&lt; dialog.get_filename()
          &lt;&lt; std::endl;
      break;
    }
    case(Gtk::RESPONSE_CANCEL):
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
}

void ExampleWindow::on_button_file_clicked()
{
  Gtk::FileChooserDialog dialog("Please choose a file",
          Gtk::FILE_CHOOSER_ACTION_OPEN);
  dialog.set_transient_for(*this);

  //Add response buttons the the dialog:
  dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
  dialog.add_button(Gtk::Stock::OPEN, Gtk::RESPONSE_OK);

  //Add filters, so that only certain file types can be selected:

  Glib::RefPtr&lt;Gtk::FileFilter&gt; filter_text = Gtk::FileFilter::create();
  filter_text-&gt;set_name("Text files");
  filter_text-&gt;add_mime_type("text/plain");
  dialog.add_filter(filter_text);

  Glib::RefPtr&lt;Gtk::FileFilter&gt; filter_cpp = Gtk::FileFilter::create();
  filter_cpp-&gt;set_name("C/C++ files");
  filter_cpp-&gt;add_mime_type("text/x-c");
  filter_cpp-&gt;add_mime_type("text/x-c++");
  filter_cpp-&gt;add_mime_type("text/x-c-header");
  dialog.add_filter(filter_cpp);

  Glib::RefPtr&lt;Gtk::FileFilter&gt; filter_any = Gtk::FileFilter::create();
  filter_any-&gt;set_name("Any files");
  filter_any-&gt;add_pattern("*");
  dialog.add_filter(filter_any);

  //Show the dialog and wait for a user response:
  int result = dialog.run();

  //Handle the response:
  switch(result)
  {
    case(Gtk::RESPONSE_OK):
    {
      std::cout &lt;&lt; "Open clicked." &lt;&lt; std::endl;

      //Notice that this is a std::string, not a Glib::ustring.
      std::string filename = dialog.get_filename();
      std::cout &lt;&lt; "File selected: " &lt;&lt;  filename &lt;&lt; std::endl;
      break;
    }
    case(Gtk::RESPONSE_CANCEL):
    {
      std::cout &lt;&lt; "Cancel clicked." &lt;&lt; std::endl;
      break;
    }
    default:
    {
      std::cout &lt;&lt; "Unexpected button clicked." &lt;&lt; std::endl;
      break;
    }
  }
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>
</sect1>

<sect1 id="sec-color-selection-dialog"><title>ColorSelectionDialog</title>
<para>
The <classname>ColorSelectionDialog</classname> allows the user to choose a
color.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ColorSelectionDialog.html">Referenz</ulink></para>

<sect2 id="colorselectiondialog-example">
<title>Beispiel</title>

<figure id="figure-dialogs-colorselectiondialog">
  <title>ColorSelectionDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/dialogs_colorselectiondialog.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/dialogs/colorselectiondialog?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_color_set();

  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::ColorButton m_Button;
  Gtk::DrawingArea m_DrawingArea; //To show the color.

  Gdk::RGBA m_Color;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
{
  set_title("Gtk::ColorButton example");
  set_default_size(200, 200);

  add(m_VBox);

  m_VBox.pack_start(m_Button, Gtk::PACK_SHRINK);
  m_Button.signal_color_set().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_color_set) );

  //Set start color:
  m_Color.set_red(0);
  m_Color.set_blue(1);
  m_Color.set_green(0);
  m_Button.set_rgba(m_Color);

  m_DrawingArea.override_background_color(m_Color);

  m_VBox.pack_start(m_DrawingArea);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_color_set()
{
  //Store the chosen color, and show it:
  m_Color = m_Button.get_rgba();
  m_DrawingArea.override_background_color(m_Color);
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

</sect1>

<sect1 id="sec-font-selection-dialog"><title>FontSelectionDialog</title>
<para>
The <classname>FontSelectionDialog</classname> allows the user to choose a
font.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1FontSelectionDialog.html">Referenz</ulink></para>

<sect2 id="fontselectiondialog-example">
<title>Beispiel</title>

<figure id="figure-dialogs-fontselectiondialog">
  <title>FontSelectionDialog</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/dialogs_fontselectiondialog.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/dialogs/fontselectiondialog?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_font_set();

  //Child widgets:
  Gtk::FontButton m_Button;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;iostream&gt;


ExampleWindow::ExampleWindow()
: m_Button("sans")
{
  set_title("Gtk::FontSelectionDialog example");

  add(m_Button);
  m_Button.signal_font_set().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_font_set) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_font_set()
{
  Glib::ustring font_name = m_Button.get_font_name();
  std::cout &lt;&lt; "Font chosen: " &lt;&lt; font_name &lt;&lt; std::endl;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

</sect1>


</chapter>

<chapter id="chapter-drawingarea">
  <title>Das Zeichenbereich-Widget</title>
  <para>
    The <classname>DrawingArea</classname> widget is a blank window that gives
    you the freedom to create any graphic you desire. Along with that freedom
    comes the responsibility to handle expose events on the widget. When a
    widget is first shown, or when it is covered and then uncovered again it
    needs to redraw itself. Most widgets have code to do this, but the
    DrawingArea  does not, allowing you to write your own expose event signal
    handler to determine how the contents of the widget will be drawn. This is
    most often done by overriding the virtual
    <methodname>on_expose_event()</methodname> member function.
  </para>

  <para>
      GTK+ uses the <ulink url="http://cairographics.org">Cairo</ulink> drawing API.
      With gtkmm, you may use the <ulink url="http://www.cairographics.org/cairomm/">cairomm</ulink> C++ API for cairo.
  </para>

  <para>
      You can draw very sophisticated shapes using Cairo, but the methods to do
      so are quite basic. Cairo provides methods for drawing straight lines,
      curved lines, and arcs (including circles). These basic shapes can be
      combined to create more complex shapes and paths which can be filled with
      solid colors, gradients, patterns, and other things. In addition, Cairo
      can perform complex transformations, do compositing of images, and render
      antialiased text.
  </para>
  <note>
      <title>Cairo und Pango</title>
      <para>Although Cairo can render text, it's not meant to be a replacement for
      Pango. Pango is a better choice if you need to perform more advanced
      text rendering such as wrapping or ellipsizing text. Drawing text with
      Cairo should only be done if the text is part of a graphic.</para>
  </note>
  <para>
      In this section of the tutorial, we'll cover the basic Cairo drawing
      model, describe each of the basic drawing elements in some detail (with
      examples), and then present a simple application that uses Cairo to draw
      a custom clock widget.
  </para>
  <sect1 id="sec-cairo-drawing-model">
    <title>Das Cairo-Zeichenmodell</title>
    <para>
        The basic concept of drawing in Cairo involves defining 'invisible'
        paths and then stroking or filling them to make them visible.
    </para>
    <para>
        To do any drawing in <application>gtkmm</application> with Cairo, you must first create a
        <classname>Cairo::Context</classname> object. This class holds all of the graphics state parameters that
        describe how drawing is to be done. This includes information such as
        line width, color, the surface to draw to, and many other things. This
        allows the actual drawing functions to take fewer arguments to simplify
        the interface. In <application>gtkmm</application>, a <classname>Cairo::Context</classname> is
        created by calling the
        <methodname>Gdk::Window::create_cairo_context()</methodname> function.
        Since Cairo context are reference-counted objects, this function
        returns a <classname>Cairo::RefPtr&lt;Cairo::Context&gt;</classname>
        object.
    </para>
    <para>
        The following example shows  how to set up a Cairo context with a
        foreground color of red and a width of 2. Any drawing functions that
        use this context will use these settings.
    </para>
    <programlisting>Gtk::DrawingArea myArea;
Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();
myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);
myContext-&gt;set_line_width(2.0);</programlisting>
    <para>
        Each <classname>Cairo::Context</classname> is associated with a
        particular <classname>Gdk::Window</classname>, so the first line of the
        above example creates a <classname>Gtk::DrawingArea</classname> widget
        and the second line uses its associated
        <classname>Gdk::Window</classname> to create a
        <classname>Cairo::Context</classname> object. The final two lines
        change the graphics state of the context.
    </para>
    <para>
        There are a number of graphics state variables that can be set for a
        Cairo context. The most common context attributes are color (using
        <methodname>set_source_rgb()</methodname> or
        <methodname>set_source_rgba()</methodname> for translucent colors), line
        width (using <methodname>set_line_width()</methodname>), line dash pattern
        (using <methodname>set_dash()</methodname>), line cap style (using
        <methodname>set_line_cap()</methodname>), and line join style (using
        <methodname>set_line_join()</methodname>), and font styles (using
        <methodname>set_font_size()</methodname>,
        <methodname>set_font_face()</methodname> and others).
        There are many other settings as well, such as transformation matrices,
        fill rules, whether to perform antialiasing, and others. For further
        information, see the <ulink url="http://www.cairographics.org/cairomm/">cairomm</ulink> API documentation.
    </para>
    <para>
        The current state of a <classname>Cairo::Context</classname> can be
        saved to an internal stack of saved states and later be restored to the
        state it was in when you saved it. To do this, use the
        <methodname>save()</methodname>
        method and the <methodname>restore()</methodname> method. This can be
        useful if you need to temporarily change the line width and color (or
        any other graphics setting) in order to draw something and then return
        to the previous settings. In this situation, you could call
        <methodname>Cairo::Context::save()</methodname>, change the graphics
        settings, draw the lines, and then call
        <methodname>Cairo::Context::restore()</methodname> to restore the original
        graphics state. Multiple calls to <methodname>save()</methodname> and
        <methodname>restore()</methodname> can be nested; each call to
        <methodname>restore()</methodname> restores the state from the
        matching paired <methodname>save()</methodname>.
        <tip>
            <para>It is good practice to put all modifications to the graphics state
            between <methodname>save()</methodname>/<methodname>restore()</methodname>
            function calls. For example, if you have a function that takes a
            <classname>Cairo::Context</classname> reference as an argument, you
            might implement it as follows:
          </para>
          <programlisting>void doSomething(Cairo::RefPtr&lt;Cairo::Context&gt; context, int x)
{
    context-&gt;save();
    // change graphics state
    // peform drawing operations
    context-&gt;restore();
}</programlisting>
        </tip>
    </para>
  </sect1>
  <sect1 id="sec-cairo-drawing-lines">
    <title>Zeichnen gerader Linien</title>
    <para>
        Now that we understand the basics of the Cairo graphics library, we're
        almost ready to start drawing. We'll start with the simplest of
        drawing elements: the straight line. But first you need to know a
        little bit about Cairo's coordinate system. The origin of the Cairo
        coordinate system is located in the upper-left corner of the window
        with positive x values to the right and positive y values going down.
        <tip>
            <para>Since the Cairo graphics library was written with support for
            multiple output targets (the X window system, PNG images, OpenGL,
            etc), there is a distinction between user-space and device-space
            coordinates. The mapping between these two coordinate systems
            defaults to one-to-one so that integer values map roughly to pixels
            on the screen, but this setting can be adjusted if desired.
            Sometimes it may be useful to scale the coordinates so that the
            full width and height of a window both range from 0 to 1 (the 'unit
            square') or some other mapping that works for your application.
            this can be done with the
            <methodname>Cairo::Context::scale()</methodname> function.</para>
        </tip>
    </para>

    <sect2 id="cairo-example-lines"><title>Beispiel</title>
    <para>
        In this example, we'll construct a small but fully functional <application>gtkmm</application>
        program and draw some lines into the window. The lines are drawn by
        creating a path and then stroking it. A path is created using the
        functions <methodname>Cairo::Context::move_to()</methodname> and
        <methodname>Cairo::Context::line_to()</methodname>. The function
        <methodname>move_to()</methodname> is similar to the act of lifting your
        pen off of the paper and placing it somewhere else -- no line is drawn
        between the point you were at and the point you moved to. To draw a
        line between two points, use the <methodname>line_to()</methodname>
        function.
    </para>
    <para>
        After you've finished creating your path, you still haven't
        drawn anything visible yet. To make the path visible, you must use the
        function <methodname>stroke()</methodname> which will stroke the current
        path with the line width and style specified in your
        <classname>Cairo::Context</classname> object. After stroking, the
        current path will be cleared so that you can start on your next path.
    </para>
        <tip>
            <para>Many Cairo drawing functions have a <methodname>_preserve()</methodname>
            variant. Normally drawing functions such as
            <methodname>clip()</methodname>, <methodname>fill()</methodname>, or
            <methodname>stroke()</methodname> will clear the current path. If you
            use the <methodname>_preserve()</methodname> variant, the current path
            will be retained so that you can use the same path with the next
            drawing function.</para>
        </tip>

    <figure id="figure-drawingarea-lines">
      <title>Zeichenbereich - Linien</title>
      <screenshot>
        <graphic format="PNG" fileref="figures/drawingarea_lines.png"/>
      </screenshot>
    </figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/drawingarea/simple?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>myarea.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  //Override default signal handler:
  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</programlisting>
<para>File: <filename>myarea.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;cairomm/context.h&gt;

MyArea::MyArea()
{
}

MyArea::~MyArea()
{
}

bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  Gtk::Allocation allocation = get_allocation();
  const int width = allocation.get_width();
  const int height = allocation.get_height();

  // coordinates for the center of the window
  int xc, yc;
  xc = width / 2;
  yc = height / 2;

  cr-&gt;set_line_width(10.0);

  // draw red lines out from the center of the window
  cr-&gt;set_source_rgb(0.8, 0.0, 0.0);
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(xc, yc);
  cr-&gt;line_to(0, height);
  cr-&gt;move_to(xc, yc);
  cr-&gt;line_to(width, yc);
  cr-&gt;stroke();

  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;gtkmm/window.h&gt;

int main(int argc, char** argv)
{
   Gtk::Main kit(argc, argv);

   Gtk::Window win;
   win.set_title("DrawingArea");

   MyArea area;
   win.add(area);
   area.show();

   Gtk::Main::run(win);

   return 0;
}
</programlisting>
<!-- end inserted example code -->

    <para>
        This program contains a single class, <classname>MyArea</classname>,
        which is a subclass of <classname>Gtk::DrawingArea</classname> and
        contains an <methodname>on_expose_event()</methodname> member function.
        This method is called whenever the image in the drawing area needs to
        be redrawn. This function is passed a pointer to a
        <classname>GdkEventExpose</classname> structure which defines the area
        that needs to be redrawn. We use these values to create a rectangle
        path in Cairo (using the <methodname>rectangle()</methodname> function) and
        then <methodname>clip()</methodname> to this path. The
        <methodname>clip()</methodname> function sets a clip region. The current
        clip region affects all drawing operations by effectively masking out
        any changes to the surface that are outside the current clip region.
        This allows us to limit our redrawing to only the area that needs to be
        redrawn.
        The actual drawing code sets the color we want to use for drawing by
        using <methodname>set_source_rgb()</methodname> which takes arguments
        defining the Red, Green, and Blue components of the desired color
        (valid values are between 0 and 1). After setting the color, we
        created a new path using the functions <methodname>move_to()</methodname>
        and <methodname>line_to()</methodname>, and then stroked this path with
        <methodname>stroke()</methodname>.
    </para>
    <tip>
        <title>Zeichnen mit relativen Koordinaten</title>
        <para>In the example above we drew everything using absolute coordinates. You can also draw using
        relative coordinates. For a straight line, this is done with the
        function <methodname>Cairo::Context::rel_line_to()</methodname>.</para>
    </tip>
    </sect2>
    <sect2 id="cairo-line-styles">
        <title>Linienstile</title>
        <para>
            In addition to drawing basic straight lines, there are a number of
            things that you can customize about a line. You've already seen
            examples of setting a line's color and width, but there are others
            as well.
        </para>
        <para>
            If you've drawn a series of lines that form a path, you may
            want them to join together in a certain way. Cairo offers
            three different ways to join lines together: Miter, Bevel, and
            Round. These are show below:
        </para>
        <figure id="figure-cairo-joins">
            <title>Verschiedene Verbindungstypen in Cairo</title>
            <screenshot>
                <graphic format="PNG" fileref="figures/cairo_joins.png"/>
            </screenshot>
        </figure>
        <para>
            The line join style is set using the function
            <methodname>Cairo::Context::set_line_join()</methodname>.
        </para>
        <para>
            Line ends can have different styles as well. The default style
            is for the line to start and stop exactly at the destination
            points of the line. This is called a Butt cap. The other
            options are Round (uses a round ending, with the center of the
            circle at the end point) or Square (uses a squared ending, with
            the center of the square at the end point). This setting is set
            using the function
            <methodname>Cairo::Context::set_line_cap()</methodname>.
        </para>
        <para>
            There are other things you can customize as well, including
            creating dashed lines and other things. For more information , see
            the Cairo API documentation.
        </para>
    </sect2>
</sect1>
    <sect1 id="sec-cairo-curved-lines">
        <title>Zeichnen von gebogenen Linien</title>
        <para>
            In addition to drawing straight lines Cairo allows you to easily
            draw curved lines (technically a cubic Bézier spline) using the
            <methodname>Cairo::Context::curve_to()</methodname> and
            <methodname>Cairo::Context::rel_curve_to()</methodname> functions.
            These functions take coordinates for a destination point as well as
            coordinates for two 'control' points. This is best explained using
            an example, so let's dive in.
        </para>
        <sect2 id="cairo-example-curves">
            <title>Beispiel</title>
            <para>
                This simple application draws a curve with Cairo and displays
                the control points for each end of the curve.
            </para>
        <figure id="figure-drawingarea-curve">
            <title>Zeichenbereich - Linien</title>
            <screenshot>
                <graphic format="PNG" fileref="figures/drawingarea_curve.png"/>
            </screenshot>
        </figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/drawingarea/curve?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>myarea.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  //Override default signal handler:
  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</programlisting>
<para>File: <filename>myarea.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;cairomm/context.h&gt;

MyArea::MyArea()
{
}

MyArea::~MyArea()
{
}

bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  Gtk::Allocation allocation = get_allocation();
  const int width = allocation.get_width();
  const int height = allocation.get_height();

  double x0=0.1, y0=0.5, // start point
         x1=0.4, y1=0.9,  // control point #1
         x2=0.6, y2=0.1,  // control point #2
         x3=0.9, y3=0.5;  // end point

  // clip to the area indicated by the expose event so that we only redraw
  // the portion of the window that needs to be redrawn
  cr-&gt;rectangle(0, 0, width, height);
  cr-&gt;clip();

  // scale to unit square (0 to 1 with and height)
  cr-&gt;scale(width, height);

  cr-&gt;set_line_width(0.05);
  // draw curve
  cr-&gt;move_to(x0, y0);
  cr-&gt;curve_to(x1, y1, x2, y2, x3, y3);
  cr-&gt;stroke();
  // show control points
  cr-&gt;set_source_rgba(1, 0.2, 0.2, 0.6);
  cr-&gt;move_to(x0, y0);
  cr-&gt;line_to (x1, y1);
  cr-&gt;move_to(x2, y2);
  cr-&gt;line_to (x3, y3);
  cr-&gt;stroke();

  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;gtkmm/window.h&gt;

int main(int argc, char** argv)
{
   Gtk::Main kit(argc, argv);

   Gtk::Window win;
   win.set_title("DrawingArea");

   MyArea area;
   win.add(area);
   area.show();

   Gtk::Main::run(win);

   return 0;
}
</programlisting>
<!-- end inserted example code -->
        <para>
            The only difference between this example and the straight line
            example is in the <methodname>on_expose_event()</methodname> function,
            but there are a few new concepts and functions introduced here, so
            let's examine them briefly.
        </para>
        <para>
            Note that we clip to the area that needs re-exposing just as we did
            in the last example. After clipping, however, we make a call to
            <methodname>Cairo::Context::scale()</methodname>, passing in the width
            and height of the drawing area. This scales the user-space
            coordinate system such that the the width and height of the widget
            are both equal to 1.0 'units'. There's no particular reason to
            scale the coordinate system in this case, but sometimes it can make
            drawing operations easier.
        </para>
        <para>
            The call to <methodname>Cairo::Context::curve_to()</methodname> should
            be fairly self-explanatory. The first pair of coordinates define
            the control point for the beginning of the curve. The second set
            of coordinates define the control point for the end of the curve,
            and the last set of coordinates define the destination point. To
            make the concept of control points a bit easier to visualize, a
            line has been draw from each control point to the end-point on the
            curve that it is associated with. Note that these control point
            lines are both translucent. This is achieved with a variant of
            <methodname>set_source_rgb()</methodname> called
            <methodname>set_source_rgba()</methodname>. This function takes a
            fourth argument specifying the alpha value of the color (valid
            values are between 0 and 1).
        </para>
        </sect2>
  </sect1>
  <sect1 id="sec-cairo-drawing-arcs">
      <title>Zeichnen von Kreisbögen und Kreisen </title>
      <para>
          With Cairo, the same function is used to draw arcs, circles, or
          ellipses: <methodname>Cairo::Context::arc()</methodname>. This function
          takes five arguments. The first two are the coordinates of the
          center point of the arc, the third argument is the radius of the arc,
          and the final two arguments define the start and end angle of the
          arc. All angles are defined in radians, so drawing a circle is the
          same as drawing an arc from 0 to 2 * M_PI radians.
          An angle of 0 is in the direction of the positive X axis (in user-space). An
          angle of M_PI/2 radians (90 degrees) is in the direction of the positive Y axis
          (in user-space). Angles increase in the direction from the positive X axis
          toward the positive Y axis. So with the default transformation matrix, angles
          increase in a clockwise direction.
      </para>
      <para>
          To draw an ellipse, you can scale the current transformation matrix
          by different amounts in the X and Y directions. For example, to draw
          an ellipse in the box given by <varname>x</varname>,
          <varname>y</varname>, <varname>width</varname>,
          <varname>height</varname>:

          <programlisting>context-&gt;save();
context-&gt;translate(x, y);
context-&gt;scale(width / 2.0, height / 2.0);
context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);
context-&gt;restore();</programlisting>
          Note that this contradicts the <ulink url="http://www.cairographics.org/manual/cairo-Paths.html#cairo-arc">advice
              given in the official Cairo documentation</ulink>, but it seems
          to work.
      </para>
      <sect2 id="cairo-example-arcs">
          <title>Beispiel</title>
          <para>
              Here's an example of a simple program that draws an arc, a circle
              and an ellipse into a drawing area.
          </para>
          <figure id="figure-drawingarea-arc">
              <title>Zeichenbereich - Bögen</title>
              <screenshot>
                  <graphic format="PNG" fileref="figures/drawingarea_arcs.png"/>
              </screenshot>
          </figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/drawingarea/arcs?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>myarea.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_MYAREA_H
#define GTKMM_EXAMPLE_MYAREA_H

#include &lt;gtkmm/drawingarea.h&gt;

class MyArea : public Gtk::DrawingArea
{
public:
  MyArea();
  virtual ~MyArea();

protected:
  //Override default signal handler:
  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);
};

#endif // GTKMM_EXAMPLE_MYAREA_H
</programlisting>
<para>File: <filename>myarea.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;cairomm/context.h&gt;
#include &lt;cmath&gt;

MyArea::MyArea()
{
}

MyArea::~MyArea()
{
}

bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  // This is where we draw on the window
  Gtk::Allocation allocation = get_allocation();
  const int width = allocation.get_width();
  const int height = allocation.get_height();
  const int lesser = MIN(width, height);

  // coordinates for the center of the window
  int xc, yc;
  xc = width / 2;
  yc = height / 2;

  cr-&gt;set_line_width(lesser * 0.02);  // outline thickness changes
                                      // with window size

  // first draw a simple unclosed arc
  cr-&gt;save();
  cr-&gt;arc(width / 3.0, height / 4.0, lesser / 4.0, -(M_PI / 5.0), M_PI);
  cr-&gt;close_path();   // line back to start point
  cr-&gt;set_source_rgb(0.0, 0.8, 0.0);
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();   // outline it

  // now draw a circle
  cr-&gt;save();
  cr-&gt;arc(xc, yc, lesser / 4.0, 0.0, 2.0 * M_PI); // full circle
  cr-&gt;set_source_rgba(0.0, 0.0, 0.8, 0.6);    // partially translucent
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();

  // and finally an ellipse
  double ex, ey, ew, eh;
  // center of ellipse
  ex = xc;
  ey = 3.0 * height / 4.0;
  // ellipse dimensions
  ew = 3.0 * width / 4.0;
  eh = height / 3.0;

  cr-&gt;save();

  cr-&gt;translate(ex, ey);  // make (ex, ey) == (0, 0)
  cr-&gt;scale(ew / 2.0, eh / 2.0);  // for width: ew / 2.0 == 1.0
                                  // for height: eh / 2.0 == 1.0

  cr-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);  // 'circle' centered at (0, 0)
                                          // with 'radius' of 1.0

  cr-&gt;set_source_rgba(0.8, 0.0, 0.0, 0.7);
  cr-&gt;fill_preserve();
  cr-&gt;restore();  // back to opaque black
  cr-&gt;stroke();

  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "myarea.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;gtkmm/window.h&gt;

int main(int argc, char** argv)
{
   Gtk::Main kit(argc, argv);

   Gtk::Window win;
   win.set_title("DrawingArea");

   MyArea area;
   win.add(area);
   area.show();

   Gtk::Main::run(win);

   return 0;
}
</programlisting>
<!-- end inserted example code -->

          <para>
              There are a couple of things to note about this example code.
              Again, the only real difference between this example and the
              previous ones is the <methodname>on_expose_event()</methodname>
              function, so we'll limit our focus to that function. In
              addition, the first part of the function is nearly identical to
              the previous examples, so we'll skip that portion.
          </para>
          <para>
              Note that in this case, we've expressed nearly everything in
              terms of the height and width of the window, including the width
              of the lines. Because of this, when you resize the window,
              everything scales with the window. Also note that there are
              three drawing sections in the function and each is wrapped with a
              <methodname>save()</methodname>/<methodname>restore()</methodname> pair
              so that we're back at a known state after each drawing.
          </para>
          <para>
              The section for drawing an arc introduces one new function,
              <methodname>close_path()</methodname>. This function will in effect
              draw a straight line from the current point back to the first
              point in the path. There is a significant difference between
              calling <methodname>close_path()</methodname> and manually drawing a
              line back to the starting point, however. If you use
              <methodname>close_path()</methodname>, the lines will be nicely
              joined together. If you use <methodname>line_to()</methodname>
              instead, the lines will end at the same point, but Cairo won't do
              any special joining.
          </para>
          <note>
              <title>Drawing counter-clockwise</title>
              <para>
                  The function
                  <methodname>Cairo::Context::arc_negative()</methodname> is
                  exactly the same as
                  <methodname>Cairo::Context::arc()</methodname> but the angles go
                  the opposite direction.
              </para>
          </note>

      </sect2>
  </sect1>
  <sect1 id="sec-drawing-text">
      <title>Zeichnen von Text</title>
      <sect2 id="drawing-text-pango">
          <title>Zeichnen von Text mit Pango</title>
          <para>
              Text is drawn via Pango Layouts. The easiest way to create a
              <classname>Pango::Layout</classname> is to use
              <methodname>create_pango_layout</methodname>. Once created, the layout
              can be manipulated in various ways, including changing the text,
              font, etc. Finally, the layout can be rendered using the
              <methodname>draw_layout</methodname> method of
              <classname>Gdk::Drawable</classname>, which takes a
              <classname>Gdk::GC</classname> object, an x-position, a
              y-position and the layout itself.
              
          </para>
      </sect2>

      <!--
      <sect2 id="drawing-text-cairo">
          <title>Drawing Text with Cairo</title>
          <warning>TODO: Add Cairo content.</warning>
      </sect2>
      -->
  </sect1>
  <sect1 id="sec-draw-images">
      <title>Zeichnen von Grafiken</title>
      <sect2 id="drawing-images-gdk">
          <title>Zeichnen von Grafiken mit Gdk</title>
          <para>
              There are a couple of drawing methods for putting image data into
              a drawing area. <methodname>draw_pixmap()</methodname> can copy the
              contents of a <classname>Gdk::Drawable</classname> (the window of
              a drawing area is one) into the drawing area. There is also
              <methodname>draw_bitmap()</methodname> for drawing a two-color image
              into the drawing area, and <methodname>draw_image()</methodname> for
              drawing an image with more than two colors.
          </para>
          <para>
              For all of these methods, the first argument is the
              <classname>Gdk::GC</classname>. The second argument is the object
              of the appropriate type to copy in:
              <classname>Gdk::Drawable</classname>,
              <classname>Gdk::Bitmap</classname>,
              <classname>Gdk::Image</classname>. The next two arguments are the
              x and y points in the image to begin copying from. Then come the
              x and y points in the drawing area to copy to. The final two
              arguments are the width and height of the area to copy.
          </para>
          <para>
              There is also a method for drawing from a
              <classname>Gdk::Pixbuf</classname>. A
              <classname>Gdk::Pixbuf</classname> buffer is a useful wrapper
              around a collection of pixels, which can be read from files, and
              manipulated in various ways.
          </para>
          <para>
              Probably the most common way of creating
              <classname>Gdk::Pixbuf</classname>s is to use
              <methodname>Gdk::Pixbuf::create_from_file()</methodname>, which can
              read an image file, such as a png file into a pixbuf ready for
              rendering.
          </para>
          <para>
              The <classname>Gdk::Pixbuf</classname> can be rendered with
              <methodname>render_to_drawable</methodname>, which takes quite a few
              parameters. The <methodname>render_to_drawable</methodname> is a
              member of <classname>Gdk::Pixbuf</classname> rather than
              <classname>Gdk::Drawable</classname>, which is unlike the
              <methodname>draw_*</methodname> functions described earlier. As such,
              its first parameter is the drawable to render to. The second
              parameter is still the <classname>Gdk::GC</classname>. The next
              two parameters are the point in the pixbuf to start drawing from.
              This is followed by the point in the drawable to draw it at, and
              by the width and height to actually draw (which may not be the
              whole image, especially if you're only responding to an expose
              event for part of the window). Finally, there are the dithering
              parameters. If you use Gdk::RGB_DITHER_NONE as the dither type,
              then the dither offset parameters can both be 0.
          </para>
          <para>
              Here is a small bit of code to tie it all together: (Note that
              usually you wouldn't load the image every time in the expose
              event handler! It's just shown here to keep it all together)
          </para>
          <programlisting>bool myarea::on_expose_event(GdkEventExpose* ev)
{
Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file("myimage.png");
image-&gt;render_to_drawable(get_window(), get_style()-&gt;get_black_gc(),
0, 0, 100, 80, image-&gt;get_width(), image-&gt;get_height(), // draw the whole image (from 0,0 to the full width,height) at 100,80 in the window
Gdk::RGB_DITHER_NONE, 0, 0);
return true;
}</programlisting>
      </sect2>
      <!--
      <sect2 id="drawing-images-cairo">
          <title>Drawing images with Cairo</title>
          <warning>TODO: Add Cairo content.</warning>
      </sect2>
      -->
  </sect1>
  <!--
  <sect1 id="sec-drawing-fill">
      <title>Gradients and other fill techniques</title>
      <warning>TODO: Add content.</warning>
  </sect1>
  <sect1 id="sec-drawing-transformations">
      <title>Transformations with Cairo</title>
      <warning>TODO: Add content.</warning>
  </sect1>
  -->
  <sect1 id="sec-drawing-clock-example">
      <title>Example Application: Creating a Clock with Cairo</title>
      <para>
          Now that we've covered the basics of drawing with Cairo, let's try to
          put it all together and create a simple application that actually
          does something. The following example uses Cairo to create a custom
          <classname>Clock</classname> widget. The clock has a second hand, a
          minute hand, and an hour hand, and updates itself every second.
      </para>
      <screenshot>
          <graphic format="PNG" fileref="figures/cairo_clock.png"/>
      </screenshot>
<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/drawingarea/clock?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>clock.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_CLOCK_H
#define GTKMM_EXAMPLE_CLOCK_H

#include &lt;gtkmm/drawingarea.h&gt;

class Clock : public Gtk::DrawingArea
{
public:
  Clock();
  virtual ~Clock();

protected:
  //Override default signal handler:
  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);

  bool on_timeout();

  double m_radius;
  double m_line_width;

};

#endif // GTKMM_EXAMPLE_CLOCK_H
</programlisting>
<para>File: <filename>clock.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;cairomm/context.h&gt;
#include "clock.h"

Clock::Clock()
: m_radius(0.42), m_line_width(0.05)
{
  Glib::signal_timeout().connect( sigc::mem_fun(*this, &amp;Clock::on_timeout), 1000 );

  #ifndef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
  //Connect the signal handler if it isn't already a virtual method override:
  signal_draw().connect(sigc::mem_fun(*this, &amp;Clock::on_draw), false);
  #endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
}

Clock::~Clock()
{
}

bool Clock::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  Gtk::Allocation allocation = get_allocation();
  const int width = allocation.get_width();
  const int height = allocation.get_height();

  // scale to unit square and translate (0, 0) to be (0.5, 0.5), i.e.
  // the center of the window
  cr-&gt;scale(width, height);
  cr-&gt;translate(0.5, 0.5);
  cr-&gt;set_line_width(m_line_width);

  cr-&gt;save();
  cr-&gt;set_source_rgba(0.337, 0.612, 0.117, 0.9);   // green
  cr-&gt;paint();
  cr-&gt;restore();
  cr-&gt;arc(0, 0, m_radius, 0, 2 * M_PI);
  cr-&gt;save();
  cr-&gt;set_source_rgba(1.0, 1.0, 1.0, 0.8);
  cr-&gt;fill_preserve();
  cr-&gt;restore();
  cr-&gt;stroke_preserve();
  cr-&gt;clip();

  //clock ticks
  for (int i = 0; i &lt; 12; i++)
  {
    double inset = 0.05;

    cr-&gt;save();
    cr-&gt;set_line_cap(Cairo::LINE_CAP_ROUND);

    if(i % 3 != 0)
    {
      inset *= 0.8;
      cr-&gt;set_line_width(0.03);
    }

    cr-&gt;move_to(
      (m_radius - inset) * cos (i * M_PI / 6),
      (m_radius - inset) * sin (i * M_PI / 6));
    cr-&gt;line_to (
      m_radius * cos (i * M_PI / 6),
      m_radius * sin (i * M_PI / 6));
    cr-&gt;stroke();
    cr-&gt;restore(); /* stack-pen-size */
  }

  // store the current time
  time_t rawtime;
  time(&amp;rawtime);
  struct tm * timeinfo = localtime (&amp;rawtime);

  // compute the angles of the indicators of our clock
  double minutes = timeinfo-&gt;tm_min * M_PI / 30;
  double hours = timeinfo-&gt;tm_hour * M_PI / 6;
  double seconds= timeinfo-&gt;tm_sec * M_PI / 30;

  cr-&gt;save();
  cr-&gt;set_line_cap(Cairo::LINE_CAP_ROUND);

  // draw the seconds hand
  cr-&gt;save();
  cr-&gt;set_line_width(m_line_width / 3);
  cr-&gt;set_source_rgba(0.7, 0.7, 0.7, 0.8); // gray
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(seconds) * (m_radius * 0.9),
    -cos(seconds) * (m_radius * 0.9));
  cr-&gt;stroke();
  cr-&gt;restore();

  // draw the minutes hand
  cr-&gt;set_source_rgba(0.117, 0.337, 0.612, 0.9);   // blue
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(minutes + seconds / 60) * (m_radius * 0.8),
    -cos(minutes + seconds / 60) * (m_radius * 0.8));
  cr-&gt;stroke();

  // draw the hours hand
  cr-&gt;set_source_rgba(0.337, 0.612, 0.117, 0.9);   // green
  cr-&gt;move_to(0, 0);
  cr-&gt;line_to(sin(hours + minutes / 12.0) * (m_radius * 0.5),
    -cos(hours + minutes / 12.0) * (m_radius * 0.5));
  cr-&gt;stroke();
  cr-&gt;restore();

  // draw a little dot in the middle
  cr-&gt;arc(0, 0, m_line_width / 3.0, 0, 2 * M_PI);
  cr-&gt;fill();

  return true;
}


bool Clock::on_timeout()
{
    // force our program to redraw the entire clock.
    Glib::RefPtr&lt;Gdk::Window&gt; win = get_window();
    if (win)
    {
        Gdk::Rectangle r(0, 0, get_allocation().get_width(),
                get_allocation().get_height());
        win-&gt;invalidate_rect(r, false);
    }
    return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "clock.h"
#include &lt;gtkmm/main.h&gt;
#include &lt;gtkmm/window.h&gt;

int main(int argc, char** argv)
{
   Gtk::Main kit(argc, argv);

   Gtk::Window win;
   win.set_title("Cairomm Clock");

   Clock c;
   win.add(c);
   c.show();

   Gtk::Main::run(win);

   return 0;
}
</programlisting>
<!-- end inserted example code -->
      <para>
          As before, almost all of the interesting stuff is done in the expose
          event handler <methodname>on_expose_event()</methodname>. Before we dig
          into the expose event handler, notice that the constructor for the
          <classname>Clock</classname> widget connects a handler function
          <methodname>onSecondElapsed()</methodname> to a timer with a timeout
          period of 1000 milliseconds (1 second). This means that
          <methodname>onSecondElapsed()</methodname> will get called once per
          second. The sole responsibility of this function is to invalidate
          the window so that <application>gtkmm</application> will be forced to redraw it.
      </para>
      <para>
          Now let's take a look at the code that performs the actual drawing.
          The first section of <methodname>on_expose_event()</methodname> should be
          pretty familiar by now as it's mostly 'boilerplate' code for getting
          the <classname>Gdk::Window</classname>, creating a
          <classname>Cairo::Context</classname>, and clipping to the area that
          we want to re-draw. This example again scales the coordinate system
          to be a unit square so that it's easier to draw the clock as a
          percentage of window size so that it will automatically scale when
          the window size is adjusted. Furthermore, the coordinate system is
          scaled over and down so that the (0, 0) coordinate is in the very
          center of the window.
      </para>
      <para>
          The function <methodname>Cairo::Context::paint()</methodname> is used here
          to set the background color of the window. This function takes no
          arguments and fills the current surface (or the clipped portion of
          the surface) with the source color currently active. After setting
          the background color of the window, we draw a circle for the clock
          outline, fill it with white, and then stroke the outline in black.
          Notice that both of these actions use the
          <methodname>_preserve</methodname> variant to preserve the current path,
          and then this same path is clipped to make sure than our next lines
          don't go outside the outline of the clock.
      </para>
      <para>
          After drawing the outline, we go around the clock and draw ticks for
          every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally
          ready to implement the time-keeping functionality of the clock, which
          simply involves getting the current values for hours, minutes and
          seconds, and drawing the hands at the correct angles.
      </para>
  </sect1>
</chapter>

<chapter id="chapter-draganddrop">
<title>Ziehen und Ablegen</title>
<para>
<classname>Gtk::Widget</classname> has several methods and signals which are
prefixed with "drag_". These are used for Drag and Drop.
</para>
<sect1 id="sec-dnd-sources-destinations">
<title>Quellen und Ziele</title>
<para>
Things are dragged from <literal>sources</literal> to be dropped on
<literal>destinations</literal>. Each source and destination has infomation
about the data formats that it can send or receive, provided by
<classname>Gtk::TargetEntry</classname> items. A drop destination will only
accept a dragged item if they both share a compatible
<classname>Gtk::TargetEntry</classname> item. Appropriate signals will then be
emitted, telling the signal handlers which
<classname>Gtk::TargetEntry</classname> was used.
</para>
<para>
<classname>Gtk::TargetEntry</classname> objects contain this information:
<itemizedlist>
<listitem><para>target: A name, such as "STRING"</para></listitem>
<listitem><para>info: An identifier which will be sent to your signals to tell you which TargetEntry was used.</para></listitem>
<listitem><para>flags: Used only for drag and drop, this specifies whether the data may be dragged to other widgets and applications, or only to the same ones.</para></listitem>
</itemizedlist>
</para>

</sect1>

<sect1 id="sec-dnd-methods">
<title>Methoden</title>
<para>
<classname>Widgets</classname> can be identified as sources or destinations
using these <classname>Gtk::Widget</classname> methods:
</para>
<programlisting>void drag_source_set(const ArrayHandle_TargetEntry&amp; targets,
      GdkModifierType start_button_mask, GdkDragAction actions);</programlisting>

<itemizedlist>
<listitem>
    <para>
        <literal>targets</literal> is a container of
        <classname>Gtk::TargetEntry</classname>
        (<classname>std::list&lt;Gtk::TargetEntry&gt;</classname> or
        <classname>std::vector&lt;Gtk::TargetEntry&gt;</classname>, for
        instance) elements.
    </para>
</listitem>
<listitem>
    <para>
        <literal>start_button_mask</literal> is an ORed combination of values,
        which specify which modifier key or mouse button must be pressed to
        start the drag.
    </para>
</listitem>
<listitem>
    <para>
        <literal>actions</literal> is an ORed combination of values, which
        specified which Drag and Drop operations will be possible from this
        source - for instance, copy, move, or link. The user can choose between
        the actions by using modifier keys, such as <keycap>Shift</keycap> to
        change from <literal>copy</literal> to <literal>move</literal>, and
        this will be shown by a different cursor.
    </para>
</listitem>
</itemizedlist>

<programlisting>void drag_dest_set(const ArrayHandle_TargetEntry&amp; targets,
    GtkDestDefaults flags, GdkDragAction actions);</programlisting>

<itemizedlist>
<listitem>
    <para>
        <literal>flags</literal> is an ORed combination of values which
        indicates how the widget will respond visually to Drag and Drop items.
    </para>
</listitem>
<listitem>
    <para>
        <literal>actions</literal> indicates the Drag and Drop actions which
        this destination can receive - see the description above.
    </para>
</listitem>
</itemizedlist>
</sect1>

<sect1 id="sec-dnd-signals">
<title>Signale</title>
<para>
When a drop destination has accepted a dragged item, certain signals will be
emitted, depending on what action has been selected. For instance, the user
might have held down the <keycap>Shift</keycap> key to specify a
<literal>move</literal> rather than a <literal>copy</literal>. Remember that
the user can only select the actions which you have specified in your calls to
<methodname>drag_dest_set()</methodname> and
<methodname>drag_source_set()</methodname>.
</para>

<sect2 id="sec-dnd-signals-copy">
<title>Kopieren</title>
<para>
The source widget will emit these signals, in this order:
<itemizedlist>
<listitem><para><literal>drag_begin</literal>: Provides DragContext.</para></listitem>
<listitem><para><literal>drag_motion</literal>: Provides DragContext and coordinates. You can call the drag_status() method of the DragContext to indicate which target will be accepted.</para></listitem>
<listitem><para><literal>drag_get</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>GtkSelectionData</literal> structure, in which you should put the requested data.</para></listitem>
<listitem><para><literal>drag_drop</literal>: Provides DragContext and coordinates.</para></listitem>
<listitem><para><literal>drag_end</literal>: Provides DragContext.</para></listitem>
</itemizedlist>
</para>
<para>
The destination widget will emit this signal, after the source destination has emitted the <literal>drag_get</literal> signal:
<itemizedlist>
<listitem>
    <para>
        <literal>drag_data_received</literal>: Provides <literal>info</literal>
        about the dragged data format, and a
        <literal>GtkSelectionData</literal> structure which contains the
        dropped data. You should  call the <methodname>drag_finish()</methodname>
        method of the <literal>DragContext</literal> to indicate whether the
        operation was successful.
    </para>
</listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="dnd-signal-move">
<title>Verschieben</title>
<para>During a <literal>move</literal>, the source widget will also emit this signal:
<itemizedlist>
<listitem><para><literal>drag_delete</literal>: Gives the source the opportunity to delete the original data if that's appropriate.</para></listitem>
</itemizedlist>
</para>
</sect2>

<!--
<sect2 id="dnd-signal-link">
<title>Link</title>
<para>TODO: Find an example or documentation.</para>
</sect2>
-->
</sect1>

<sect1 id="sec-dragcontext">
<title>DragContext</title>
<para>
The drag and drop signals provide a DragContext, which contains some
information about the drag and drop operation and can be used to influence the
process. For instance, you can discover the source widget, or  change the drag
and drop icon, by using the <methodname>set_icon()</methodname> methods. More
importantly, you should call the <methodname>drag_finish()</methodname> method from
your <literal>drag_data_received</literal> signal handler to indicate whether
the drop was successful.
</para>
</sect1>

<sect1 id="sec-dnd-example">
<title>Beispiel</title>
<para>Here is a very simple example, demonstrating a drag and drop <literal>Copy</literal> operation:</para>

<figure id="figure-drag-and-drop">
  <title>Ziehen und Ablegen</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/drag_and_drop.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/drag_and_drop?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>dndwindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_DNDWINDOW_H
#define GTKMM_EXAMPLE_DNDWINDOW_H

#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/label.h&gt;
#include &lt;gtkmm/window.h&gt;
#include &lt;gtkmm/button.h&gt;

class DnDWindow : public Gtk::Window
{

public:
  DnDWindow();
  virtual ~DnDWindow();

protected:
  //Signal handlers:
  void on_button_drag_data_get(
          const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context,
          Gtk::SelectionData&amp; selection_data, guint info, guint time);
  void on_label_drop_drag_data_received(
          const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int x, int y,
          const Gtk::SelectionData&amp; selection_data, guint info, guint time);

  //Member widgets:
  Gtk::HBox m_HBox;
  Gtk::Button m_Button_Drag;
  Gtk::Label m_Label_Drop;
};

#endif // GTKMM_EXAMPLE_DNDWINDOW_H
</programlisting>
<para>File: <filename>dndwindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "dndwindow.h"
#include &lt;iostream&gt;

DnDWindow::DnDWindow()
: m_Button_Drag("Drag Here\n"),
  m_Label_Drop("Drop here\n")
{
  set_title("DnD example");

  add(m_HBox);

  //Targets:
  std::vector&lt;Gtk::TargetEntry&gt; listTargets;
  listTargets.push_back( Gtk::TargetEntry("STRING") );
  listTargets.push_back( Gtk::TargetEntry("text/plain") );

  //Drag site:

  //Make m_Button_Drag a DnD drag source:
  m_Button_Drag.drag_source_set(listTargets);

  //Connect signals:
  m_Button_Drag.signal_drag_data_get().connect(sigc::mem_fun(*this,
              &amp;DnDWindow::on_button_drag_data_get));

  m_HBox.pack_start(m_Button_Drag);

  //Drop site:

  //Make m_Label_Drop a DnD drop destination:
  m_Label_Drop.drag_dest_set(listTargets);

  //Connect signals:
  m_Label_Drop.signal_drag_data_received().connect(sigc::mem_fun(*this,
              &amp;DnDWindow::on_label_drop_drag_data_received) );

  m_HBox.pack_start(m_Label_Drop);

  show_all();
}

DnDWindow::~DnDWindow()
{
}

void DnDWindow::on_button_drag_data_get(
        const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp;,
        Gtk::SelectionData&amp; selection_data, guint, guint)
{
  selection_data.set(selection_data.get_target(), 8 /* 8 bits format */,
          (const guchar*)"I'm Data!",
          9 /* the length of I'm Data! in bytes */);
}

void DnDWindow::on_label_drop_drag_data_received(
        const Glib::RefPtr&lt;Gdk::DragContext&gt;&amp; context, int, int,
        const Gtk::SelectionData&amp; selection_data, guint, guint time)
{
  const int length = selection_data.get_length();
  if((length &gt;= 0) &amp;&amp; (selection_data.get_format() == 8))
  {
    std::cout &lt;&lt; "Received \"" &lt;&lt; selection_data.get_data_as_string()
        &lt;&lt; "\" in label " &lt;&lt; std::endl;
  }

  context-&gt;drag_finish(false, false, time);
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "dndwindow.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  DnDWindow dndWindow;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(dndWindow);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

<para>
There is a more complex example in examples/dnd.
</para>

</sect1>

</chapter>

<chapter id="chapter-clipboard">
<title>Die Zwischenablage</title>
<para>Simple text copy-paste functionality is provided for free by widgets such as Gtk::Entry and Gtk::TextView, but you might need special code to deal with your own data formats. For instance, a drawing program would need special code to allow copy and paste within a view, or between documents.</para>

<para>
<classname>Gtk::Clipboard</classname> is a singleton. You can get the one and
only instance with <methodname>Gtk::Clipboard::get()</methodname>.
</para>

<para>
So your application doesn't need to wait for clipboard operations, particularly
between the time when the user chooses Copy and then later chooses Paste, most
<classname>Gtk::Clipboard</classname> methods take
<classname>sigc::slot</classname>s which specify callback methods. When
<classname>Gtk::Clipboard</classname> is ready, it will call these methods,
either providing the requested data, or asking for data.
</para>

<para><ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Clipboard.html">Referenz</ulink></para>

<sect1 id="sec-clipboard-targets">
<title>Ziele</title>
<para>
Different applications contain different types of data, and they might make that data available in
a variety of formats. <application>gtkmm</application> calls these data types <literal>target</literal>s.</para>

<para>
For instance, gedit can supply and receive the <literal>"UTF8_STRING"</literal> target, so you can paste data into gedit from any application that supplies that target. Or two different image editing applications might supply and receive a variety of image formats as targets. As long as one application can receive one of the targets that the other supplies then you will be able to copy data from one to the other.
</para>

<para>
A target can be in a variety of binary formats. This chapter, and the examples,
assume that the data is 8-bit text. This would allow us to use an XML format
for the clipboard data. However this would probably not be appropriate for
binary data such as images. <classname>Gtk::Clipboard</classname> provides
overloads that allow you to specify the format in more detail if
necessary.
</para>

<para>The <link linkend="chapter-draganddrop">Drag and Drop</link> API uses the same mechanism. You should probably use the same data targets and formats for both Clipboard and Drag and Drap operations.</para>
</sect1>

<sect1 id="sec-clipboard-copy">
<title>Kopieren</title>
<para>
When the user asks to copy some data, you should tell the
<classname>Clipboard</classname> what targets are available, and provide the
callback methods that it can use to get the data. At this point you should
store a copy of the data, to be provided when the clipboard calls your callback
method in repsonse to a paste.
</para>
<para>Zum Beispiel,</para>
<programlisting>Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();

//Targets:
std::list&lt;Gtk::TargetEntry&gt; listTargets;
listTargets.push_back( Gtk::TargetEntry("example_custom_target") );
listTargets.push_back( Gtk::TargetEntry("UTF8_STRING") );

refClipboard-&gt;set( listTargets,
    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );</programlisting>

<para>Your callback will then provide the store data when the user chooses to paste the data. For instance:
</para>
<programlisting>void ExampleWindow::on_clipboard_get(
    Gtk::SelectionData&amp; selection_data, guint info)
{
  const Glib::ustring target = selection_data.get_target();

  if(target == "example_custom_target")
    selection_data.set("example_custom_target", m_ClipboardStore);
}</programlisting>
<para>
The <literal>ideal</literal> example below can supply more than one clipboard target.
</para>

<para>The clear callback allows you to free the memory used by your stored data when the clipboard replaces its data with something else.
</para>

</sect1>

<sect1 id="sec-clipboard-paste">
<title>Einfügen</title>
<para>
When the user asks to paste data from the <classname>Clipboard</classname>, you
should request a specific format and provide a callback method which will be
called with the actual data. For instance:
</para>
<programlisting>refClipboard-&gt;request_contents("example_custom_target",
    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );</programlisting>

<para>Here is an example callback method:
</para>
<programlisting>void ExampleWindow::on_clipboard_received(
    const Gtk::SelectionData&amp; selection_data)
{
  Glib::ustring clipboard_data = selection_data.get_data_as_string();
  //Do something with the pasted data.
}</programlisting>

<sect2 id="dnd-discovering-targets">
<title>Discovering the available targets</title>
<para>
To find out what targets are currently available on the
<classname>Clipboard</classname> for pasting, call the
<methodname>request_targets()</methodname> method, specifying a method to be called
with the information. For instance:
</para>
<programlisting>refClipboard-&gt;request_targets( sigc::mem_fun(*this,
    &amp;ExampleWindow::on_clipboard_received_targets) );</programlisting>

<para>
In your callback, compare the list of available targets with those that your application supports for pasting. You could enable or disable a Paste menu item, depending on whether pasting is currently possible. For instance:
</para>
<programlisting>void ExampleWindow::on_clipboard_received_targets(
  const Glib::StringArrayHandle&amp; targets_array)
{
  // Get the list of available clipboard targets:
  std::list&lt;std::string&gt; targets = targets_array;

  const bool bPasteIsPossible =
    std::find(targets.begin(), targets.end(),
      example_target_custom) != targets.end();

  // Enable/Disable the Paste button appropriately:
  m_Button_Paste.set_sensitive(bPasteIsPossible);
}</programlisting>
</sect2>

</sect1>

<sect1 id="sec-clipboard-examples"><title>Beispiele</title>

<sect2 id="sec-clipboard-example-simple"><title>Einfach</title>
<para>
This example allows copy and pasting of application-specific data, using the
standard text target. Although this is simple, it's not ideal because it does
not identify the <classname>Clipboard</classname> data as being of a particular
type.
</para>

<figure id="figure-clipboard-simple">
  <title>Zwischenablage - Einfach</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/clipboard_simple.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/clipboard/simple/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_copy();
  void on_button_paste();
  void on_clipboard_text_received(const Glib::ustring&amp; text);

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::Label m_Label;
  
  Gtk::Table m_Table;
  Gtk::ToggleButton m_ButtonA1, m_ButtonA2, m_ButtonB1, m_ButtonB2;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Copy, m_Button_Paste;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Label("Select cells in the table, click Copy, then open a second "
        "instance of this example to try pasting the copied data."),
  m_Table(2, 2, true),
  m_ButtonA1("A1"), m_ButtonA2("A2"), m_ButtonB1("B1"), m_ButtonB2("B2"),
  m_Button_Copy(Gtk::Stock::COPY), m_Button_Paste(Gtk::Stock::PASTE)
{
  set_title("Gtk::Clipboard example");
  set_border_width(12);

  add(m_VBox);

  m_VBox.pack_start(m_Label, Gtk::PACK_SHRINK);

  //Fill Table:
  m_VBox.pack_start(m_Table);
  m_Table.attach(m_ButtonA1, 0, 1, 0, 1);
  m_Table.attach(m_ButtonA2, 1, 2, 0, 1);
  m_Table.attach(m_ButtonB1, 0, 1, 1, 2);
  m_Table.attach(m_ButtonB2, 1, 2, 1, 2);

  //Add ButtonBox to bottom:
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);
  m_VBox.set_spacing(6);

  //Fill ButtonBox:
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_ButtonBox.pack_start(m_Button_Copy, Gtk::PACK_SHRINK);
  m_Button_Copy.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_copy) );
  m_ButtonBox.pack_start(m_Button_Paste, Gtk::PACK_SHRINK);
  m_Button_Paste.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_paste) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_copy()
{
  //Build a string representation of the stuff to be copied:
  //Ideally you would use XML, with an XML parser here:
  Glib::ustring strData;
  strData += m_ButtonA1.get_active() ? "1" : "0";
  strData += m_ButtonA2.get_active() ? "1" : "0";
  strData += m_ButtonB1.get_active() ? "1" : "0";
  strData += m_ButtonB2.get_active() ? "1" : "0";

  Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();
  refClipboard-&gt;set_text(strData);
}

void ExampleWindow::on_button_paste()
{
  //Tell the clipboard to call our method when it is ready:
  Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();
  refClipboard-&gt;request_text(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_text_received) );
}

void ExampleWindow::on_clipboard_text_received(const Glib::ustring&amp; text)
{
  //See comment in on_button_copy() about this silly clipboard format.
  if(text.size() &gt;= 4)
  {
    m_ButtonA1.set_active( text[0] == '1' );
    m_ButtonA2.set_active( text[1] == '1' );
    m_ButtonB1.set_active( text[2] == '1' );
    m_ButtonB2.set_active( text[3] == '1' );
  }
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

<sect2 id="sec-clipboard-example-ideal"><title>Ideal</title>
<para>This is like the simple example, but it
<orderedlist>
<listitem><simpara>Defines a custom clipboard target, though the format of that target is still text.</simpara></listitem>
<listitem><simpara>It supports pasting of 2 targets - both the custom one and a text one that creates an arbitrary text representation of the custom data.</simpara></listitem>
<listitem><simpara>It uses <methodname>request_targets()</methodname> and the <literal>owner_change</literal> signal and disables the Paste button if it can't use anything on the clipboard.</simpara></listitem>
</orderedlist>
</para>

<figure id="figure-clipboard-ideal">
  <title>Zwischenablage - Ideal</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/clipboard_ideal.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/clipboard/ideal/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_copy();
  void on_button_paste();

  void on_clipboard_owner_change(GdkEventOwnerChange* event);
  void on_clipboard_get(Gtk::SelectionData&amp; selection_data, guint info);
  void on_clipboard_clear();

  void on_clipboard_received(const Gtk::SelectionData&amp; selection_data);
  void on_clipboard_received_targets(const Glib::StringArrayHandle&amp; targets_array);
   
  virtual void update_paste_status(); //Disable the paste button if there is nothing to paste.

  //Child widgets:
  Gtk::VBox m_VBox;

  Gtk::Label m_Label;
  
  Gtk::Table m_Table;
  Gtk::ToggleButton m_ButtonA1, m_ButtonA2, m_ButtonB1, m_ButtonB2;

  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Copy, m_Button_Paste;

  Glib::ustring m_ClipboardStore; //Keep copied stuff here, until it is pasted. This could be a big complex data structure.
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;algorithm&gt;

namespace
{

//These should usually be MIME types.
const char example_target_custom[] = "gtkmmclipboardexample";
const char example_target_text[]   = "UTF8_STRING";

} // anonymous namespace


ExampleWindow::ExampleWindow()
: m_Label("Select cells in the table, click Copy, then open a second instance "
          "of this example to try pasting the copied data.\nOr try pasting the "
          "text representation into gedit."),
  m_Table(2, 2, true),
  m_ButtonA1("A1"), m_ButtonA2("A2"), m_ButtonB1("B1"), m_ButtonB2("B2"),
  m_Button_Copy(Gtk::Stock::COPY), m_Button_Paste(Gtk::Stock::PASTE)
{
  set_title("Gtk::Clipboard example");
  set_border_width(12);

  add(m_VBox);

  m_VBox.pack_start(m_Label, Gtk::PACK_SHRINK);

  //Fill Table:
  m_VBox.pack_start(m_Table);
  m_Table.attach(m_ButtonA1, 0, 1, 0, 1);
  m_Table.attach(m_ButtonA2, 1, 2, 0, 1);
  m_Table.attach(m_ButtonB1, 0, 1, 1, 2);
  m_Table.attach(m_ButtonB2, 1, 2, 1, 2);

  //Add ButtonBox to bottom:
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);
  m_VBox.set_spacing(6);

  //Fill ButtonBox:
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_ButtonBox.pack_start(m_Button_Copy, Gtk::PACK_SHRINK);
  m_Button_Copy.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_copy) );
  m_ButtonBox.pack_start(m_Button_Paste, Gtk::PACK_SHRINK);
  m_Button_Paste.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_paste) );

  //Connect a signal handler that will be called when the contents of
  //the clipboard change.
  Gtk::Clipboard::get()-&gt;signal_owner_change().connect(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_owner_change) );

  show_all_children();

  update_paste_status();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_copy()
{
  //Build a string representation of the stuff to be copied:
  //Ideally you would use XML, with an XML parser here:
  Glib::ustring strData;
  strData += m_ButtonA1.get_active() ? "1" : "0";
  strData += m_ButtonA2.get_active() ? "1" : "0";
  strData += m_ButtonB1.get_active() ? "1" : "0";
  strData += m_ButtonB2.get_active() ? "1" : "0";

  Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();

  //Targets:
  std::vector&lt;Gtk::TargetEntry&gt; listTargets;

  listTargets.push_back( Gtk::TargetEntry(example_target_custom) );
  listTargets.push_back( Gtk::TargetEntry(example_target_text) );

  refClipboard-&gt;set(listTargets, sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_get), sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_clipboard_clear) );

  //Store the copied data until it is pasted:
  //(Must be done after the call to refClipboard-&gt;set, because that call
  //may trigger a call to on_clipboard_clear.)
  m_ClipboardStore = strData;

  update_paste_status();
}

void ExampleWindow::on_button_paste()
{
  //Tell the clipboard to call our method when it is ready:
  Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();

  refClipboard-&gt;request_contents(example_target_custom, 
    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );

  update_paste_status();
}

void ExampleWindow::on_clipboard_owner_change(GdkEventOwnerChange*)
{
  update_paste_status();
}

void ExampleWindow::on_clipboard_get(Gtk::SelectionData&amp; selection_data, guint)
{
  //info is meant to indicate the target, but it seems to be always 0,
  //so we use the selection_data's target instead.

  const std::string target = selection_data.get_target();

  if(target == example_target_custom)
  {
    // This set() override uses an 8-bit text format for the data.
    selection_data.set(example_target_custom, m_ClipboardStore);
  }
  else if(target == example_target_text)
  {
    //Build some arbitrary text representation of the data,
    //so that people see something when they paste into a text editor:
    Glib::ustring text_representation;

    text_representation += m_ButtonA1.get_active() ? "A1, " : "";
    text_representation += m_ButtonA2.get_active() ? "A2, " : "";
    text_representation += m_ButtonB1.get_active() ? "B1, " : "";
    text_representation += m_ButtonB2.get_active() ? "B2, " : "";

    selection_data.set_text(text_representation);
  }
  else
  {
    g_warning("ExampleWindow::on_clipboard_get(): "
            "Unexpected clipboard target format.");
  }
}

void ExampleWindow::on_clipboard_clear()
{
  //This isn't really necessary. I guess it might save memory.
  m_ClipboardStore.clear();
}

void ExampleWindow::on_clipboard_received(
        const Gtk::SelectionData&amp; selection_data)
{
  const std::string target = selection_data.get_target();

  //It should always be this, because that' what we asked for when calling
  //request_contents().
  if(target == example_target_custom)
  {
    Glib::ustring clipboard_data = selection_data.get_data_as_string();

    //See comment in on_button_copy() about this silly clipboard format.
    if(clipboard_data.size() &gt;= 4)
    {
      m_ButtonA1.set_active( clipboard_data[0] == '1' );
      m_ButtonA2.set_active( clipboard_data[1] == '1' );
      m_ButtonB1.set_active( clipboard_data[2] == '1' );
      m_ButtonB2.set_active( clipboard_data[3] == '1' );
    }
  }
}

void ExampleWindow::update_paste_status()
{
  //Disable the paste button if there is nothing to paste.

  Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();

  //Discover what targets are available:
  refClipboard-&gt;request_targets(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_received_targets) );
}

void ExampleWindow::on_clipboard_received_targets(
  const Glib::StringArrayHandle&amp; targets_array)
{
  // Get the list of available clipboard targets:
  std::vector&lt;std::string&gt; targets = targets_array;

  const bool bPasteIsPossible =
    std::find(targets.begin(), targets.end(),
      example_target_custom) != targets.end();

  // Enable/Disable the Paste button appropriately:
  m_Button_Paste.set_sensitive(bPasteIsPossible);
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>


</chapter>

<chapter id="chapter-printing">
<title>Drucken</title>

<para>
At the application development level, <application>gtkmm</application>'s printing API
provides dialogs that are consistent across applications and allows us of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific backends and printer-specific drivers are used.
</para>

<sect1 id="sec-printoperation">
<title>PrintOperation</title>

<para>
The primary object is <classname>Gtk::PrintOperation</classname>, allocated
for each print operation. To handle page drawing connect to its signals,
or inherit from it and override the default virtual signal handlers.
<classname>PrintOperation</classname> automatically handles all the settings
affecting the print loop.
</para>

<sect2 id="sec-printoperation-signals">
<title>Signale</title>

<para>
The <methodname>PrintOperation::run()</methodname> method starts the print loop,
during which various signals are emitted:

<itemizedlist>
  <listitem>
    <para>
      <literal>begin_print</literal>:
      You must handle this signal, because this is where you
      create and set up a <classname>Pango::Layout</classname> using the
      provided <classname>Gtk::PrintContext</classname>, and break up your
      printing output into pages.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>paginate</literal>: Pagination is potentially slow so if you
      need to monitor it you can call the
      <methodname>PrintOperation::set_show_progress()</methodname> method and
      handle this signal.
    </para>
  </listitem>

  <listitem>
    <para>Für jede darzustellende Seite werden folgende Signale ausgegeben: <itemizedlist>
        <listitem>
          <para>
            <literal>request_page_setup</literal>: Provides a
            <classname>PrintContext</classname>, page number and
            <classname>Gtk::PageSetup</classname>. Handle this signal if you
            need to modify page setup on a per-page basis.
          </para>
        </listitem>

        <listitem>
          <para>
            <literal>draw_page</literal>: You must handle this signal, which provides a
            <classname>PrintContext</classname> and a page number.
            The <classname>PrintContext</classname> should be used
            to create a <classname>Cairo::Context</classname> into which
            the provided page should be drawn. To render text, iterate over
            the <classname>Pango::Layout</classname> you created in the
            <literal>begin_print</literal> handler.
          </para>
        </listitem>
      </itemizedlist></para>
  </listitem>

  <listitem>
    <para>
      <literal>end_print</literal>: A handler for it is a safe place to free
      any resources related to a <classname>PrintOperation</classname>.
      If you have your custom class that inherits from
      <classname>PrintOperation</classname>, it is naturally simpler to do it
      in the destructor.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>done</literal>: This signal is emitted when printing is finished, meaning when the
      print data is spooled. Note that the provided
      <literal>Gtk::PrintOperationResult</literal> may indicate that
      an error occurred. In any case you probably want to notify the user
      about the final status.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>status_changed</literal>: Emitted whenever a print job's
      status changes, until it is finished. Call the
      <methodname>PrintOperation::set_track_print_status()</methodname> method to
      monitor the job status after spooling. To see the status, use
      <methodname>get_status()</methodname> or
      <methodname>get_status_string()</methodname>.
    </para>
  </listitem>
</itemizedlist>

</para>

<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PrintOperation.html">Referenz</ulink>
</para>

</sect2>

</sect1>

<sect1 id="sec-page-setup">
<title>Seite einrichten</title>

<para>
The <classname>PrintOperation</classname> class has a method called
<methodname>set_default_page_setup()</methodname> which selects the default
paper size, orientation and margins. To show a page setup dialog from your
application, use the <methodname>Gtk::run_page_setup_dialog()</methodname> method,
which returns a <classname>Gtk::PageSetup</classname> object with the chosen
settings. Use this object to update a <classname>PrintOperation</classname>
and to access the selected <classname>Gtk::PaperSize</classname>,
<literal>Gtk::PageOrientation</literal> and printer-specific margins.
</para>
<para>You should save the chosen <classname>Gtk::PageSetup</classname>
so you can use it again if the page setup dialog is shown again.</para>

<para>Zum Beispiel, <programlisting>
//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...
Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);
m_refPageSetup = new_page_setup;
</programlisting></para>

<para>
<ulink url="http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PageSetup.html">Referenz</ulink>
</para>

<para>
The Cairo coordinate system, in the <literal>draw_page</literal> handler,
is automatically rotated to the current page orientation. It is normally
within the printer margins, but you can change that via the
<methodname>PrintOperation::set_use_full_page()</methodname>
method. The default measurement unit is device pixels. To select other units,
use the <methodname>PrintOperation::set_unit()</methodname> method.
</para>

</sect1>

<sect1 id="sec-printing-rendering-text">
<title>Darstellen von Text</title>

<para>
Text rendering is done using Pango.
The <classname>Pango::Layout</classname> object for printing should be created by calling
the <methodname>PrintContext::create_pango_layout()</methodname> method.
The <classname>PrintContext</classname> object also provides the page metrics,
via <methodname>get_width()</methodname> and <methodname>get_height()</methodname>.
The number of pages can be set with
<methodname>PrintOperation::set_n_pages()</methodname>. To actually render the
 Pango text in <literal>on_draw_page</literal>, get a
<classname>Cairo::Context</classname> with
<methodname>PrintContext::get_cairo_context()</methodname> and show the
<classname>Pango::LayoutLine</classname>s that appear within the requested
page number.
</para>

<para>
See <link linkend="sec-printing-example-simple">an example</link>
of exactly how this can be done.
</para>

</sect1>

<sect1 id="sec-async-printing-ops">
<title>Asynchrone Vorgänge</title>

<para>
By default, <methodname>PrintOperation::run()</methodname> returns when a print
operation is completed. If you need to run a non-blocking print operation,
call <methodname>PrintOperation::set_allow_async()</methodname>. Note that <methodname>set_allow_async()</methodname> is not supported
on all platforms, however the <literal>done</literal> signal will still be emitted.
</para>

<para>
<methodname>run()</methodname> may return
<literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. To track status
and handle the result or error you need to implement signal handlers for
the <literal>done</literal> and <literal>status_changed</literal> signals:
</para>

<para>Zum Beispiel, <programlisting>
// in class ExampleWindow's method...
Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();
// ...set up op...
op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));
// run the op
</programlisting></para>

<para>Second, check for an error and connect to the <literal>status_changed</literal> signal. For instance:
<programlisting>
void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)
{
  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)
    //notify user
  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)
    //Update PrintSettings with the ones used in this PrintOperation

  if (! op-&gt;is_finished())
    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));
}
</programlisting>
</para>

<para>Finally, check the status. For instance,
<programlisting>
void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)
{
  if (op-&gt;is_finished())
    //the print job is finished
  else
    //get the status with get_status() or get_status_string()

  //update UI
}
</programlisting>
</para>

</sect1>

<sect1 id="sec-printing-export-to-pdf">
<title>PDF-Export</title>
<para>
The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to generate a pdf file directly from code. For instance,

<programlisting>
Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();
// ...set up op...
op-&gt;set_export_filename("test.pdf");
Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);
</programlisting>

</para>

</sect1>

<sect1 id="sec-extending-print-dialog">
<title>Erweitern des Druckdialogs</title>

<para>
You may add a custom tab to the print dialog:

<itemizedlist>
  <listitem>
    <para>
      Set the title of the tab via
      <methodname>PrintOperation::set_custom_tab_label()</methodname>,
      create a new widget and return it from the
      <literal>create_custom_widget</literal> signal handler. You'll probably
      want this to be a container widget, packed with some others.
    </para>
  </listitem>

  <listitem>
    <para>
      Get the data from the widgets in the
      <literal>custom_widget_apply</literal> signal handler.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Although the <literal>custom_widget_apply</literal> signal provides the widget you
previously created, to simplify things you can keep the widgets you expect
to contain some user input as class members. For example, let's say you have
a <classname>Gtk::Entry</classname> called <literal>m_Entry</literal> as
a member of your <classname>CustomPrintOperation</classname> class:

<programlisting>
Gtk::Widget* CustomPrintOperation::on_create_custom_widget()
{
  set_custom_tab_label("My custom tab");

  Gtk::HBox* hbox = new Gtk::HBox(false, 8);
  hbox-&gt;set_border_width(6);

  Gtk::Label* label = Gtk::manage(new Gtk::Label("Enter some text: "));
  hbox-&gt;pack_start(*label, false, false);
  label-&gt;show();

  hbox-&gt;pack_start(m_Entry, false, false);
  m_Entry.show();

  return hbox;
}

void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)
{
  Glib::ustring user_input = m_Entry.get_text();
  //...
}
</programlisting>

</para>

<para>
The example in examples/book/printing/advanced demonstrates this.
</para>

</sect1>

<sect1 id="sec-printing-preview">
<title>Vorschau</title>

<para>Der native GTK+-Druckdialog verfügt über einen Vorschauknopf, aber Sie können die Vorschau auch direkt aus der Anwendung starten: <programlisting>
// in a class that inherits from Gtk::Window...
Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();
// ...set up op...
op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);
</programlisting></para>

<para>
On Unix, the default preview handler uses an external viewer program.
On Windows, the native preview dialog will be shown. If necessary you may
override this behaviour and provide a custom preview dialog. See the example
located in /examples/book/printing/advanced.
</para>

</sect1>

<sect1 id="sec-printing-example">
<title>Beispiel</title>

<sect2 id="sec-printing-example-simple">
<title>Einfach</title>

<para>
The following example demonstrates how to print some input from a user
interface. It shows how to implement <literal>on_begin_print</literal>
and <literal>on_draw_page</literal>, as well as how to track print status
and update the print settings.
</para>

<figure id="figure-printing-simple">
  <title>Drucken - Einfach</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/printing.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/printing/simple/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>printformoperation.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_PRINT_FORM_OPERATION_H
#define GTKMM_PRINT_FORM_OPERATION_H

#include &lt;pangomm.h&gt;
#include &lt;gtkmm.h&gt;
#include &lt;vector&gt;

//We derive our own class from PrintOperation,
//so we can put the actual print implementation here.
class PrintFormOperation : public Gtk::PrintOperation
{
 public:
  static Glib::RefPtr&lt;PrintFormOperation&gt; create();
  virtual ~PrintFormOperation();

  void set_name(const Glib::ustring&amp; name) { m_Name = name; }
  void set_comments(const Glib::ustring&amp; comments) { m_Comments = comments; }

 protected:
  PrintFormOperation();

  //PrintOperation default signal handler overrides:
  virtual void on_begin_print(const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; context);
  virtual void on_draw_page(const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; context, int page_nr);

  Glib::ustring m_Name;
  Glib::ustring m_Comments;
  Glib::RefPtr&lt;Pango::Layout&gt; m_refLayout;
  std::vector&lt;int&gt; m_PageBreaks; // line numbers where a page break occurs
};

#endif // GTKMM_PRINT_FORM_OPERATION_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;memory&gt;
#include &lt;vector&gt;

#include &lt;pangomm.h&gt;
#include &lt;gtkmm.h&gt;

class PrintFormOperation;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:

  void build_main_menu();

  void print_or_preview(Gtk::PrintOperationAction print_action);

  //PrintOperation signal handlers.
  //We handle these so can get necessary information to update the UI or print settings.
  //Our derived PrintOperation class also overrides some default signal handlers.
  void on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; operation);

  void on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; operation);

  //Action signal handlers:
  void on_menu_file_new();
  void on_menu_file_page_setup();
  void on_menu_file_print_preview();
  void on_menu_file_print();
  void on_menu_file_quit();

  //Printing-related objects:
  Glib::RefPtr&lt;Gtk::PageSetup&gt; m_refPageSetup;
  Glib::RefPtr&lt;Gtk::PrintSettings&gt; m_refSettings;


  //Child widgets:
  Gtk::VBox m_VBox;
  Gtk::Table m_Table;

  Gtk::Label m_NameLabel;
  Gtk::Entry m_NameEntry;

  Gtk::Label m_SurnameLabel;
  Gtk::Entry m_SurnameEntry;

  Gtk::Label m_CommentsLabel;
  Gtk::ScrolledWindow m_ScrolledWindow;
  Gtk::TextView m_TextView;
  
  Glib::RefPtr&lt;Gtk::TextBuffer&gt; m_refTextBuffer;

  unsigned m_ContextId;
  Gtk::Statusbar m_Statusbar;

  Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager;
  Glib::RefPtr&lt;Gtk::ActionGroup&gt; m_refActionGroup;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>printformoperation.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "printformoperation.h"

PrintFormOperation::PrintFormOperation()
{
}

PrintFormOperation::~PrintFormOperation()
{
}

Glib::RefPtr&lt;PrintFormOperation&gt; PrintFormOperation::create()
{
  return Glib::RefPtr&lt;PrintFormOperation&gt;(new PrintFormOperation());
}

void PrintFormOperation::on_begin_print(
        const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; print_context)
{
  //Create and set up a Pango layout for PrintData based on the passed
  //PrintContext: We then use this to calculate the number of pages needed, and
  //the lines that are on each page.
  m_refLayout = print_context-&gt;create_pango_layout();

  Pango::FontDescription font_desc("sans 12");
  m_refLayout-&gt;set_font_description(font_desc);

  const double width = print_context-&gt;get_width();
  const double height = print_context-&gt;get_height();

  m_refLayout-&gt;set_width(static_cast&lt;int&gt;(width * Pango::SCALE));

  //Set and mark up the text to print:
  Glib::ustring marked_up_form_text;
  marked_up_form_text += "&lt;b&gt;Name&lt;/b&gt;: " + m_Name + "\n\n";
  marked_up_form_text += "&lt;b&gt;Comments&lt;/b&gt;: " + m_Comments;

  m_refLayout-&gt;set_markup(marked_up_form_text);

  //Set the number of pages to print by determining the line numbers
  //where page breaks occur:
  const int line_count = m_refLayout-&gt;get_line_count();

  Glib::RefPtr&lt;Pango::LayoutLine&gt; layout_line;
  double page_height = 0;

  for (int line = 0; line &lt; line_count; ++line)
  {
    Pango::Rectangle ink_rect, logical_rect;

    layout_line = m_refLayout-&gt;get_line(line);
    layout_line-&gt;get_extents(ink_rect, logical_rect);

    const double line_height = logical_rect.get_height() / 1024.0;

    if (page_height + line_height &gt; height)
    {
      m_PageBreaks.push_back(line);
      page_height = 0;
    }

    page_height += line_height;
  }

  set_n_pages(m_PageBreaks.size() + 1);
}

void PrintFormOperation::on_draw_page(
        const Glib::RefPtr&lt;Gtk::PrintContext&gt;&amp; print_context, int page_nr)
{
  //Decide which lines we need to print in order to print the specified page:
  int start_page_line = 0;
  int end_page_line = 0;

  if(page_nr == 0)
  {
    start_page_line = 0;
  }
  else
  {
    start_page_line = m_PageBreaks[page_nr - 1];
  }

  if(page_nr &lt; static_cast&lt;int&gt;(m_PageBreaks.size()))
  {
    end_page_line = m_PageBreaks[page_nr];
  }
  else
  {
    end_page_line = m_refLayout-&gt;get_line_count();
  }

  //Get a Cairo Context, which is used as a drawing board:
  Cairo::RefPtr&lt;Cairo::Context&gt; cairo_ctx = print_context-&gt;get_cairo_context();

  //We'll use black letters:
  cairo_ctx-&gt;set_source_rgb(0, 0, 0);

  //Render Pango LayoutLines over the Cairo context:
  Pango::LayoutIter iter = m_refLayout-&gt;get_iter();

  double start_pos = 0;
  int line_index = 0;

  do
  {
    if(line_index &gt;= start_page_line)
    {
      Glib::RefPtr&lt;Pango::LayoutLine&gt; layout_line = iter.get_line();
      Pango::Rectangle logical_rect = iter.get_line_logical_extents();
      int baseline = iter.get_baseline();

      if (line_index == start_page_line)
      {
        start_pos = logical_rect.get_y() / 1024.0;
      }

      cairo_ctx-&gt;move_to(logical_rect.get_x() / 1024.0,
        baseline / 1024.0 - start_pos);

      layout_line-&gt;show_in_cairo_context(cairo_ctx);
    }

    line_index++;
  }
  while(line_index &lt; end_page_line &amp;&amp; iter.next_line());
}

</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include "printformoperation.h"

#include &lt;iostream&gt;

#include &lt;pangomm.h&gt;

const Glib::ustring app_title = "gtkmm Printing Example";

ExampleWindow::ExampleWindow()
  :
  m_Table(3, 2),
  m_NameLabel("Name"),
  m_SurnameLabel("Surname"),
  m_CommentsLabel("Comments")
{
  m_refPageSetup = Gtk::PageSetup::create();
  m_refSettings = Gtk::PrintSettings::create();

  m_ContextId = m_Statusbar.get_context_id(app_title);

  set_title(app_title);
  set_default_size(400, 300);

  add(m_VBox);

  build_main_menu();

  m_VBox.pack_start(m_Table);

  //Arrange the widgets inside the table:
  m_Table.attach(m_NameLabel, 0, 1, 0, 1);
  m_Table.attach(m_NameEntry, 1, 2, 0, 1);

  m_Table.attach(m_SurnameLabel, 0, 1, 1, 2, Gtk::SHRINK);
  m_Table.attach(m_SurnameEntry, 1, 2, 1, 2);

  //Add the TreeView, inside a ScrolledWindow:
  m_ScrolledWindow.add(m_TextView);

  //Only show the scrollbars when they are necessary:
  m_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);

  m_Table.attach(m_CommentsLabel, 0, 1, 2, 3, Gtk::SHRINK);
  m_Table.attach(m_ScrolledWindow, 1, 2, 2, 3);

  m_refTextBuffer = Gtk::TextBuffer::create();
  m_TextView.set_buffer(m_refTextBuffer);

  m_VBox.pack_start(m_Statusbar);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::build_main_menu()
{
  //Create actions for menus and toolbars:
  m_refActionGroup = Gtk::ActionGroup::create();

  //File menu:
  m_refActionGroup-&gt;add(
    Gtk::Action::create("FileMenu", "_File"));

  m_refActionGroup-&gt;add(
    Gtk::Action::create("New", Gtk::Stock::NEW),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new));

  m_refActionGroup-&gt;add(
    Gtk::Action::create("PageSetup", "Page _Setup"),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_page_setup));

  m_refActionGroup-&gt;add(
    Gtk::Action::create("PrintPreview", "Print Preview"),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_print_preview));

  m_refActionGroup-&gt;add(
    Gtk::Action::create("Print", Gtk::Stock::PRINT),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_print));

  m_refActionGroup-&gt;add(
    Gtk::Action::create("Quit", Gtk::Stock::QUIT),
    sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_quit));

  m_refUIManager = Gtk::UIManager::create();
  m_refUIManager-&gt;insert_action_group(m_refActionGroup);

  add_accel_group(m_refUIManager-&gt;get_accel_group());

  //Layout the actions in a menubar and toolbar:

  Glib::ustring ui_info =
        "&lt;ui&gt;"
        "  &lt;menubar name='MenuBar'&gt;"
        "    &lt;menu action='FileMenu'&gt;"
        "      &lt;menuitem action='New'/&gt;"
        "      &lt;menuitem action='PageSetup'/&gt;"
        "      &lt;menuitem action='PrintPreview'/&gt;"
        "      &lt;menuitem action='Print'/&gt;"
        "      &lt;separator/&gt;"
        "      &lt;menuitem action='Quit'/&gt;"
        "    &lt;/menu&gt;"
        "  &lt;/menubar&gt;"
        "  &lt;toolbar  name='ToolBar'&gt;"
        "    &lt;toolitem action='New'/&gt;"
        "    &lt;toolitem action='Print'/&gt;"
        "      &lt;separator/&gt;"
        "    &lt;toolitem action='Quit'/&gt;"
        "  &lt;/toolbar&gt;"
        "&lt;/ui&gt;";

  try
  {
    m_refUIManager-&gt;add_ui_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt; ex.what();
  }

  //Get the menubar and toolbar widgets, and add them to a container widget:
  Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget("/MenuBar");
  if(pMenubar)
    m_VBox.pack_start(*pMenubar, Gtk::PACK_SHRINK);

  Gtk::Widget* pToolbar = m_refUIManager-&gt;get_widget("/ToolBar") ;
  if(pToolbar)
    m_VBox.pack_start(*pToolbar, Gtk::PACK_SHRINK);
}

void ExampleWindow::on_printoperation_status_changed(
        const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; operation)
{
  Glib::ustring status_msg;

  if (operation-&gt;is_finished())
  {
    status_msg = "Print job completed.";
  }
  else
  {
    //You could also use get_status().
    status_msg = operation-&gt;get_status_string();
  }

  m_Statusbar.push(status_msg, m_ContextId);
}

void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result,
        const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; operation)
{
  //Printing is "done" when the print data is spooled.

  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)
  {
    Gtk::MessageDialog err_dialog(*this, "Error printing form", false,
            Gtk::MESSAGE_ERROR, Gtk::BUTTONS_OK, true);
    err_dialog.run();
  }
  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)
  {
    //Update PrintSettings with the ones used in this PrintOperation:
    m_refSettings = operation-&gt;get_print_settings();
  }

  if (! operation-&gt;is_finished())
  {
    //We will connect to the status-changed signal to track status
    //and update a status bar. In addition, you can, for example,
    //keep a list of active print operations, or provide a progress dialog.
    operation-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this,
                    &amp;ExampleWindow::on_printoperation_status_changed),
                operation));
  }
}

void ExampleWindow::print_or_preview(Gtk::PrintOperationAction print_action)
{
  //Create a new PrintOperation with our PageSetup and PrintSettings:
  //(We use our derived PrintOperation class)
  Glib::RefPtr&lt;PrintFormOperation&gt; print = PrintFormOperation::create();

  print-&gt;set_name(m_NameEntry.get_text() + " " + m_SurnameEntry.get_text());
  print-&gt;set_comments(m_refTextBuffer-&gt;get_text(false /*Don't include hidden*/));

  print-&gt;set_track_print_status();
  print-&gt;set_default_page_setup(m_refPageSetup);
  print-&gt;set_print_settings(m_refSettings);

  print-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_printoperation_done), print));
  try
  {
    print-&gt;run(print_action /* print or preview */, *this);
  }
  catch (const Gtk::PrintError&amp; ex)
  {
    //See documentation for exact Gtk::PrintError error codes.
    std::cerr &lt;&lt; "An error occurred while trying to run a print operation:"
        &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

void ExampleWindow::on_menu_file_new()
{
  //Clear entries and textview:
  m_NameEntry.set_text("");
  m_SurnameEntry.set_text("");
  m_refTextBuffer-&gt;set_text("");
  m_TextView.set_buffer(m_refTextBuffer);
}

void ExampleWindow::on_menu_file_page_setup()
{
  //Show the page setup dialog, asking it to start with the existing settings:
  Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup =
      Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);

  //Save the chosen page setup dialog for use when printing, previewing, or
  //showing the page setup dialog again:
  m_refPageSetup = new_page_setup;
}

void ExampleWindow::on_menu_file_print_preview()
{
  print_or_preview(Gtk::PRINT_OPERATION_ACTION_PREVIEW);
}

void ExampleWindow::on_menu_file_print()
{
  print_or_preview(Gtk::PRINT_OPERATION_ACTION_PRINT_DIALOG);
}

void ExampleWindow::on_menu_file_quit()
{
  hide();
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>

<chapter id="chapter-recent-documents">
  <title>Kürzlich geöffnete Dokumente</title>

  <para>
    <application>gtkmm</application> provides an easy way to manage recently used documents. The classes
    involved in implementing this functionality are
    <classname>RecentManager</classname>,
    <classname>RecentChooserDialog</classname>,
    <classname>RecentChooserMenu</classname>,
    <classname>RecentChooserWidget</classname>, and
    <classname>RecentFilter</classname>.
  </para>
  <para>
    Each item in the list of recently used files is identified by its URI, and
    can have associated metadata. The metadata can be used to specify how the
    file should be displayed, a description of the file, its mime type, which
    application registered it, whether it's private to the registering
    application, and several other things.
  </para>
  <sect1 id="sec-recentmanager">
    <title>RecentManager</title>
    <para>
      <classname>RecentManager</classname> acts as the central database of
      recently used files. You use this class to register new files, remove
      files from the list, or look up recently used files.
    </para>
    <para>
      You can create a new <classname>RecentManager</classname>, but you'll most
      likely just want to use the default one. You can get a reference to the
      default <classname>RecentManager</classname> with
      <methodname>get_default()</methodname>.
      </para>
    <sect2 id="recent-files-adding">
      <title>Hinzufügen von Objekten zur Liste der kürzlich geöffneten Dateien</title>
      <para>Im einfachsten Fall müssen Sie zum Hinzufügen einer Datei zur Liste der kürzlich geöffneten Dateien nur deren Adresse angeben. Zum Beispiel:</para>
      <programlisting>Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();
recent_manager-&gt;add_item(uri);</programlisting>
      <para>
        If you want to register a file with metadata, you can pass a
        <classname>RecentManager::Data</classname> parameter to
        <methodname>add_item()</methodname>. The metadata that can be set on a
        particular file item is as follows:
      </para>
      <itemizedlist>
        <listitem>
          <para><varname>app_exec</varname>: The command line to be used to launch
            this resource. This string may contain the "f" and "u" escape
            characters which will be expanded to the resource file path and URI
            respectively</para>
        </listitem>
        <listitem>
          <para><varname>app_name</varname>: The name of the application that
            registered the resource</para>
        </listitem>
        <listitem>
          <para><varname>description</varname>: A short description of the
            resource as a UTF-8 encoded string</para>
        </listitem>
        <listitem>
          <para><varname>display_name</varname>: The name of the resource to be
            used for display as a UTF-8 encoded string</para>
        </listitem>
        <listitem>
          <para><varname>groups</varname>: A list of groups associated with this
            item. Groups are essentially arbitrary strings associated with a
            particular resource. They can be thought of as 'categories' (such
            as "email", "graphics", etc) or tags for the resource.</para>
        </listitem>
        <listitem>
          <para><varname>is_private</varname>: Whether this resource should be
            visible only to applications that have registered it or not</para>
        </listitem>
        <listitem>
          <para><varname>mime_type</varname>: Der MIME-Type der Ressource</para>
        </listitem>
      </itemizedlist>
      <para>
        In addition to adding items to the list, you can also look up items from
        the list and modify or remove items.
      </para>
    </sect2>
    <sect2 id="recent-files-lookup">
      <title>Looking up Items in the List of Recent Files</title>
      <para>
        To look up recently used files, <classname>RecentManager</classname>
        provides several functions. To look up a specific item by its URI, you
        can use the <methodname>lookup_item()</methodname> function, which will
        return a <classname>RecentInfo</classname> class. If the specified URI
        did not exist in the list of recent files, the
        <classname>RecentInfo</classname> object will be invalid.
        <classname>RecentInfo</classname> provides an implementation for
        <methodname>operator bool()</methodname> which can be used to test for
        validity. For example:
      </para>
<programlisting>Gtk::RecentInfo info = recent_manager-&gt;lookup_item(uri);
if (info)
{
  // item was found
}</programlisting>
      <para>
        A <classname>RecentInfo</classname> object is essentially an object
        containing all of the metadata about a single recently-used file. You
        can use this object to look up any of the properties listed above. FIXME
        - add cross-reference.
      </para>
      <para>
        If you don't want to look for a specific URI, but instead want to get a
        list of all recently used items, <classname>RecentManager</classname>
        provides the <methodname>get_items()</methodname> function. The return
        value of this function can be assigned to any standard C++ container
        (e.g. <classname>std::vector</classname>,
        <classname>std::list</classname>, etc) and contains a list of all
        recently-used files up to a user-defined limit (FIXME: what's the
        default limit?). The following code demonstrates how you might get a
        list of recently-used files:
      </para>
      <programlisting>std::vector&lt;Gtk::RecentInfo&gt; info_list = recent_manager-&gt;get_items();</programlisting>
      <para>
        The limit on the number of items returned can be set
        by <methodname>set_limit()</methodname>, and queried with
        <methodname>get_limit()</methodname>.
      </para>
    </sect2>
    <sect2 id="recent-files-modifying">
      <title>Anpassen der Liste der kürzlich geöffneten Dateien</title>
      <para>
        There may be times when you need to modify the list of recent files.
        For instance, if a file is moved or renamed, you may need to update the
        file's location in the recent files list so that it doesn't point to an
        incorrect location. You can update an item's location by using
        <methodname>move_item()</methodname>.
      </para>
      <para>
        In addition to changing a file's URI, you can also remove items from the
        list, either one at a time or by clearint them all at once. The former
        is accomplished with <methodname>remove_item()</methodname>, the latter with
        <methodname>purge_items()</methodname>.
      </para>
      <note>
        <para>
        The functions <methodname>move_item()</methodname>,
        <methodname>remove_item()</methodname> and
        <methodname>purge_items()</methodname> have no effect on the actual files
        that are referred to by the URIs, they only modify the list of recent
        files.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="sec-recentchooser">
    <title>RecentChooser</title>
    <para>
      <classname>RecentChooser</classname> is an interface that can be
      implemented by widgets displaying the list of recently used files.
      <application>gtkmm</application> provides three built-in implementations for choosing recent files:
      <classname>RecentChooserWidget</classname>,
      <classname>RecentChooserDialog</classname>, and
      <classname>RecentChooserMenu</classname>.
    </para>
    <para>
      <classname>RecentChooserWidget</classname> is a simple widget for
      displaying a list of recently used files.
      <classname>RecentChooserWidget</classname> is the basic building block for
      <classname>RecentChooserDialog</classname>, but you can embed it into your
      user interface if you want to.
    </para>
    <para>
      The last class that implements the <classname>RecentChooser</classname>
      interface is <classname>RecentChooserMenu</classname>. This class allows
      you to list recently used files as a menu.
    </para>
    <sect2 id="recenchooserwidget-example">
      <title>Einfaches Beispiel für RecentChooserWidget</title>
      <para>
        Shown below is a simple example of how to use the
        <classname>RecentChooserDialog</classname> class in a program. This
        simple program has a menubar with a "Recent Files Dialog" menu item.
        When you select this menu item, a dialog pops up showing the list of
        recently used files.
      </para>
      <note>
        <para>
          If this is the first time you're using a program that uses the Recent
          Files framework, the dialog may be empty at first. Otherwise it
          should show the list of recently used documents registered by other
          applications.
        </para>
      </note>
      <para>
        After selecting the <guimenuitem>Recent Files Dialog</guimenuitem> menu
        item, you should see something similar to the following window.
      </para>
      <screenshot>
          <graphic format="PNG" fileref="figures/recentchooserdialog.png"/>
      </screenshot>
<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/recent_files?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_menu_file_recent_files_dialog();
  void on_menu_file_quit();
  void on_menu_file_new();

  //Child widgets:
  Gtk::VBox m_Box;

  Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager;
  Glib::RefPtr&lt;Gtk::ActionGroup&gt; m_refActionGroup;

  Glib::RefPtr&lt;Gtk::RecentManager&gt; m_refRecentManager;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/stock.h&gt;
#include &lt;iostream&gt;

ExampleWindow::ExampleWindow()
: m_refRecentManager(Gtk::RecentManager::get_default())
{
  set_title("recent files example");
  set_default_size(200, 200);

  //We can put a MenuBar at the top of the box and other stuff below it.
  add(m_Box);

  //Create actions for menus and toolbars:
  m_refActionGroup = Gtk::ActionGroup::create();

  //File menu:
  m_refActionGroup-&gt;add( Gtk::Action::create("FileMenu", "_File") );
  m_refActionGroup-&gt;add( Gtk::Action::create("FileNew", Gtk::Stock::NEW),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_new));

  /* A recent-files sub-menu: */
  //TODO: Shouldn't this have a default constructor?: 
  //See bug #450032.
  //m_refActionGroup-&gt;add( Gtk::RecentAction::create() );
  m_refActionGroup-&gt;add( Gtk::RecentAction::create("FileRecentFiles",
              "_Recent Files"));

  /* A menu item to open the recent-files dialog: */
  m_refActionGroup-&gt;add( Gtk::Action::create("FileRecentDialog",
              "Recent Files _Dialog"), sigc::mem_fun(*this,
                  &amp;ExampleWindow::on_menu_file_recent_files_dialog) );

  m_refActionGroup-&gt;add( Gtk::Action::create("FileQuit", Gtk::Stock::QUIT),
          sigc::mem_fun(*this, &amp;ExampleWindow::on_menu_file_quit) );


  m_refUIManager = Gtk::UIManager::create();
  m_refUIManager-&gt;insert_action_group(m_refActionGroup);

  add_accel_group(m_refUIManager-&gt;get_accel_group());

  //Layout the actions in a menubar and toolbar:
  Glib::ustring ui_info =
        "&lt;ui&gt;"
        "  &lt;menubar name='MenuBar'&gt;"
        "    &lt;menu action='FileMenu'&gt;"
        "      &lt;menuitem action='FileNew'/&gt;"
        "      &lt;menuitem action='FileRecentFiles'/&gt;"
        "      &lt;menuitem action='FileRecentDialog'/&gt;"
        "      &lt;separator/&gt;"
        "      &lt;menuitem action='FileQuit'/&gt;"
        "    &lt;/menu&gt;"
        "  &lt;/menubar&gt;"
        "  &lt;toolbar  name='ToolBar'&gt;"
        "    &lt;toolitem action='FileNew'/&gt;"
        "    &lt;toolitem action='FileQuit'/&gt;"
        "  &lt;/toolbar&gt;"
        "&lt;/ui&gt;";

  try
  {
    m_refUIManager-&gt;add_ui_from_string(ui_info);
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "building menus failed: " &lt;&lt;  ex.what();
  }

  //Get the menubar and toolbar widgets, and add them to a container widget:
  Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget("/MenuBar");
  if(pMenubar)
    m_Box.pack_start(*pMenubar, Gtk::PACK_SHRINK);

  Gtk::Widget* pToolbar = m_refUIManager-&gt;get_widget("/ToolBar") ;
  if(pToolbar)
    m_Box.pack_start(*pToolbar, Gtk::PACK_SHRINK);

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_menu_file_new()
{
    std::cout &lt;&lt; " New File" &lt;&lt; std::endl;
}

void ExampleWindow::on_menu_file_quit()
{
  hide(); //Closes the main window to stop the Gtk::Main::run().
}

void ExampleWindow::on_menu_file_recent_files_dialog()
{
  Gtk::RecentChooserDialog dialog(*this, "Recent Files", m_refRecentManager);
  dialog.add_button("Select File", Gtk::RESPONSE_OK);
  dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);

  const int response = dialog.run();
  dialog.hide();
  if(response == Gtk::RESPONSE_OK)
  {
     std::cout &lt;&lt; "URI selected = " &lt;&lt; dialog.get_current_uri() &lt;&lt; std::endl;
  }
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
      <para>
        The constructor for <classname>ExampleWindow</classname> creates the
        menu using <classname>UIManager</classname> (see <xref linkend="chapter-menus-and-toolbars"/> for more information). It then adds
        the menu and the toolbar to the window.
      </para>
    </sect2>
    <sect2 id="recent-files-filtering">
      <title>Filtern kürzlich geöffneter Dateien</title>
      <para>
        For any of the <classname>RecentChooser</classname> classes, if you
        don't wish to display all of the items in the list of recent files, you
        can filter the list to show only those that you want. You can filter
        the list with the help of the <classname>RecentFilter</classname> class.
        This class allows you to filter recent files by their name
        (<methodname>add_pattern()</methodname>), their mime type
        (<methodname>add_mime_type()</methodname>), the application that registered
        them (<methodname>add_application()</methodname>), or by a custom filter
        function (<methodname>add_custom()</methodname>). It also provides the
        ability to filter based on how long ago the file was modified and which
        groups it belongs to.
      </para>
      <para>
        After you've created and set up the filter to match only the items you
        want, you can apply a filter to a chooser widget with the
        <methodname>RecentChooser::add_filter()</methodname> function.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="chapter-plugs-sockets">
  <title>Plugs und Sockets</title>
  <sect1 id="sec-plugs-sockets-overview">
    <title>Übersicht</title>
    <para>
      From time to time, it may be useful to be able to embed a widget from
      another application within your application. <application>gtkmm</application> allows you to do
      this with the <classname>Gtk::Socket</classname> and
      <classname>Gtk::Plug</classname> classes. It is not anticipated that very
      many applications will need this functionality, but in the rare case that
      you need to display a widget that is running in a completely different
      process, these classes can be very helpful.
    </para>
    <para>
      The communication between a <classname>Socket</classname> and a
      <classname>Plug</classname> follows the XEmbed protocol. This protocol has
      also been implemented in other toolkits (e.g. Qt), which allows the same
      level of integration when embedding a Qt widget in GTK+ or vice versa.
    </para>
    <para>
      The way that <classname>Sockets</classname> and
      <classname>Plugs</classname> work together is through their window ids.
      Both a <classname>Socket</classname> and a <classname>Plug</classname>
      have IDs that can be retrieved with their <methodname>get_id()</methodname>
      member functions. The use of these IDs will be explained below in <xref linkend="sec-connecting-plugs-sockets"/>.
    </para>
    <sect2 id="sec-sockets">
      <title>Sockets</title>
      <para>
        A <classname>Socket</classname> is a special kind of container widget that
        provides the ability to embed widgets from one process into another
        process in a way that is transparent to the user.
      </para>
    </sect2>
    <sect2 id="sec-plugs">
      <title>Plugs</title>
      <para>
        A <classname>Plug</classname> is a special kind of Window that can be
        plugged into a <classname>Socket</classname>. Besides the normal
        properties and methods of <classname>Gtk::Window</classname>, a
        <classname>Plug</classname> provides a constructor that takes the ID of
        a <classname>Socket</classname>, which will automatically embed the
        <classname>Plug</classname> into the <classname>Socket</classname> that
        matches that ID.
      </para>
      <para>
        Since a <classname>Plug</classname> is just a special type of
        <classname>Gtk::Window</classname> class, you can add containers or
        widgets to it like you would to any other window.
      </para>
    </sect2>
    <sect2 id="sec-connecting-plugs-sockets">
      <title>Verbinden von Plugs und Sockets</title>
      <para>
        After a <classname>Socket</classname> or <classname>Plug</classname>
        object is realized, you can obtain its ID with its
        <methodname>get_id()</methodname> function. This ID can then be shared with
        other processes so that other processes know how to connect to
        eachother.
      </para>
      <para>
        There are two basic strategies that can be used:
        <itemizedlist>
          <listitem>
            <para>
              Create a <classname>Socket</classname> object in one process and
              pass the ID of that <classname>Socket</classname> to another
              process so that it can create a <classname>Plug</classname> object
              by specifying the given <classname>Socket</classname> ID in its
              constructor. There is no way to assign a
              <classname>Plug</classname> to a particular
              <classname>Socket</classname> after creation, so you must pass the
              <classname>Socket</classname> ID to the
              <classname>Plug</classname>'s constructor.
            </para>
          </listitem>
          <listitem>
            <para>
              Create a <classname>Plug</classname> independantly from any
              particular <classname>Socket</classname> and pass the ID of the
              <classname>Plug</classname> to other processes that need to use
              it. The ID of the <classname>Plug</classname> can be associated
              with a particular <classname>Socket</classname> object using the
              <methodname>Socket::add_id()</methodname> function. This is the
              approach used in the example below.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="sec-plugs-sockets-example">
    <title>Beispiel für Plugs und Sockets</title>
    <para>
      The following is a simple example of using sockets and plugs. The method
      of communication between processes is deliberately kept very simple: The
      <classname>Plug</classname> writes its ID out to a text file named
      <filename>plug.id</filename> and the process with the socket reads the ID
      from this files. In a real program, you may want to use a more
      sophisticated method of inter-process communication.
    </para>
<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/socket/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>socket.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;gtkmm.h&gt;
#include &lt;gtkmm/socket.h&gt;

using namespace std;

const char* id_filename = "plug.id";

void plug_added()
{
  cout &lt;&lt; "A plug was added" &lt;&lt; endl;
}

bool plug_removed()
{
  cout &lt;&lt; "A Plug was removed" &lt;&lt; endl;
  return true;
}

class MySocketWindow : public Gtk::Window
{
  public:
    MySocketWindow()
    {
      ifstream infile(id_filename);
      if (infile)
      {
        Gtk::Socket* socket = Gtk::manage(new Gtk::Socket());
        add(*socket);
        socket-&gt;signal_plug_added().connect(sigc::ptr_fun(plug_added));
        socket-&gt;signal_plug_removed().connect(sigc::ptr_fun(plug_removed));
        ::Window plug_id = 0;
        infile &gt;&gt; plug_id;
        infile.close();
        socket-&gt;add_id(plug_id);
      }
      else
      {
        Gtk::Label* label = Gtk::manage(
            new Gtk::Label(
              "Plug id file not found.\n Make sure plug is running."));
        add(*label);
        set_size_request(150, 50);
      }
      show_all();
    }
};

int main(int argc, char** argv)
{
  Gtk::Main app(argc, argv);
  MySocketWindow win;
  app.run(win);
  return 0;
}
</programlisting>
<para>File: <filename>plug.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;gtkmm.h&gt;
#include &lt;gtkmm/plug.h&gt;
#include &lt;glib/gstdio.h&gt;

using namespace std;

const char* id_filename = "plug.id";

void on_embed()
{
  cout &lt;&lt; "I've been embedded." &lt;&lt; endl;
}

class MyPlug : public Gtk::Plug
{
  public:
    MyPlug() :
      m_label("I am the plug")
  {
    set_size_request(150, 100);
    add(m_label);
    signal_embedded().connect(sigc::ptr_fun(on_embed));
    show_all();
  }

  private:
    Gtk::Label m_label;
};


int main(int argc, char** argv)
{
  Gtk::Main app(argc, argv);
  MyPlug plug;

  ofstream out(id_filename);
  out &lt;&lt; plug.get_id();
  out.close();
  cout &lt;&lt; "The window ID is: " &lt;&lt; plug.get_id() &lt;&lt; endl;

  app.run(plug);

  // remove the ID file when the program exits
  g_remove(id_filename);
  return 0;
}
</programlisting>
<!-- end inserted example code -->
    <para>
      This example creates two executable programs: <filename>socket</filename>
      and <filename>plug</filename>. The idea is that
      <filename>socket</filename> has an application window that will embed a
      widget from the <filename>plug</filename> program. The way this example
      is designed, <filename>plug</filename> must be running first before
      starting <filename>socket</filename>. To see the example in action,
      execute the following commands in order from within the example directory:
    </para>
    <para>
      Start the <filename>plug</filename> program and send it to the background
      (or just use a different terminal).
    </para>
    <screen>$ ./plug &amp;</screen>
    <para>
      After which you should see something like the following:
    </para>
    <screen>The window ID is: 69206019</screen>
    <para>Then start the <filename>socket</filename> program:</para>
    <screen>$ ./socket</screen>
    <para>
      After starting <filename>socket</filename>, you should see the following
      output in the terminal:
    </para>
    <screen>I've been embedded.
A plug was added</screen>
    <para>
      The first line of output is from <filename>plug</filename>, after it has
      been notified that it has been embedded inside of a
      <classname>Socket</classname>. The second line was emitted by
      <filename>socket</filename> in response to its
      <methodname>plug_added</methodname> signal. If everything was done as
      described above, the <filename>socket</filename> window should look
      roughly like the following:
    </para>
    <screenshot>
      <graphic format="PNG" fileref="figures/socket.png"/>
    </screenshot>
    <para>
      If for some reason the <classname>Socket</classname> couldn't attach the
      <classname>Plug</classname>, the window would look something like this:
    </para>
    <screenshot>
      <graphic format="PNG" fileref="figures/socket-fail.png"/>
    </screenshot>
  </sect1>
</chapter>

<chapter id="chapter-chapter-timeouts">
<title>Timeouts, I/O and Idle Functions </title>

<sect1 id="sec-timeouts">
<title>Timeouts</title>

<para>
You may be wondering how to make <application>gtkmm</application> do useful work while it's idling along
(well, sleeping actually) in <methodname>Gtk::Main::run()</methodname>. Happily,
you have several options. Using the following methods you can create a timeout
method that will be called every few milliseconds.
</para>

<para>
<programlisting>
sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot, unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
</programlisting>
</para>

<para>
The first argument is a <classname>slot</classname> you wish to have called
when the timeout occurs. The second argument is the number of milliseconds
between calls to that method. You receive a
<classname>sigc::connection</classname> object that can be used to deactivate
the connection using its <methodname>disconnect()</methodname> method:
</para>

<para>

<programlisting>
my_connection.disconnect();
</programlisting>
</para>

<para>
Another way of destroying the connection is your signal handler.
It has to be of the type <classname>sigc::slot&lt;bool&gt;</classname>.
As you see from the definition your signal handler has to return a value of
the type <literal>bool</literal>. A definition of a sample method might
look like this:

<programlisting>
bool MyCallback() { std::cout &lt;&lt; "Hello World!\n" &lt;&lt; std::endl; return true; }
</programlisting>

</para>

<para>
You can stop the timeout method by returning <literal>false</literal> from
your signal handler. Therefore, if you want your
method to be called repeatedly, it should return <literal>true</literal>.
</para>

<para>Hier ein Beispiel für diese Technik:</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/timeout/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>timerexample.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_TIMEREXAMPLE_H
#define GTKMM_EXAMPLE_TIMEREXAMPLE_H

#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;

class TimerExample : public Gtk::Window
{
public:
  TimerExample();

protected:
  // signal handlers
  void on_button_add_timer();
  void on_button_delete_timer();
  void on_button_quit();

  // This is the callback function the timeout will call
  bool on_timeout(int timer_number);

  // Member data:

  Gtk::HBox m_Box;
  Gtk::Button m_ButtonAddTimer, m_ButtonDeleteTimer, m_ButtonQuit;

  // Keep track of the timers being added:
  int m_timer_number;

  // These two constants are initialized in the constructor's member initializer:
  const int count_value;
  const int timeout_value;

  // STL map for storing our connections
  std::map&lt;int, sigc::connection&gt; m_timers;

  // STL map for storing our timer values.
  // Each timer counts back from COUNT_VALUE to 0 and is removed when it reaches 0
  std::map&lt;int, int&gt; m_counters;
};

#endif // GTKMM_EXAMPLE_TIMEREXAMPLE_H
</programlisting>
<para>File: <filename>timerexample.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "timerexample.h"

TimerExample::TimerExample() :
  m_Box(true, 10),
    // use Gtk::Stock wherever possible for buttons, etc.
  m_ButtonAddTimer(Gtk::Stock::ADD),
  m_ButtonDeleteTimer(Gtk::Stock::REMOVE),
  m_ButtonQuit(Gtk::Stock::QUIT),
  m_timer_number(0), // start numbering the timers at 0
  count_value(5), // each timer will count down 5 times before disconnecting
  timeout_value(1500) // 1500 ms = 1.5 seconds
{
  set_border_width(10);

  add(m_Box);
  m_Box.pack_start(m_ButtonAddTimer);
  m_Box.pack_start(m_ButtonDeleteTimer);
  m_Box.pack_start(m_ButtonQuit);

  // Connect the three buttons:
  m_ButtonQuit.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_quit));
  m_ButtonAddTimer.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_add_timer));
  m_ButtonDeleteTimer.signal_clicked().connect(sigc::mem_fun(*this,
              &amp;TimerExample::on_button_delete_timer));

  show_all_children();
}

void TimerExample::on_button_quit()
{
  hide();
}

void TimerExample::on_button_add_timer()
{
  // Creation of a new object prevents long lines and shows us a little
  // how slots work.  We have 0 parameters and bool as a return value
  // after calling sigc::bind.
  sigc::slot&lt;bool&gt; my_slot = sigc::bind(sigc::mem_fun(*this,
              &amp;TimerExample::on_timeout), m_timer_number);

  // This is where we connect the slot to the Glib::signal_timeout()
  sigc::connection conn = Glib::signal_timeout().connect(my_slot,
          timeout_value);

  // Remember the connection:
  m_timers[m_timer_number] = conn;

  // Initialize timer count:
  m_counters[m_timer_number] = count_value + 1;

  // Print some info to the console for the user:
  std::cout &lt;&lt; "added timeout " &lt;&lt; m_timer_number++ &lt;&lt; std::endl;
}

void TimerExample::on_button_delete_timer()
{
  // any timers?
  if(m_timers.empty())
  {
    // no timers left
    std::cout &lt;&lt; "Sorry, there are no timers left." &lt;&lt; std::endl;
  }
  else
  {
    // get the number of the first timer
    int timer_number = m_timers.begin()-&gt;first;

    // Give some info to the user:
    std::cout &lt;&lt; "manually disconnecting timer " &lt;&lt; timer_number
        &lt;&lt; std::endl;

    // Remove the entry in the counter values
    m_counters.erase(timer_number);

    // Diconnect the signal handler:
    m_timers[timer_number].disconnect();

    // Forget the connection:
    m_timers.erase(timer_number);
  }
}

bool TimerExample::on_timeout(int timer_number)
{
  // Print the timer:
  std::cout &lt;&lt; "This is timer " &lt;&lt; timer_number;

  // decrement and check counter value
  if (--m_counters[timer_number] == 0)
  {
    std::cout &lt;&lt; " being disconnected" &lt;&lt;  std::endl;

    // delete the counter entry in the STL MAP
    m_counters.erase(timer_number);

    // delete the connection entry in the STL MAP
    m_timers.erase(timer_number);

    // Note that we do not have to explicitly call disconnect() on the
    // connection since Gtk::Main does this for us when we return false.
    return false;
  }

  // Print the timer value
  std::cout &lt;&lt; " - " &lt;&lt; m_counters[timer_number] &lt;&lt; "/"
      &lt;&lt; count_value &lt;&lt; std::endl;

 // Keep going (do not disconnect yet):
  return true;
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "timerexample.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main app(argc, argv);

  TimerExample example;
  Gtk::Main::run(example);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

<sect1 id="sec-monitoring-io">
<title>Überwachung von Ein- und Ausgaben</title>

<para>
A nifty feature of Glib (one of the libraries underlying
<application>gtkmm</application>) is the ability to have it check for data on a file descriptor
for you. This is especially useful for networking applications. The
following method is used to do this:
</para>

<para>
<programlisting>
sigc::connection Glib::SignalInput::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,
                                    int fd, Glib::IOCondition condition,
                                    int priority = Glib::PRIORITY_DEFAULT);
</programlisting>
</para>

<para>
The first argument is a slot you wish to have called when then
the specified event (see argument 3) occurs on the file descriptor you specify
using argument two. Argument three may be one or more (using
<literal>|</literal>) of:
</para>

<itemizedlist>
<listitem>

<para>
Glib::IO_IN - Call your method when there is data ready for
reading on your file descriptor.

</para>
</listitem>
<listitem>

<para>
Glib::IO_OUT - Call your method when the file descriptor is
ready for writing.

</para>
</listitem>
<listitem>

<para>
Glib::IO_PRI - Call your method when the file descriptor has urgent data to be read.

</para>
</listitem>
<listitem>

<para>
Glib::IO_ERR - Call your method when an error has occurred on the file descriptor.

</para>
</listitem>
<listitem>

<para>
Glib::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets).
</para>
</listitem>

</itemizedlist>

<para>
    The return value is a <classname>sigc::connection</classname> that may be used to stop monitoring
this file descriptor using its <methodname>disconnect()</methodname> method. The
<parameter>slot</parameter> signal handler should be declared as follows:
</para>

<para>
<programlisting>
bool input_callback(Glib::IOCondition condition);
</programlisting>
</para>

<para>
where <parameter>condition</parameter> is as
specified above. As usual the slot is created with
<function>sigc::mem_fun()</function> (for a member method of an object.), or
<function>sigc::ptr_fun()</function> (for a function).
</para>

<para>
A little example follows. To use the example just execute it from a terminal;
it doesn't create a window. It will create a pipe named
<literal>testfifo</literal> in the current directory. Then start another shell
and execute <literal>echo "Hello" &gt; testfifo</literal>. The example will
print each line you enter until you execute <literal>echo "Q" &gt;
testfifo</literal>.
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/input/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;build/config.h&gt;
#include &lt;gtkmm/main.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;iostream&gt;

#include &lt;unistd.h&gt; //The SUN Forte compiler puts F_OK here.

//The SUN Forte compiler needs these for mkfifo:
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int read_fd;
Glib::RefPtr&lt;Glib::IOChannel&gt; iochannel;

/*
  send to the fifo with:
  echo "Hello" &gt; testfifo

  quit the program with:
  echo "Q" &gt; testfifo
*/

// this will be our signal handler for read operations
// it will print out the message sent to the fifo
// and quit the program if the message was 'Q'.
bool MyCallback(Glib::IOCondition io_condition)
{

  if ((io_condition &amp; Glib::IO_IN) == 0) {
    std::cerr &lt;&lt; "Invalid fifo response" &lt;&lt; std::endl;
  }
  else {
   Glib::ustring buf;

   iochannel-&gt;read_line(buf);
   std::cout &lt;&lt; buf;
   if (buf == "Q\n")
       Gtk::Main::quit ();

  }
  return true;
}


int main(int argc, char *argv[])
{
  // the usual Gtk::Main object
  Gtk::Main app(argc, argv);

  if (access("testfifo", F_OK) == -1) {
    // fifo doesn't exit - create it
    #ifdef HAVE_MKFIFO
    if (mkfifo("testfifo", 0666) != 0) {
      std::cerr &lt;&lt; "error creating fifo" &lt;&lt; std::endl;
      return -1;
    }
    #else
      std::cerr &lt;&lt; "error creating fifo: This platform does not have mkfifo()"
          &lt;&lt; std::endl;
    #endif //HAVE_MKFIFO
  }

  read_fd = open("testfifo", O_RDONLY);
  if (read_fd == -1)
  {
    std::cerr &lt;&lt; "error opening fifo" &lt;&lt; std::endl;
    return -1;
  }

  // connect the signal handler
  Glib::signal_io().connect(sigc::ptr_fun(MyCallback), read_fd, Glib::IO_IN);

  // Creates a iochannel from the file descriptor
  iochannel = Glib::IOChannel::create_from_fd(read_fd);

  // and last but not least - run the application main loop
  app.run();

  // now remove the temporary fifo
  if(unlink("testfifo"))
    std::cerr &lt;&lt; "error removing fifo" &lt;&lt; std::endl;

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

<sect1 id="sec-idle-functions">
<title>Untätigkeitsfunktionen</title>

<para>
If you want to specify a method that gets called when nothing else is happening, use the following:
</para>

<para>
<programlisting>
sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot, int priority = Glib::PRIORITY_DEFAULT_IDLE);
</programlisting>
</para>

<para>
This causes <application>gtkmm</application> to call the specified method whenever nothing else is
happening. You can add a priority (lower numbers are higher priorities). There are two ways to remove the signal handler: calling
<methodname>disconnect()</methodname> on the
<classname>sigc::connection</classname> object, or returning
<literal>false</literal> in the signal handler, which should be declared
as follows:
</para>

<para>
<programlisting>
bool idleFunc();
</programlisting>
</para>

<para>
Since this is very similar to the methods above this explanation should
be sufficient to understand what's going on. However, here's a little example:
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/idle/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>idleexample.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_IDLEEXAMPLE_H
#define GTKMM_EXAMPLE_IDLEEXAMPLE_H

#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;

class IdleExample : public Gtk::Window
{
public:
  IdleExample();

protected:
  // Signal Handlers:
  bool on_timer();
  bool on_idle();
  void on_button_clicked();

  // Member data:
  Gtk::VBox m_Box;
  Gtk::Button m_ButtonQuit;
  Gtk::ProgressBar m_ProgressBar_c;
  Gtk::ProgressBar m_ProgressBar_d;
};

#endif // GTKMM_EXAMPLE_IDLEEXAMPLE_H
</programlisting>
<para>File: <filename>idleexample.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "idleexample.h"

IdleExample::IdleExample() :
  m_Box(false, 5),
  m_ButtonQuit(Gtk::Stock::QUIT)
{
  set_border_width(5);

  // Put buttons into container

  // Adding a few widgets:
  add(m_Box);
  m_Box.pack_start( *Gtk::manage(new Gtk::Label("Formatting Windows drive C:")));
  m_Box.pack_start( *Gtk::manage(new Gtk::Label("100 MB")) );
  m_Box.pack_start(m_ProgressBar_c);

  m_Box.pack_start( *Gtk::manage(new Gtk::Label("")) );

  m_Box.pack_start( *Gtk::manage(new Gtk::Label("Formatting Windows drive D:")));
  m_Box.pack_start( *Gtk::manage(new Gtk::Label("5000 MB")) );
  m_Box.pack_start(m_ProgressBar_d);

  Gtk::HBox* hbox = Gtk::manage( new Gtk::HBox(false,10));
  m_Box.pack_start(*hbox);
  hbox-&gt;pack_start(m_ButtonQuit, Gtk::PACK_EXPAND_PADDING);

  // Connect the signal handlers:
  m_ButtonQuit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;IdleExample::on_button_clicked) );

  // formatting drive c in timeout signal handler - called once every 50ms
  Glib::signal_timeout().connect( sigc::mem_fun(*this, &amp;IdleExample::on_timer),
          50 );

  // formatting drive d in idle signal handler - called as quickly as possible
  Glib::signal_idle().connect( sigc::mem_fun(*this, &amp;IdleExample::on_idle) );

  show_all_children();
}


void IdleExample::on_button_clicked()
{
  hide();
}

// this timer callback function is executed once every 50ms (set in connection
// above).  Use timeouts when speed is not critical. (ie periodically updating
// something).
bool IdleExample::on_timer()
{
  double value = m_ProgressBar_c.get_fraction();

  // Update progressbar 1/500th each time:
  m_ProgressBar_c.set_fraction(value + 0.002);
 
  return value &lt; 0.99;  // return false when done
}


// This idle callback function is executed as often as possible, hence it is
// ideal for processing intensive tasks.
bool IdleExample::on_idle()
{
  double value = m_ProgressBar_d.get_fraction();

  // Update progressbar 1/5000th each time:
  m_ProgressBar_d.set_fraction(value + 0.0002);

  return value &lt; 0.99;  // return false when done
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "idleexample.h"
#include &lt;gtkmm/main.h&gt;

int main (int argc, char *argv[])
{
  Gtk::Main app(argc, argv);

  IdleExample example;
  Gtk::Main::run(example);

  return 0;
}
</programlisting>
<!-- end inserted example code -->

<para>
This example points out the difference of idle and timeout methods a
little. If you need methods that are called periodically, and speed
is not very important, then you want timeout methods. If
you want methods that are called as often as possible (like
calculating a fractal in background), then use idle methods.
</para>

<para>
Try executing the example and increasing the system load. The upper
progress bar will increase steadily; the lower one will slow down.
</para>

</sect1>

</chapter>

<chapter id="chapter-memory">
<title>Speicherverwaltung</title>

<sect1 id="sec-memory-widgets">
<title>Widgets</title>

<sect2 id="memory-normal">
<title>Normale C++-Speicherverwaltung</title>

<para>
<application>gtkmm</application> allows the programmer to control the lifetime (that is, the construction
and destruction) of any widget in the same manner as any other C++ object.
This flexibility allows you to use <literal>new</literal> and
<literal>delete</literal> to create and destroy objects dynamically
or to use regular class members (that are destroyed automatically when the
class is destroyed) or to use local instances (that are destroyed when the
instance goes out of scope). This flexibility is not present in some C++ GUI
toolkits, which restrict the programmer to only a subset of C++'s memory
management features.
</para>

<para>Here are some examples of normal C++ memory management:</para>

<sect3 id="memory-class-scope">
<title>Class Scope widgets</title>

<para>
If a programmer does not need dynamic memory allocation, automatic widgets in class
scope may be used. One advantage of automatic widgets in class scope is that
memory management is grouped in one place. The programmer does not
risk memory leaks from failing to <literal>delete</literal> a widget.
</para>

<para>
The primary disadvantages of using class scope widgets are revealing
the class implementation rather than the class interface in the class header. Class
scope widgets also require Automatic widgets in class scope suffer the same disadvantages as
any other class scope automatic variable.
</para>

<para>
<programlisting>
#include &lt;gtkmm/button.h&gt;
class Foo
{
private:
  Gtk::Button theButton;
  // will be destroyed when the Foo object is destroyed
};
</programlisting>
</para>
</sect3>

<sect3 id="memory-function-scope">
<title>Function scope widgets</title>

<para>
If a programmer does not need a class scope widget, a function scope widget
may also be used. The advantages to function scope over class scope are the
increased data hiding and reduced dependencies.


<programlisting>
{
  Gtk::Button aButton;
  aButton.show();
  ...
  kit.run();
}
</programlisting>
</para>
</sect3>

<sect3 id="memory-dynamic-allocation">
<title>Dynamische Zuweisung mit new und delete</title>

<para>
Although, in most cases, the programmer will prefer to allow containers to
automatically destroy their children using <function>manage()</function> (see
below), the programmer is not required to use <function>manage()</function>.
The traditional <literal>new</literal> and <literal>delete</literal> operators
may also be used.
</para>

<para>

<programlisting>
Gtk::Button* pButton = new Gtk::Button("Test");

// do something useful with pButton

delete pButton;
</programlisting>

Here, the programmer deletes pButton to prevent a memory leak.
</para>
</sect3>

</sect2>

<sect2 id="memory-managed-widgets">
<title>Verwaltete Widgets</title>

<para>
Alternatively, you can let a widget's container control when the widget is
destroyed. In most cases, you want a widget to last only as long as the
container it is in. To delegate the management of a widget's lifetime to its
container, first create it with <function>manage()</function> and
pack it into its container with <methodname>add()</methodname>. Now, the
widget will be destroyed whenever its container is destroyed.
</para>

<sect3 id="memory-managed-dynamic">
<title>Dynamische Zuweisung mit manage() und add()</title>

<para>
<application>gtkmm</application> provides the <function>manage()</function> function and
<methodname>add()</methodname> methods to create and destroy widgets. Every widget
except a top-level window must be added or packed into a container in order to
be displayed. The <function>manage()</function> function marks a packed widget
so that when the widget is added to a container, the container becomes
responsible for deleting the widget.
</para>

<para>
<programlisting>
MyWidget::MyWidget()
{
  Gtk::Button* pButton = manage(new Gtk::Button("Test"));
  add(*pButton); //add aButton to MyWidget
}
</programlisting>

Now, when objects of type <classname>MyWidget</classname> are destroyed, the
button will also be deleted. It is no longer necessary to delete pButton to
free the button's memory; its deletion has been delegated to the
<classname>MyWidget</classname> object.
</para>

<para>
<application>gtkmm</application> also provides the <methodname>set_manage()</methodname> method for
all widgets. This can be used to generate the same result as
<function>manage()</function>, but is more tedious:
</para>

<para>foo.add( (w=new Gtk::Label("Hello"), w-&gt;set_manage(), &amp;w) );</para>

<para>ist das gleiche wie</para>

<para>foo.add( manage(new Gtk::Label("Hello")) );</para>

<para>
Of course, a top level container will not be added to another container. The
programmer is responsible for destroying the top level container using one of
the traditional C++ techniques. For instance, your top-level Window might just
be an instance in your <function>main()</function> function..
</para>

</sect3>
</sect2>
</sect1>

<sect1 id="sec-memory-shared-resources">
<title>Gemeinsame Ressourcen</title>

<para>
Some objects, such as <classname>Gdk::Pixmap</classname>s and
<classname>Pango::Font</classname>s, are obtained from a shared store.
Therefore you cannot instantiate your own instances. These classes typically
inherit from <classname>Glib::Object</classname>. Rather than requiring you to
reference and unreference these objects, <application>gtkmm</application> uses the
<classname>RefPtr&lt;&gt;</classname> smartpointer.
</para>

<para>
Objects such as <classname>Gdk::Bitmap</classname> can only be instantiated
with a <methodname>create()</methodname> function. For instance,
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap = Gdk::Bitmap::create(window, data, width, height);
</programlisting>
</para>

<para>
You have no way of getting a bare <classname>Gdk::Bitmap</classname>. In the
example, <varname>bitmap</varname> is a smart pointer, so you can do this, much
like a normal pointer:
<programlisting>
if(bitmap)
{
  int depth = bitmap-&gt;get_depth().
}
</programlisting>
</para>

<para>
When <varname>bitmap</varname> goes out of scope an
<methodname>unref()</methodname> will happen in the background and you don't need
to worry about it anymore. There's no <literal>new</literal> so there's no
<literal>delete</literal>.
</para>
<para>
If you copy a <classname>RefPtr</classname>, for instance
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap2 = bitmap.
</programlisting>
, or if you pass it as a method argument or a return type, then
<classname>RefPtr</classname> will do any necessary referencing to ensure that
the instance will not be destroyed until the last <classname>RefPtr</classname>
has gone out of scope.
</para>
<para>See the <link linkend="chapter-refptr">appendix</link> for detailed information about RefPtr.</para>
<para>
If you wish to learn more about smartpointers, you might look in these
books:
<itemizedlist>
<listitem><para>Bjarne Stroustrup, »The C++ Programming Language« - Abschnitt 14.4.2</para></listitem>
<listitem><para>Nicolai M. Josuttis, »The C++ Standard Library« - Abschnitt 4.2</para></listitem>
</itemizedlist>
</para>

</sect1>

</chapter>

<chapter id="chapter-builder">
<title>Glade und Gtk::Builder</title>
<para>
Although you can use C++ code to instantiate and arrange widgets, this
can soon become tedious and repetitive. And it requires a recompilation to show
changes. The <application>Glade</application> application allows you to layout
widgets on screen and then save an XML description of the arrangement. Your
application can then use the <application>Gtk::Builder</application> API to load
that XML file at runtime and obtain a pointer to specifically named widget
instances.
</para>

<para>Dies hat folgende Vorteile: <orderedlist>
<listitem><simpara>Es wird weniger C++-Code benötigt.</simpara></listitem>
<listitem><simpara>UI changes can be seen more quickly, so UIs are able to improve.</simpara></listitem>
<listitem><simpara>Designer ohne Programmierkenntnisse können grafische Benutzeroberflächen entwerfen und bearbeiten.</simpara></listitem>
</orderedlist></para>

<para>
You still need C++ code to deal with User Interface changes triggered by user
actions, but using <application>Gtk::Builder</application> for the widget
layout allows you to focus on implementing that functionality.
</para>

<sect1 id="sec-builder-loading-glade-file">
<title>Laden der .glade-Datei</title>
<para>
<classname>Gtk::Builder</classname> must be used via a
<classname>Glib::RefPtr</classname>. Like all such classes, you need to use a
<methodname>create()</methodname> method to instantiate it. For instance,
<programlisting>
Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file("basic.glade");
</programlisting>
This will instantiate the windows defined in the .glade file, though they will
not be shown immediately unless you have specified that via the <guilabel>Properties</guilabel>
window in <application>Glade</application>.
</para>

<para>To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance,
<programlisting>
Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file("basic.glade", "treeview_products");
</programlisting>
</para>

</sect1>

<sect1 id="sec-builder-accessing-widgets">
<title>Zugriff auf Widgets</title>

<para>
To access a widget, for instance to <methodname>show()</methodname> a dialog, use
the <methodname>get_widget()</methodname> method, providing the widget's name. This
name should be specified in the <application>Glade</application> Properties
window. If the widget could not be found, or is of the wrong type, then the
pointer will be set to 0.
<programlisting>
Gtk::Dialog* pDialog = 0;
builder-&gt;get_widget("DialogBasic", pDialog);
</programlisting>
</para>

<para>
<application>Gtk::Builder</application> checks for a null pointer, and checks
that the widget is of the expected type, and will show warnings on the command
line about these.
</para>

<para>
Remember that you are not instantiating a widget with
<methodname>get_widget()</methodname>, you are just obtaining a pointer to one that
already exists. You will always receive a pointer to the same instance when you
call <methodname>get_widget()</methodname> on the same
<classname>Gtk::Builder</classname>, with the same widget name. The
widgets are instantiated during <methodname>Gtk::Builder::create_from_file()</methodname>.
</para>

<para>
<methodname>get_widget()</methodname> returns child widgets that are
<function>manage()</function>ed (see the <link linkend="chapter-memory">Memory
Management</link> chapter), so they will be deleted when their parent
container is deleted. So, if you get only a child widget from
<application>Gtk::Builder</application>, instead of a whole window, then you must
either put it in a <classname>Container</classname> or delete it.
<classname>Windows</classname> (such as <classname>Dialogs</classname>) cannot
be managed because they have no parent container, so you must delete them at
some point.
</para>

<sect2 id="builder-example-loading">
<title>Beispiel</title>
<para>
This simple example shows how to load a <application>Glade</application> file at runtime and access the widgets with
<application>Gtk::Builder</application>.
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/builder/basic?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;gtkmm.h&gt;
#include &lt;iostream&gt;

Gtk::Dialog* pDialog = 0;

static
void on_button_clicked()
{
  if(pDialog)
    pDialog-&gt;hide(); //hide() will cause main::run() to end.
}

int main (int argc, char **argv)
{
  Gtk::Main kit(argc, argv);

  //Load the GtkBuilder file and instantiate its widgets:
  Glib::RefPtr&lt;Gtk::Builder&gt; refBuilder = Gtk::Builder::create();
  try
  {
    refBuilder-&gt;add_from_file("basic.ui");
  }
  catch(const Glib::FileError&amp; ex)
  {
    std::cerr &lt;&lt; "FileError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return 1;
  }
  catch(const Gtk::BuilderError&amp; ex)
  {
    std::cerr &lt;&lt; "BuilderError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return 1;
  }

  //Get the GtkBuilder-instantiated Dialog:
  refBuilder-&gt;get_widget("DialogBasic", pDialog);
  if(pDialog)
  {
    //Get the GtkBuilder-instantiated Button, and connect a signal handler:
    Gtk::Button* pButton = 0;
    refBuilder-&gt;get_widget("quit_button", pButton);
    if(pButton)
    {
      pButton-&gt;signal_clicked().connect( sigc::ptr_fun(on_button_clicked) );
    }

    kit.run(*pDialog);
  }

  return 0;
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>


<sect1 id="sec-builder-using-derived-widgets">
<title>Verwenden abgeleiteter Widgets</title>
<para>
You can use <application>Glade</application> to layout your own custom widgets
derived from <application>gtkmm</application> widget classes. This keeps your code organized and
encapsulated. Of course you won't see the exact appearance and properties of
your derived widget in <application>Glade</application>, but you can specify
its location and child widgets and the properties of its <application>gtkmm</application> base class.
</para>

<para>Verwenden Sie <methodname>Gtk::Builder::get_widget_derived()</methodname> folgendermaßen: <programlisting>
DerivedDialog* pDialog = 0;
builder-&gt;get_widget_derived("DialogBasic", pDialog);
</programlisting></para>

<para>
Your derived class must have a constructor that takes a pointer to the
underlying C type, and the <classname>Gtk::Builder</classname> instance.
All relevant classes of <application>gtkmm</application> typedef their underlying C type as
<classname>BaseObjectType</classname> (<classname>Gtk::Dialog</classname>
typedefs <classname>BaseObjectType</classname> as <type>GtkDialog</type>, for instance).
</para>
<para>
You must call the base class's constructor in the initialization list, providing the C pointer. For
instance,
<programlisting>
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Dialog(cobject)
{
}
</programlisting>
</para>

<para>
You could then encapsulate the manipulation of the child widgets in the
constructor of the derived class, maybe using <methodname>get_widget()</methodname>
or <methodname>get_widget_derived()</methodname> again. For instance,
<programlisting>
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Dialog(cobject),
  m_builder(builder),
  m_pButton(0)
{
  //Get the Glade-instantiated Button, and connect a signal handler:
  m_builder-&gt;get_widget("quit_button", m_pButton);
  if(m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );
  }
}
</programlisting>
</para>

<sect2 id="builder-example-accessing">
<title>Beispiel</title>
<para>
This example shows how to load a <application>Glade</application> file at runtime and access the widgets via a derived class.
</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/builder/derived?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>deriveddialog.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_DERIVED_DIALOG_H
#define GTKMM_EXAMPLE_DERIVED_DIALOG_H

#include &lt;gtkmm.h&gt;


class DerivedDialog : public Gtk::Dialog
{
public:
  DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade);
  virtual ~DerivedDialog();

protected:
  //Signal handlers:
  void on_button_quit();

  Glib::RefPtr&lt;Gtk::Builder&gt; m_refGlade;
  Gtk::Button* m_pButton;
};

#endif //GTKMM_EXAMPLE_DERIVED_WINDOW_H
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "deriveddialog.h"
#include &lt;iostream&gt;

int main (int argc, char **argv)
{
  Gtk::Main kit(argc, argv);

  //Load the Glade file and instiate its widgets:
  Glib::RefPtr&lt;Gtk::Builder&gt; refBuilder = Gtk::Builder::create();
  try
  {
    refBuilder-&gt;add_from_file("basic.ui");
  }
  catch(const Glib::FileError&amp; ex)
  {
    std::cerr &lt;&lt; "FileError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return 1;
  }
  catch(const Gtk::BuilderError&amp; ex)
  {
    std::cerr &lt;&lt; "BuilderError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    return 1;
  }

  //Get the GtkBuilder-instantiated dialog::
  DerivedDialog* pDialog = 0;
  refBuilder-&gt;get_widget_derived("DialogBasic", pDialog);
  if(pDialog)
  {
    //Start:
    kit.run(*pDialog);
  }

  delete pDialog;
    

  return 0;
}
</programlisting>
<para>File: <filename>deriveddialog.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "deriveddialog.h"

DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; refGlade)
: Gtk::Dialog(cobject),
  m_refGlade(refGlade),
  m_pButton(0)
{
  //Get the Glade-instantiated Button, and connect a signal handler:
  m_refGlade-&gt;get_widget("quit_button", m_pButton);
  if(m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) ); 
  }
}

DerivedDialog::~DerivedDialog()
{
}

void DerivedDialog::on_button_quit()
{
  hide(); //hide() will cause main::run() to end.
}
</programlisting>
<!-- end inserted example code -->

</sect2>

</sect1>

</chapter>

<chapter id="chapter-internationalization">
  <title>Internationalisierung und Lokalisierung</title>

  <para>
    <application>gtkmm</application> applications can easily support multiple languages, including
    non-European languages such as Chinese and right-to-left languages such as
    Arabic. An appropriately-written and translated <application>gtkmm</application> application will use
    the appropriate language at runtime based on the user's environment.
  </para>
  <para>
    You might not anticipate the need to support additional languages, but
    you can never rule it out. And it's easier to develop the application
    properly in the first place rather than retrofitting later.
  </para>

  <para>
    The process of writing source code that allows for translation is called
    <literal>internationalization</literal>, often abbreviated to
    <literal>i18n</literal>. The <literal>Localization</literal> process,
    sometimes abbreviated as <literal>l10n</literal>, provides translated text
    for other languages, based on that source code.
  </para>

  <para>
    The main activity in the internationalization process is finding strings
    seen by users and marking them for translation. You do not need to do it all
    at once - if you set up the necessary project infrastructure correctly then
    your application will work normally regardless of how many strings you've
    covered.
  </para>

  <para>
    String literals should be typed in the source code in English, but
    surrounded by a macro. The <application>gettext</application> (or intltool)
    utility can then extract the marked strings for tramslation, and substitute
    the translated text at runtime.
  </para>

  <sect1 id="sec-internationalization-intro">
    <title>Einrichten Ihres Projekts</title>

    <note>
      <para>
        In the instructions below we will assume that you will not be using
        <application>gettext</application> directly, but
        <application>intltool</application>, which was written specifically for
        <literal>GNOME</literal>. <application>intltool</application> uses
        <function>gettext()</function>, which extracts strings from source code,
        but <application>intltool</application> can also combine strings from
        other files, for example from desktop menu details, and GUI resource
        files such as <application>Glade</application> files, into standard
        <application>gettext</application> <filename>.pot/.po</filename> files.
      </para>
      <para>
        We also assume that you are using autotools (e.g.
        <application>automake</application> and
        <application>autoconf</application>) to build your project, and
        that you are using <ulink url="http://svn.gnome.org/viewcvs/gnome-common/trunk/autogen.sh?view=markup">
          <literal>./autogen.sh</literal> from
          <application>gnome-common</application></ulink>, which, among other
        things, takes care of some <application>intltool</application>
        initialization.
      </para>
    </note>

    <para>
      Create a sub-directory named <literal>po</literal> in your project's root
      directory. This directory will eventually contain all of your
      translations. Within it, create a file named <literal>LINGUAS</literal>
      and a file named <literal>POTFILES.in</literal>. It is common practice to
      also create a <literal>ChangeLog</literal> file in the
      <literal>po</literal> directory so that translators can keep track of
      translation changes.
    </para>

    <para>
      <literal>LINGUAS</literal> contains an alphabetically sorted list of codes
      identifying the languages for which your program is translated (comment
      lines starting with a <literal>#</literal> are ignored). Each language
      code listed in the <literal>LINGUAS</literal> file must have a
      corresponding <literal>.po</literal> file. So, if your program has German
      and Japanese translations, your <literal>LINGUAS</literal> file would
      look like this:
    </para>
    <programlisting># keep this file sorted alphabetically, one language code per line
de
ja</programlisting>
    <para>
      (In addition, you'd have the files <literal>ja.po</literal> and
      <literal>de.po</literal> in your
      <literal>po</literal> directory which contain the German and Japanese
      translations, respectively.)
    </para>

    <para>
      <literal>POTFILES.in</literal> is a list of paths to all files which
      contain strings marked up for translation, starting from the project root
      directory. So for example, if your project sources were located in a
      subdirectory named <literal>src</literal>, and you had two files that
      contained strings that should be translated, your
      <literal>POTFILES.in</literal> file might look like this:
    </para>

    <programlisting>src/main.cc
src/other.cc</programlisting>

    <para>
      If you are using <application>gettext</application> directly, you can only
      mark strings for translation if they are in source code file. However, if
      you use <application>intltool</application>, you can mark strings for
      translation in a variety of other file formats, including
      <application>Glade</application> UI files, xml, <ulink url="http://standards.freedesktop.org/desktop-entry-spec/latest/">.desktop
        files</ulink> and several more. So, if you have designed some of the
      application UI in <application>Glade</application> then also add your
      <filename>.glade</filename> files to the list in
      <literal>POTFILES.in</literal>.
    </para>

    <para>
      Now that there is a place to put your translations, you need to initialize
      <application>intltool</application> and <application>gettext</application>.
      Add the following code to your <literal>configure.ac</literal>,
      substituting 'programname' with the name of your program:
    </para>

    <programlisting>IT_PROG_INTLTOOL([0.35.0])

GETTEXT_PACKAGE=programname
AC_SUBST(GETTEXT_PACKAGE)
AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], ["$GETTEXT_PACKAGE"],
                   [The domain to use with gettext])
AM_GLIB_GNU_GETTEXT

PROGRAMNAME_LOCALEDIR=[${datadir}/locale]
AC_SUBST(PROGRAMNAME_LOCALEDIR)</programlisting>

    <para>
      This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later
      in the <literal>Makefile.am</literal> file, to define a macro that will be
      used when you initialize <application>gettext</application> in your source
      code.
    </para>

    <para>
      In the top-level Makefile.am:
      <itemizedlist>
        <listitem>
          <para>Add <literal>po</literal> to the <literal>SUBDIRS</literal>
            variable. Without this, your translations won't get built and
            installed when you build the program</para>
        </listitem>
        <listitem>
          <para>
            Define <literal>INTLTOOL_FILES</literal> as:
            <programlisting>INTLTOOL_FILES = intltool-extract.in \
                 intltool-merge.in \
                 intltool-update.in</programlisting>
          </para>
        </listitem>
        <listitem>
          <para>
            Add <literal>INTLTOOL_FILES</literal> to the
            <literal>EXTRA_DIST</literal> list of files. This ensures that when
            you do a <command>make dist</command>, these commands will be
            included in the source tarball.
          </para>
        </listitem>
        <listitem>
          <para>
            Update your <literal>DISTCLEANFILES</literal>:
            <programlisting>DISTCLEANFILES = ... intltool-extract \
                 intltool-merge \
                 intltool-update \
                 po/.intltool-merge-cache</programlisting>
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      In your <literal>src/Makefile.am</literal>, update your
      <literal>AM_CPPFLAGS</literal> to add the following preprocessor macro
      definition:
    </para>
    <programlisting>AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\"${PROGRAMNAME_LOCALEDIR}\"</programlisting>
    <para>
      This macro will be used when you initialize <literal>gettext</literal> in
      your source code.
    </para>
  </sect1>

<sect1 id="sec-i18n-marking-strings">
  <title>Markieren von Zeichenketten für die Übersetzung</title>

  <para>
    String literals should be typed in the source code in English, but
    they should be surrounded by a call to the <function>gettext()</function>
    function. These strings will be extracted for translation and the
    translations may be used at runtime instead of the original English
    strings.
  </para>

  <para>
    The <application>GNU gettext</application> package allows you to mark
    strings in source code, extract those strings for translation, and use
    the translated strings in your application.
  </para>

  <para>
    However, <application>Glib</application> defines
    <function>gettext()</function>
    support macros which are shorter wrappers in an easy-to-use form.
    To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>,
    and then, for example, substitute:
    <programlisting>display_message("Getting ready for i18n.");</programlisting>
    with:
    <programlisting>display_message(_("Getting ready for i18n."));</programlisting>
  </para>

  <para>
    For reference, it is possible to generate a file which contains all
    strings which appear in your code, even if they are not marked for translation,
    together with file name and line
    number references. To generate such a file named
    <literal>my-strings</literal>, execute the following command,
    within the source code directory:

    <programlisting>xgettext -a -o my-strings --omit-header *.cc *.h</programlisting>
  </para>

  <para>
    Finally, to let you program use the translation for the current locale,
    add this code to the beginning of your <filename>main.cc</filename> file, to initialize gettext.

<programlisting>bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);
bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
textdomain(GETTEXT_PACKAGE);</programlisting>
  </para>

  <sect2 id="sec-i18n-gettext">
    <title>Funktionsweise von Gettext</title>

    <para>
      <application>intltool</application> /
      <application>xgettext</application> script extracts the strings
      and puts them in a <filename>mypackage.pot</filename> file.
      The translators of your application create their translations by
      first copying this <filename>.pot</filename> file to a
      <filename>localename.po</filename> file. A locale identifies a
      language and an encoding for that language, including date and numerical
      formats. Later, when the text in your source code has changed, the
      <literal>msmerge</literal> script is used to update the
      <filename>localename.po</filename> files from the regenerated
      <filename>.pot</filename> file.
    </para>

    <para>
      At install time, the <filename>.po</filename> files are converted to
      a binary format (with the extension <filename>.mo</filename>) and
      placed in a system-wide directory for locale files, for example
      <filename>/usr/share/locale/</filename>.
    </para>

    <para>
      When the application runs, the <application>gettext</application>
      library checks the system-wide directory to see if there is a
      <filename>.mo</filename> file for the user's locale environment
      (you can set the locale with, for instance, "export LANG=de_DE.UTF-8"
      from a bash console). Later, when the program reaches a
      <literal>gettext</literal> call, it looks for a translation of a
      particular string. If none is found, the original string is used.
    </para>
  </sect2>

  <sect2 id="sec-i18n-testing">
    <title>Testen und Hinzufügen von Übersetzungen</title>

    <para>
      To convince yourself that you've done well, you may wish to add a
      translation for a new locale. In order to do that, go to the
      <filename>po</filename> subdirectory of your project and
      execute the following command:
      <programlisting>intltool-update --pot</programlisting>
    </para>

    <para>
      That will create a file named <filename>programname.pot</filename>.
      Now copy that file to <filename>languagecode.po</filename>, such as
      <filename>de.po</filename> or <filename>hu.po</filename>. Also add
      that language code to <literal>LINGUAS</literal>. The
      <filename>.po</filename> file contains a header and a list of English strings,
      with space for the translated strings to be entered. Make sure you set the
      encoding of the <filename>.po</filename> file (specified in the header, but
      also as content) to <literal>UTF-8</literal>.
    </para>

    <!-- TODO: This need more explanation. What's the point of the fuzzy tag then? murrayc -->
    <note>
      <para>
      It's possible that certain strings will be marked as
      <literal>fuzzy</literal> in the <filename>.po</filename> file.
      These translations will not substitute the original string. To make
      them appear, simply remove the <literal>fuzzy</literal> tag.
      </para>
    </note>
  </sect2>

  <sect2 id="sec-i18n-resources">
    <title>Ressourcen</title>

    <para>
      More information about what lies behind the internationalization and localization process
      is presented and demonstrated in:

      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://www.gnome.org/~malcolm/i18n/index.html">Internationalisierung von GNOME-Anwendungen</ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            <ulink url="http://svn.gnome.org/viewcvs/intltool/trunk/README?view=markup">Intltool-README</ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            <ulink url="http://developer.gnome.org/doc/tutorials/gnome-i18n/translator.html">Nutzung des GNOME-CVS als Übersetzer</ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            <ulink url="http://www.gnu.org/software/gettext/manual/gettext.html">Gettext-Handbuch</ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            <ulink url="http://ftp.gnome.org/pub/GNOME/sources/gtkmm_hello/"><literal>gtkmm_hello</literal>-Beispielpaket</ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            <ulink url="http://ftp.gnome.org/pub/GNOME/sources/gnomemm_hello/"><literal>gnomemm_hello</literal>-Beispielpaket</ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect2>

</sect1>

<sect1 id="sec-i18n-expecting-utf8">
<title>Expecting UTF8</title>
<para>
A properly internationalized application will not make assumptions about the
number of bytes in a character. That means that you shouldn't use pointer
arithmetic to step through the characters in a string, and it means you
shouldn't use <classname>std::string</classname> or standard C functions such
as <function>strlen()</function> because they make the same assumption.
</para>
<para>
However, you probably already avoid bare char* arrays and pointer arithmetic by
using <classname>std::string</classname>, so you just need to start using
<classname>Glib::ustring</classname> instead. See the <link linkend="sec-basics-ustring">Basics</link> chapter about
<classname>Glib::ustring</classname>.
</para>

<sect2 id="i18n-ustring-iostreams"><title>Glib::ustring und std::iostreams</title>
<!-- <para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para> -->
<para>
Unfortunately, the integration with the standard iostreams is not completely
foolproof. <application>gtkmm</application> converts <classname>Glib::ustring</classname>s to a
locale-specific encoding (which usually is not UTF-8) if you output them to an
<classname>ostream</classname> with <function>operator&lt;&lt;</function>.
Likewise, retrieving <classname>Glib::ustrings</classname> from
<classname>istream</classname> with <function>operator&gt;&gt;</function>
causes a conversion in the opposite direction. But this scheme breaks down if
you go through a <classname>std::string</classname>, e.g. by inputting text
from a stream to a <classname>std::string</classname> and then implicitly
converting it to a <classname>Glib::ustring</classname>. If the string
contained non-ASCII characters and the current locale is not UTF-8 encoded, the
result is a corrupted <classname>Glib::ustring</classname>. You can work around
this with a manual conversion. For instance, to retrieve the
<classname>std::string</classname> from a <classname>ostringstream</classname>:
<programlisting>std::ostringstream output;
output.imbue(std::locale("")); // use the user's locale for this stream
output &lt;&lt; percentage &lt;&lt; " % done";
label-&gt;set_text(Glib::locale_to_utf8(output.str()));</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-i18n-pitfalls">
      <title>Fallstricke</title>

      <para>Es gibt einige typische Fehler, denen Sie möglicherweise auch selbst begegnen werden. Dieser Abschnitt könnte Ihnen dabei helfen, dies zu vermeiden.</para>

<sect2 id="i18n-string-semantics">
        <title>Gleiche Zeichenketten, unterschiedliche Semantik</title>

        <para>Sometimes two english strings are identical but have different meanings in
different contexts, so they would probably not be identical when translated. Since the English strings are
          used as look-up keys, this causes problems.</para>

<para>
In these cases, you should add extra characters to the strings. For instance,
use <literal>"jumps[noun]"</literal> and <literal>"jumps[verb]"</literal>
instead of just <literal>"jumps"</literal>) and strip them again outside the
<function>gettext</function> call. If you add extra characters you should also
add a comment for the translators before the <function>gettext</function> call.
Such comments will be shown in the <filename>.po</filename> files. For
instance:
</para>

<programlisting>// note to translators: don't translate the "[noun]" part - it is
// just here to distinguish the string from another "jumps" string
text = strip(gettext("jumps[noun]"), "[noun]");</programlisting>
      </sect2>

<sect2 id="i18n-composition">
  <title>Zusammenstellung der Zeichenketten</title>

<para>
C programmers use <function>sprintf()</function> to compose and concatenate
strings. C++ favours streams, but unfortunately, this approach makes
translation difficult, because each fragment of text is translated separately,
without allowing the translators to rearrange them according to the grammar of
the language.</para>

<para>Folgendes könnte beispielsweise problematisch sein:</para>

<programlisting>std::cout &lt;&lt; _("Current amount: ") &lt;&lt; amount
          &lt;&lt; _(" Future: ") &lt;&lt; future &lt;&lt; std::endl;

label.set_text(_("Really delete ") + filename + _(" now?"));</programlisting>

<para>
So you should either avoid this situation or revert to the C-style
<function>sprintf()</function>. One possible solution is the <ulink url="http://www.cs.auc.dk/~olau/compose/">compose library</ulink> which
supports syntax such as:
</para>

<programlisting>label.set_text(compose(_("Really delete %1 now?"), filename));</programlisting>
</sect2>

<sect2 id="i18n-display-size">
        <title>Einschätzen der Anzeigegröße von Zeichenketten</title>

        <para>You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most <application>gtkmm</application> widgets will expand at runtime to the required size.</para>
</sect2>

<sect2 id="i18n-unusual-words">
        <title>Unübliche Wörter</title>

        <para>Sie sollten kryptische Abkürzungen, Slang oder Jargon vermeiden. So etwas ist recht schwierig zu übersetzen und oft selbst für Muttersprachler nur schwer verständlich. Beispielsweise sollten Sie »application« gegenüber »app« bevorzugen.</para>
</sect2>

<sect2 id="i18n-non-ascii-characters">
<title>Verwendubg von Nicht-ASCII-Zeichen in Zeichenketten</title>

<para>
Currently, <application>gettext</application> does not support non-ASCII
characters (i.e. any characters with a code above 127) in source code. For
instance, you cannot use the copyright sign (©).
</para>

        <para>To work around this, you could write a comment in the
          source code just before the string, telling the translators to
          use the special character if it is available in their languages. For english, you could then make an American English
          <filename>en_US.po</filename> translation which used that special charactger.</para>
      </sect2>
    </sect1>

    <sect1 id="sec-i18n-getting-help-with-translations">
      <title>Hilfe zu Übersetzungen erhalten</title>

      <para>If your program is free software, there is a whole <literal>GNOME</literal>
        subproject devoted to helping you make translations, the
        <ulink url="http://developer.gnome.org/projects/gtp/"><literal>GNOME</literal>
        Translation Project</ulink>.</para>

      <para>The way it works is that you contact the gnome-i18n
        mailing list to find out how the translators can access your
        <filename>po/</filename> subdirectory, and to add your project
        to the big <ulink url="http://developer.gnome.org/projects/gtp/status/">status
        tables</ulink>.</para>

      <para>Then you make sure you update the file
        <filename>POTFILES.in</filename> in the
        <filename>po/</filename> subdirectory
        (<command>intltool-update -M</command> can help with this) so
        that the translators always access updated
        <filename>myprogram.pot</filename> files, and simply freeze
        the strings at least a couple of days before you make a new
        release, announcing it on gnome-i18n. Depending on the number
        of strings your program contains and how popular it is, the
        translations will then start to tick in as
        <filename>languagename.po</filename> files.</para>

      <para>Note that most language teams only consist of 1-3 persons,
        so if your program contains a lot of strings, it might last a
        while before anyone has the time to look at it. Also, most
        translators do not want to waste their time (translating is
        a very time-consuming task) so if they do not assess your
        project as being really serious (in the sense that it is
        polished and being maintained) they may decide to spend their
        time on some other project.</para>
    </sect1>
</chapter>

<chapter id="chapter-customwidgets">
    <title>Benutzerdefinierte Widgets</title>

    <para><application>gtkmm</application> makes it very easy to derive new widgets by inheriting from an
      existing widget class, either by deriving from a container and adding child
      widgets, or by deriving from a single-item widget, and changing its behaviour.
      But you might occasionally find that no suitable starting point already exists.
      In this case, you can implement a widget from scratch.</para>

    <sect1 id="sec-custom-containers">
    <title>Benutzerdefinierte Container</title>
    <para>When deriving from <classname>Gtk::Container</classname>, you should override the following virtual methods:
    <itemizedlist>
      <listitem><para><methodname>get_request_mode_vfunc()</methodname>: Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the container.</para></listitem>
      <listitem><para><methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum and natural width of the container.</para></listitem>
      <listitem><para><methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum and natural height of the container.</para></listitem>
      <listitem><para><methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate the minimum and natural width of the container, if it would be given the specified height.</para></listitem>
      <listitem><para><methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate the minimum and natural height of the container, if it would be given the specified width.</para></listitem>
      <listitem><para><methodname>on_size_allocate()</methodname>: Position the child widgets, given the height and width that the container has actually been given.</para></listitem>
      <listitem><para><methodname>forall_vfunc()</methodname>: Call the same callback for each of the children.</para></listitem>
      <listitem><para><methodname>on_add()</methodname>: Add a child widget to the container.</para></listitem>
      <listitem><para><methodname>on_remove()</methodname>: Remove a child widget from the container.</para></listitem>
      <listitem><para><methodname>child_type_vfunc()</methodname>: Return what type of child can be added.</para></listitem>
    </itemizedlist>
    </para>

    <para>The <methodname>get_request_mode_vfunc()</methodname>,
        <methodname>get_preferred_width_vfunc()</methodname>,
        <methodname>get_preferred_height_vfunc()</methodname>,
        <methodname>get_preferred_width_for_height_vfunc()</methodname>,
        <methodname>get_preferred_height_for_width_vfunc()</methodname>, and
        <methodname>on_size_allocate()</methodname> virtual methods control the
        layout of the child widgets. For instance, if your container has 2
        child widgets, with one below the other, your
        <methodname>get_request_mode_vfunc()</methodname> might request
        height-for-width layout. Then your
        <methodname>get_preferred_width_vfunc()</methodname>
        might report the maximum of the widths of the child widgets, and
        <methodname>get_preferred_height_for_width_vfunc()</methodname>
        might report the sum of their heights. If you want padding between
        the child widgets then you would add that to the width and height too.
        Your widget's container will use this result to ensure that your widget
        gets enough space, and not less. By examining each widget's parent, and
        its parent, this logic will eventually decide the size of the top-level
        window.</para>

    <para>You are not guaranteed to get the <literal>Gtk::SizeRequestMode</literal>
        that you request. Therefore all four of the
        <methodname>get_preferred_xxx_vfunc()</methodname> methods must return
        sensible values.</para>

   <para><methodname>on_size_allocate()</methodname> receives the actual
       height and width that the parent container has decided to give to your
       widget. This might be more than the minimum, or even more than the natural
       size, for instance if the
       top-level window has been expanded. You might choose to ignore the extra
       space and leave a blank area, or you might choose to expand your child
       widgets to fill the space, or you might choose to expand the padding
       between your widgets. It's your container, so you decide. Don't forget to
       call <methodname>set_allocation()</methodname> inside your
       <methodname>on_size_allocate()</methodname> implementation to actually use the
       allocated space that has been offered by the parent container.</para>

  <para>Unless your container is a top-level window that derives from
      <classname>Gtk::Window</classname>, you should probably also call
      <methodname>Gtk::Widget::set_has_window(false)</methodname> in your
      constructor. This means that your container does not create its own
      <classname>Gdk::Window</classname>, but uses its parent's
      window. (Note the difference between <classname>Gtk::Window</classname>
      and <classname>Gdk::Window</classname>.) If your container does need
      its own <classname>Gdk::Window</classname>, and does not derive from
      <classname>Gtk::Window</classname>, you must also override the
      <methodname>on_realize()</methodname> method as described in the
      <link linkend="sec-custom-widgets">Custom Widgets</link> section.
      And unless your container draws directly onto the underlying
      <classname>Gdk::Window</classname>, you should probably call
      <methodname>set_redraw_on_allocate(false)</methodname> to improve
      performance.</para>

  <para>By overriding <methodname>forall_vfunc()</methodname> you can allow
      applications to operate on all of the container's child widgets. For
      instance, <methodname>show_all_children()</methodname> uses this to find all
      the child widgets and show them.</para>

  <para>Although your container might have its own method to set the child
      widgets, you should still provide an implementation for the virtual
      <methodname>on_add()</methodname> and <methodname>on_remove()</methodname>
      methods from the base class, so that the add() and remove() methods will
      do something appropriate if they are called.</para>

  <para>Your implementation of the <methodname>child_type_vfunc()</methodname>
      method should report the type of widget that may be added to your
      container, if it is not yet full. This is usually
      <methodname>Gtk::Widget::get_type()</methodname> to indicate that the
      container may contain any class derived from
      <classname>Gtk::Widget</classname>. If the container may not contain any
      more widgets, then this method should return
      <literal>G_TYPE_NONE</literal>.</para>


<sect2 id="custom-container-example"><title>Beispiel</title>

    <para>This example implements a container with two child widgets, one above
        the other. Of course, in this case it would be far simpler just to use
        a <classname>Gtk::VBox</classname>.</para>

<figure id="figure-custom-container">
  <title>Benutzerdefinierter Container</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/custom_container.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/custom/custom_container/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>mycontainer.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H
#define GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H

#include &lt;gtkmm/container.h&gt;

class MyContainer : public Gtk::Container
{
public:
  MyContainer();
  virtual ~MyContainer();

  void set_child_widgets(Gtk::Widget&amp; child_one, Gtk::Widget&amp; child_two);

protected:

  //Overrides:
  virtual Gtk::SizeRequestMode get_request_mode_vfunc() const;
  virtual void get_preferred_width_vfunc(int&amp; minimum_width, int&amp; natural_width) const;
  virtual void get_preferred_height_for_width_vfunc(int width, int&amp; minimum_height, int&amp; natural_height) const;
  virtual void get_preferred_height_vfunc(int&amp; minimum_height, int&amp; natural_height) const;
  virtual void get_preferred_width_for_height_vfunc(int height, int&amp; minimum_width, int&amp; natural_width) const;
  virtual void on_size_allocate(Gtk::Allocation&amp; allocation);

  virtual void forall_vfunc(gboolean include_internals, GtkCallback callback, gpointer callback_data);

  virtual void on_add(Gtk::Widget* child);
  virtual void on_remove(Gtk::Widget* child);
  virtual GType child_type_vfunc() const;

  Gtk::Widget* m_child_one;
  Gtk::Widget* m_child_two;
};

#endif //GTKMM_CUSTOM_CONTAINER_MYCONTAINER_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "mycontainer.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Child widgets:
  Gtk::VBox m_VBox;
  MyContainer m_MyContainer;
  Gtk::Button m_Button_One;
  Gtk::Label m_Label_Two;
  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_One("Child One"),
  m_Label_Two("Child 2"),
  m_Button_Quit("Quit")
{
  set_title("Custom Container example");
  set_border_width(6);
  set_default_size(400, 200);

  add(m_VBox);

  //Add the child widgets to the custom container:
  m_MyContainer.set_child_widgets(m_Button_One, m_Label_Two);

  m_Label_Two.set_alignment(1.0, 0.5);

  m_VBox.pack_start(m_MyContainer, Gtk::PACK_EXPAND_WIDGET);
  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(6);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this,
              &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<para>File: <filename>mycontainer.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include &lt;iostream&gt;
#include &lt;algorithm&gt; // std::max
#include "mycontainer.h"

MyContainer::MyContainer()
: m_child_one(0), m_child_two(0)
{
  set_has_window(false);
  set_redraw_on_allocate(false);
}

MyContainer::~MyContainer()
{
}

void MyContainer::set_child_widgets(Gtk::Widget&amp; child_one,
        Gtk::Widget&amp; child_two)
{
  m_child_one = &amp;child_one;
  m_child_two = &amp;child_two;

  m_child_one-&gt;set_parent(*this);
  m_child_two-&gt;set_parent(*this);
}

//This example container is a simplified VBox with at most two children.
Gtk::SizeRequestMode MyContainer::get_request_mode_vfunc() const
{
  return Gtk::SIZE_REQUEST_HEIGHT_FOR_WIDTH;
}

//Discover the total amount of minimum space and natural space needed by
//this container and its children.
void MyContainer::get_preferred_width_vfunc(int&amp; minimum_width, int&amp; natural_width) const
{
  int child_minimum_width[2] = {0, 0};
  int child_natural_width[2] = {0, 0};

  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
    m_child_one-&gt;get_preferred_width(child_minimum_width[0], child_natural_width[0]);

  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
    m_child_two-&gt;get_preferred_width(child_minimum_width[1], child_natural_width[1]);

  //Request a width equal to the width of the widest visible child.
  minimum_width = std::max(child_minimum_width[0], child_minimum_width[1]);
  natural_width = std::max(child_natural_width[0], child_natural_width[1]);
}

void MyContainer::get_preferred_height_for_width_vfunc(int width,
   int&amp; minimum_height, int&amp; natural_height) const
{
  int child_minimum_height[2] = {0, 0};
  int child_natural_height[2] = {0, 0};
  int nvis_children = 0;

  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
  {
    ++nvis_children;
    m_child_one-&gt;get_preferred_height_for_width(width, child_minimum_height[0],
                                                child_natural_height[0]);
  }

  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
  {
    ++nvis_children;
    m_child_two-&gt;get_preferred_height_for_width(width, child_minimum_height[1],
                                                child_natural_height[1]);
  }

  //The allocated height will be divided equally among the visible children.
  //Request a height equal to the number of visible children times the height
  //of the highest child.
  minimum_height = nvis_children * std::max(child_minimum_height[0],
                                            child_minimum_height[1]);
  natural_height = nvis_children * std::max(child_natural_height[0],
                                            child_natural_height[1]);
}

void MyContainer::get_preferred_height_vfunc(int&amp; minimum_height, int&amp; natural_height) const
{
  int child_minimum_height[2] = {0, 0};
  int child_natural_height[2] = {0, 0};
  int nvis_children = 0;

  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
  {
    ++nvis_children;
    m_child_one-&gt;get_preferred_height(child_minimum_height[0], child_natural_height[0]);
  }

  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
  {
    ++nvis_children;
    m_child_two-&gt;get_preferred_height(child_minimum_height[1], child_natural_height[1]);
  }

  //The allocated height will be divided equally among the visible children.
  //Request a height equal to the number of visible children times the height
  //of the highest child.
  minimum_height = nvis_children * std::max(child_minimum_height[0],
                                            child_minimum_height[1]);
  natural_height = nvis_children * std::max(child_natural_height[0],
                                            child_natural_height[1]);
}

void MyContainer::get_preferred_width_for_height_vfunc(int height,
   int&amp; minimum_width, int&amp; natural_width) const
{
  int child_minimum_width[2] = {0, 0};
  int child_natural_width[2] = {0, 0};
  int nvis_children = 0;

  //Get number of visible children.
  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
    ++nvis_children;
  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
    ++nvis_children;

  if(nvis_children &gt; 0)
  {
    //Divide the height equally among the visible children.
    const int height_per_child = height / nvis_children;

    if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
      m_child_one-&gt;get_preferred_width_for_height(height_per_child,
                   child_minimum_width[0], child_natural_width[0]);

    if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
      m_child_two-&gt;get_preferred_width_for_height(height_per_child,
                   child_minimum_width[1], child_natural_width[1]);
  }

  //Request a width equal to the width of the widest child.
  minimum_width = std::max(child_minimum_width[0], child_minimum_width[1]);
  natural_width = std::max(child_natural_width[0], child_natural_width[1]);
}

void MyContainer::on_size_allocate(Gtk::Allocation&amp; allocation)
{
  //Do something with the space that we have actually been given:
  //(We will not be given heights or widths less than we have requested, though
  //we might get more.)

  //Use the offered allocation for this container:
  set_allocation(allocation);

  //Get number of visible children.
  int nvis_children = 0;
  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
    ++nvis_children;
  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
    ++nvis_children;

  if(nvis_children &lt;= 0)
    return;

  //Assign space to the children:
  Gtk::Allocation child_allocation_one;
  Gtk::Allocation child_allocation_two;

  //Place the first child at the top-left:
  child_allocation_one.set_x( allocation.get_x() );
  child_allocation_one.set_y( allocation.get_y() );

  //Make it take up the full width available:
  child_allocation_one.set_width( allocation.get_width() );

  if(m_child_one &amp;&amp; m_child_one-&gt;get_visible())
  {
    //Divide the height equally among the visible children.
    child_allocation_one.set_height( allocation.get_height() / nvis_children);
    m_child_one-&gt;size_allocate(child_allocation_one);
  }
  else
    child_allocation_one.set_height(0);

  //Place the second child below the first child:
  child_allocation_two.set_x( allocation.get_x() );
  child_allocation_two.set_y( allocation.get_y() +
          child_allocation_one.get_height());

  //Make it take up the full width available:
  child_allocation_two.set_width( allocation.get_width() );

  //Make it take up the remaining height:
  child_allocation_two.set_height( allocation.get_height() -
          child_allocation_one.get_height());

  if(m_child_two &amp;&amp; m_child_two-&gt;get_visible())
    m_child_two-&gt;size_allocate(child_allocation_two);
}

void MyContainer::forall_vfunc(gboolean, GtkCallback callback, gpointer callback_data)
{
  if(m_child_one)
    callback(m_child_one-&gt;gobj(), callback_data);

  if(m_child_two)
    callback(m_child_two-&gt;gobj(), callback_data);
}

void MyContainer::on_add(Gtk::Widget* child)
{
  if(!m_child_one)
  {
    m_child_one = child;
    m_child_one-&gt;set_parent(*this);
  }
  else if(!m_child_two)
  {
    m_child_two = child;
    m_child_two-&gt;set_parent(*this);
  }
}

void MyContainer::on_remove(Gtk::Widget* child)
{
  if(child)
  {
    const bool visible = child-&gt;get_visible();
    bool found = false;

    if(child == m_child_one)
    {
      m_child_one = 0;
      found = true;
    }
    else if(child == m_child_two)
    {
      m_child_two = 0;
      found = true;
    }

    if(found)
    {
      child-&gt;unparent();

      if(visible)
        queue_resize();
    }
  }
}

GType MyContainer::child_type_vfunc() const
{
  //If there is still space for one widget, then report the type of widget that
  //may be added.
  if(!m_child_one || !m_child_two)
    return Gtk::Widget::get_type();
  else
  {
    //No more widgets may be added.
    return G_TYPE_NONE;
  }
}
</programlisting>
<!-- end inserted example code -->
</sect2>

    </sect1>

    <sect1 id="sec-custom-widgets">
    <title>Benutzerdefinierte Widgets</title>
    <para>By deriving directly from <classname>Gtk::Widget</classname> you can
        do all the drawing for your widget directly, instead of just arranging
        child widgets. For instance, a <classname>Gtk::Label</classname> draws
        the text of the label, but does not do this by using other
        widgets.</para>

    <para>When deriving from <classname>Gtk::Widget</classname>, you should
        override the following virtual methods. The methods marked (optional)
        need not be overridden in all custom widgets. The base class's methods
        may be appropriate.
    <itemizedlist>
      <listitem><para><methodname>get_request_mode_vfunc()</methodname>: (optional) Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the widget.</para></listitem>
      <listitem><para><methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum and natural width of the widget.</para></listitem>
      <listitem><para><methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum and natural height of the widget.</para></listitem>
      <listitem><para><methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate the minimum and natural width of the widget, if it would be given the specified height.</para></listitem>
      <listitem><para><methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate the minimum and natural height of the widget, if it would be given the specified width.</para></listitem>
      <listitem><para><methodname>on_size_allocate()</methodname>: Position the widget, given the height and width that it has actually been given.</para></listitem>
      <listitem><para><methodname>on_realize()</methodname>: Associate a <classname>Gdk::Window</classname> with the widget.</para></listitem>
      <listitem><para><methodname>on_unrealize()</methodname>: (optional) Break the association with the <classname>Gdk::Window</classname>. </para></listitem>
      <listitem><para><methodname>on_map()</methodname>: (optional)</para></listitem>
      <listitem><para><methodname>on_unmap()</methodname>: (optional)</para></listitem>
      <listitem><para><methodname>on_draw()</methodname>: Draw on the supplied <classname>Cairo::Context</classname>.</para></listitem>
    </itemizedlist>
    </para>

    <para>The first 6 methods in the previous table are also overridden in custom
        containers. They are briefly described in the
        <link linkend="sec-custom-containers">Custom Containers</link> section.
    </para>

    <para>Most custom widgets need their own <classname>Gdk::Window</classname>
      to draw on. Then you can call
      <methodname>Gtk::Widget::set_has_window(true)</methodname> in your
      constructor. (This is the default value.) If you do not call
      <methodname>set_has_window(false)</methodname>, you must override
      <methodname>on_realize()</methodname> and call
      <methodname>Gtk::Widget::set_realized()</methodname> and
      <methodname>Gtk::Widget::set_window()</methodname> from there.</para>

<sect2 id="custom-widget-example"><title>Beispiel</title>

<para>This example implements a widget which draws a Penrose triangle.</para>

<figure id="figure-custom-widget">
  <title>Benutzerdefiniertes Widget</title>
  <screenshot>
    <graphic format="PNG" fileref="figures/custom_widget.png"/>
  </screenshot>
</figure>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/custom/custom_widget/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>mywidget.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_CUSTOM_WIDGET_MYWIDGET_H
#define GTKMM_CUSTOM_WIDGET_MYWIDGET_H

#include &lt;gtkmm/widget.h&gt;
#include &lt;gtkmm/cssprovider.h&gt;

class MyWidget : public Gtk::Widget
{
public:
  MyWidget();
  virtual ~MyWidget();

protected:

  //Overrides:
  virtual Gtk::SizeRequestMode get_request_mode_vfunc() const;
  virtual void get_preferred_width_vfunc(int&amp; minimum_width, int&amp; natural_width) const;
  virtual void get_preferred_height_for_width_vfunc(int width, int&amp; minimum_height, int&amp; natural_height) const;
  virtual void get_preferred_height_vfunc(int&amp; minimum_height, int&amp; natural_height) const;
  virtual void get_preferred_width_for_height_vfunc(int height, int&amp; minimum_width, int&amp; natural_width) const;
  virtual void on_size_allocate(Gtk::Allocation&amp; allocation);
  virtual void on_map();
  virtual void on_unmap();
  virtual void on_realize();
  virtual void on_unrealize();
  virtual bool on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr);

  Glib::RefPtr&lt;Gdk::Window&gt; m_refGdkWindow;
  Glib::RefPtr&lt;Gtk::CssProvider&gt; m_refStyleProvider;

  int m_scale;
};

#endif //GTKMM_CUSTOM_WIDGET_MYWIDGET_H
</programlisting>
<para>File: <filename>examplewindow.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLEWINDOW_H
#define GTKMM_EXAMPLEWINDOW_H

#include &lt;gtkmm.h&gt;
#include "mywidget.h"

class ExampleWindow : public Gtk::Window
{
public:
  ExampleWindow();
  virtual ~ExampleWindow();

protected:
  //Signal handlers:
  void on_button_quit();

  //Child widgets:
  Gtk::VBox m_VBox;
  MyWidget m_MyWidget;
  Gtk::HButtonBox m_ButtonBox;
  Gtk::Button m_Button_Quit;
};

#endif //GTKMM_EXAMPLEWINDOW_H
</programlisting>
<para>File: <filename>mywidget.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "mywidget.h"
#include &lt;gdkmm/general.h&gt;  // for cairo helper functions
#include &lt;iostream&gt;
//#include &lt;gtk/gtkwidget.h&gt; //For GTK_IS_WIDGET()
#include &lt;cstring&gt;


MyWidget::MyWidget() :
  //The GType name will actually be gtkmm__CustomObject_mywidget
  Glib::ObjectBase("mywidget"),
  Gtk::Widget(),
  m_scale(1000)
{
  set_has_window(true);

  //This shows the GType name, which must be used in the CSS file.
  std::cout &lt;&lt; "GType name: " &lt;&lt; G_OBJECT_TYPE_NAME(gobj()) &lt;&lt; std::endl;

  //This shows that the GType still derives from GtkWidget:
  //std::cout &lt;&lt; "Gtype is a GtkWidget?:" &lt;&lt; GTK_IS_WIDGET(gobj()) &lt;&lt; std::endl;

  //Install a style so that an aspect of this widget may be themed via a CSS
  //style sheet file:
  gtk_widget_class_install_style_property(GTK_WIDGET_CLASS(
              G_OBJECT_GET_CLASS(gobj())),
      g_param_spec_int("example_scale",
        "Scale of Example Drawing",
        "The scale to use when drawing. This is just a silly example.",
        G_MININT,
        G_MAXINT,
        500,
        G_PARAM_READABLE) );

  m_refStyleProvider = Gtk::CssProvider::create();
  Glib::RefPtr&lt;Gtk::StyleContext&gt; refStyleContext = get_style_context();
  refStyleContext-&gt;add_provider(m_refStyleProvider, 
    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    
  try
  {
    m_refStyleProvider-&gt;load_from_path("custom_gtk.css");
  }
  catch(const Glib::Error&amp; ex)
  {
    std::cerr &lt;&lt; "Gtk::CssProvider::load_from_path() failed: " &lt;&lt; ex.what() &lt;&lt; std::endl;
  }
}

MyWidget::~MyWidget()
{
}

Gtk::SizeRequestMode MyWidget::get_request_mode_vfunc() const
{
  //Accept the default value supplied by the base class.
  return Gtk::Widget::get_request_mode_vfunc();
}

//Discover the total amount of minimum space and natural space needed by
//this widget.
//Let's make this simple example widget always need minimum 60 by 50 and
//natural 100 by 70.
void MyWidget::get_preferred_width_vfunc(int&amp; minimum_width, int&amp; natural_width) const
{
  minimum_width = 60;
  natural_width = 100;
}

void MyWidget::get_preferred_height_for_width_vfunc(int /* width */,
   int&amp; minimum_height, int&amp; natural_height) const
{
  minimum_height = 50;
  natural_height = 70;
}

void MyWidget::get_preferred_height_vfunc(int&amp; minimum_height, int&amp; natural_height) const
{
  minimum_height = 50;
  natural_height = 70;
}

void MyWidget::get_preferred_width_for_height_vfunc(int /* height */,
   int&amp; minimum_width, int&amp; natural_width) const
{
  minimum_width = 60;
  natural_width = 100;
}

void MyWidget::on_size_allocate(Gtk::Allocation&amp; allocation)
{
  //Do something with the space that we have actually been given:
  //(We will not be given heights or widths less than we have requested, though
  //we might get more)

  //Use the offered allocation for this container:
  set_allocation(allocation);

  if(m_refGdkWindow)
  {
    m_refGdkWindow-&gt;move_resize( allocation.get_x(), allocation.get_y(),
            allocation.get_width(), allocation.get_height() );
  }
}

void MyWidget::on_map()
{
  //Call base class:
  Gtk::Widget::on_map();
}

void MyWidget::on_unmap()
{
  //Call base class:
  Gtk::Widget::on_unmap();
}

void MyWidget::on_realize()
{
  //Do not call base class Gtk::Widget::on_realize().
  //It's intended only for widgets that set_has_window(false).

  set_realized();

  //Get the themed style from the CSS file:
  get_style_property("example_scale", m_scale);
  std::cout &lt;&lt; "m_scale (example_scale from the theme/css-file) is: "
      &lt;&lt; m_scale &lt;&lt; std::endl;

  if(!m_refGdkWindow)
  {
    //Create the GdkWindow:

    GdkWindowAttr attributes;
    memset(&amp;attributes, 0, sizeof(attributes));

    Gtk::Allocation allocation = get_allocation();

    //Set initial position and size of the Gdk::Window:
    attributes.x = allocation.get_x();
    attributes.y = allocation.get_y();
    attributes.width = allocation.get_width();
    attributes.height = allocation.get_height();

    attributes.event_mask = get_events () | Gdk::EXPOSURE_MASK;
    attributes.window_type = GDK_WINDOW_CHILD;
    attributes.wclass = GDK_INPUT_OUTPUT;

    m_refGdkWindow = Gdk::Window::create(get_parent_window(), &amp;attributes,
            GDK_WA_X | GDK_WA_Y);
    set_window(m_refGdkWindow);

    //set colors
    override_background_color(Gdk::RGBA("red"));
    override_color(Gdk::RGBA("blue"));

    //make the widget receive expose events
    m_refGdkWindow-&gt;set_user_data(gobj());
  }
}

void MyWidget::on_unrealize()
{
  m_refGdkWindow.reset();

  //Call base class:
  Gtk::Widget::on_unrealize();
}

bool MyWidget::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)
{
  const double scale_x = (double)get_allocation().get_width() / m_scale;
  const double scale_y = (double)get_allocation().get_height() / m_scale;

  // paint the background
  Gdk::Cairo::set_source_rgba(cr, get_style_context()-&gt;get_background_color());
  cr-&gt;paint();

  // draw the foreground
  Gdk::Cairo::set_source_rgba(cr, get_style_context()-&gt;get_color());
  cr-&gt;move_to(155.*scale_x, 165.*scale_y);
  cr-&gt;line_to(155.*scale_x, 838.*scale_y);
  cr-&gt;line_to(265.*scale_x, 900.*scale_y);
  cr-&gt;line_to(849.*scale_x, 564.*scale_y);
  cr-&gt;line_to(849.*scale_x, 438.*scale_y);
  cr-&gt;line_to(265.*scale_x, 100.*scale_y);
  cr-&gt;line_to(155.*scale_x, 165.*scale_y);
  cr-&gt;move_to(265.*scale_x, 100.*scale_y);
  cr-&gt;line_to(265.*scale_x, 652.*scale_y);
  cr-&gt;line_to(526.*scale_x, 502.*scale_y);
  cr-&gt;move_to(369.*scale_x, 411.*scale_y);
  cr-&gt;line_to(633.*scale_x, 564.*scale_y);
  cr-&gt;move_to(369.*scale_x, 286.*scale_y);
  cr-&gt;line_to(369.*scale_x, 592.*scale_y);
  cr-&gt;move_to(369.*scale_x, 286.*scale_y);
  cr-&gt;line_to(849.*scale_x, 564.*scale_y);
  cr-&gt;move_to(633.*scale_x, 564.*scale_y);
  cr-&gt;line_to(155.*scale_x, 838.*scale_y);
  cr-&gt;stroke();

  return true;
}
</programlisting>
<para>File: <filename>examplewindow.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"

ExampleWindow::ExampleWindow()
: m_Button_Quit("Quit")
{
  set_title("Custom Widget example");
  set_border_width(6);
  set_default_size(400, 200);

  add(m_VBox);
  m_VBox.pack_start(m_MyWidget, Gtk::PACK_EXPAND_WIDGET);
  m_MyWidget.show();

  m_VBox.pack_start(m_ButtonBox, Gtk::PACK_SHRINK);

  m_ButtonBox.pack_start(m_Button_Quit, Gtk::PACK_SHRINK);
  m_ButtonBox.set_border_width(6);
  m_ButtonBox.set_layout(Gtk::BUTTONBOX_END);
  m_Button_Quit.signal_clicked().connect( sigc::mem_fun(*this, &amp;ExampleWindow::on_button_quit) );

  show_all_children();
}

ExampleWindow::~ExampleWindow()
{
}

void ExampleWindow::on_button_quit()
{
  hide();
}
</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "examplewindow.h"
#include &lt;gtkmm/main.h&gt;

int main(int argc, char *argv[])
{
  Gtk::Main kit(argc, argv);

  ExampleWindow window;
  //Shows the window and returns when it is closed.
  Gtk::Main::run(window);

  return 0;
}
</programlisting>
<!-- end inserted example code -->
</sect2>

    </sect1>



</chapter>

<chapter id="chapter-recommended-techniques">
<title>Empfohlene Techniken</title>

<para>This section is simply a gathering of wisdom, general style guidelines
and hints for creating <application>gtkmm</application> applications.
</para>

<para>Use GNU <application>autoconf</application> and
    <application>automake</application>! They are your friends :)
    <application>Automake</application> examines C files, determines how they
    depend on each other, and generates a <filename>Makefile</filename> so the
    files can be compiled in the correct order.
    <application>Autoconf</application> permits automatic configuration of
    software installation, handling a large number of system quirks to increase
    portability..
</para>

<para>Subclass Widgets to better organize your code. You should probably
    subclass your main <classname>Window</classname> at least. Then you can
    make your child Widgets and signal handlers members of that class.
</para>

<para>Create your own signals instead of passing pointers around. Objects can
    communicate with each other via signals and signal handlers. This is much
    simpler than objects holding pointers to each other and calling each
    other's methods. <application>gtkmm</application>'s classes uses special versions of
    <classname>sigc::signal</classname>, but you should use normal
    <classname>sigc::signal</classname>s, as described in the
    <application>libsigc++</application> documentation.</para>

<sect1 id="sec-application-lifetime">
    <title>Lebensdauer einer Anwendung</title>
<para>Most applications will have only one <classname>Window</classname>, or
    only one main window. These applications can use the
    <methodname>Gtk::Main::run(Gtk::Window&amp;)</methodname> overload. It shows
    the window and returns when the window has been hidden. This might happen
    when the user closes the window, or when your code decides to
    <methodname>hide()</methodname> the window. You can prevent the user from
    closing the window (for instance, if there are unsaved changes) by
    overriding <methodname>Gtk::Window::on_delete_event()</methodname>.</para>
<para>Die meisten unserer Beispiele verwenden diese Technik.</para>
</sect1>

<sect1 id="sec-using-a-gtkmm-widget">
<title>Verwendung eines <application>gtkmm</application>-Widgets</title>

<para>
    Our examples all tend to have the same structure. They follow these steps
    for using a <classname>Widget</classname>:
</para>

<para>

<orderedlist>
<listitem>
<para>
Declare a variable of the type of <classname>Widget</classname> you wish to
use, generally as member variable of a derived container class. You could also
declare a pointer to the widget type, and then create it with
<literal>new</literal> in your code. Even when using the widget via a pointer,
it's still probably best to make that pointer a member variable of a container
class so that you can access it later.
</para>
</listitem>

<listitem>
<para>
 Set the attributes of the widget. If the widget has no default constructor, then you will need to initialize the widget in the initalizer list of your container class's constructor.
</para>
</listitem>

<listitem>
<para>
Connect any signals you wish to use to the appropriate handlers.
</para>
</listitem>

<listitem>
<para>
Pack the widget into a container using the appropriate call,
e.g. <methodname>Gtk::Container::add()</methodname> or
<methodname>pack_start()</methodname>.
</para>
</listitem>

<listitem>
<para>
Call <methodname>show()</methodname> to display the widget.
</para>
</listitem>

</orderedlist>

</para>

<para>
<methodname>Gtk::Widget::show()</methodname> lets <application>gtkmm</application> know that we have
finished setting the attributes of the widget, and that it is ready to be
displayed. You can use <methodname>Gtk::Widget::hide()</methodname> to make it
disappear again. The order in which you show the widgets is not important, but
we do suggest that you show the top-level window last; this way, the whole
window will appear with its contents already drawn. Otherwise, the user will
first see a blank window, into which the widgets will be gradually drawn.
</para>

</sect1>
</chapter>

<chapter id="chapter-contributing">
<title>Contributing</title>

<para>
This document, like so much other great software out there, was
created for free by volunteers. If you are at all knowledgeable about
any aspect of <application>gtkmm</application> that does not already have documentation, please
consider contributing to this document.
</para>
<para>
Ideally, we would like you to <ulink url="http://www.gtkmm.org/bugs.shtml">provide a patch</ulink> to the
<filename>docs/tutorial/C/gtkmm-tutorial-in.xml</filename> file. This file is currently
in the <literal>gtkmm-documentation</literal> module in GNOME git.
</para>

<para>
If you do decide to contribute, please post your contribution to the
<application>gtkmm</application> mailing list at <ulink url="mailto:gtkmm-list@gnome.org">&lt;gtkmm-list@gnome.org&gt;</ulink>. Also, be aware that
the entirety of this document is free, and any addition you provide
must also be free. That is, people must be able to use any portion of
your examples in their programs, and copies of this document
(including your contribution) may be distributed freely.
</para>

</chapter>

<appendix id="chapter-refptr">
<title>The RefPtr smartpointer</title>
<para>
<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a
reference-counting smartpointer. You might be familiar with
<literal>std::auto_ptr&lt;&gt;</literal>, which is also a smartpointer, but
<literal>Glib::RefPtr&lt;&gt;</literal> is much simpler, and more useful. We
expect a future version of the C++ Standard Library to contain a
reference-counting shared smartpointer, and a future version of <application>gtkmm</application> might possibly use that instead.</para>

<para><ulink url="http://developer.gnome.org/glibmm/unstable/classGlib_1_1RefPtr.html">Referenz</ulink></para>

<para>A smartpointer acts much like a normal pointer. Here are a few examples.</para>

<sect1 id="sec-refptr-copying">
    <title>Kopieren</title>
<para>
You can copy <classname>RefPtr</classname>s, just like normal pointers. But
unlike normal pointers, you don't need to worry about deleting the underlying
instance.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap2 = refBitmap;
</programlisting>
</para>
<para>
Of course this means that you can store <classname>RefPtrs</classname> in
standard containers, such as <classname>std::vector</classname> or
<classname>std::list</classname>.</para>
<para>
<programlisting>
std::list&lt; Glib::RefPtr&lt;Gdk::Pixmap&gt; &gt; listPixmaps;
Glib::RefPtr&lt;Gdk::Pixmap&gt; refPixmap = Gdk::Pixmap::create(window,
width, height, depth);
listPixmaps.push_back(refPixmap);
</programlisting>
</para>
</sect1>

<sect1 id="sec-refptr-dereferencing"><title>Dereferenzierung</title>
<para>You can dereference a smartpointer with the -&gt; operator, to
call the methods of the underlying instance, just like a normal pointer.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
int depth = refBitmap-&gt;get_depth();
</programlisting>
</para>
<para>But unlike most smartpointers, you can't use the * operator to
access the underlying instance.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,
data, width, height);
Gdk::Bitmap* underlying = *refBitmap; //Syntax error - will not compile.
</programlisting>
</para>
</sect1>

<sect1 id="sec-refptr-casting"><title>Casting</title>
<para>
You can cast <classname>RefPtrs</classname> to base types, just like normal
pointers.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;
</programlisting>
</para>
<para>This means that any method which takes a <type>const
Glib::RefPtr&lt;BaseType&gt;</type> argument can also take a
<type>const Glib::RefPtr&lt;DerivedType&gt;</type>. The cast is
implicit, just as it would be for a normal pointer.</para>
<para>You can also cast to a derived type, but the syntax is
a little different than with a normal pointer.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =
Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);
Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =
Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);
</programlisting>
</para>
</sect1>


<sect1 id="sec-refptr-checking-for-null"><title>Checking for null</title>
<para>
Just like normal pointers, you can check whether a
<classname>RefPtr</classname> points to anything.
</para>
<para>
<programlisting>
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();
if(refModel)
{
  int cols_count = refModel-&gt;get_n_columns();
  ...
}
</programlisting>
</para>
<para>
But unlike normal pointers, <classname>RefPtr</classname>s are automatically
initialized to null so you don't need to remember to do that yourself.
</para>
</sect1>


<sect1 id="sec-refptr-constness"><title>Constness</title>
<para>
The use of the <literal>const</literal> keyword in C++ is not always clear. You
might not realise that <type>const Something*</type> declares a pointer to a
<type>const Something</type>, The pointer can be changed, but not the
<type>Something</type> that it points to.
</para>
<para>
Therefore, the <classname>RefPtr</classname> equivalent of
<type>Something*</type> for a method parameter is <type>const
    Glib::RefPtr&lt;Something&gt;&amp;</type>, and the equivalent of
<type>const Something*</type> is <type>const Glib::RefPtr&lt;const
    Something&gt;&amp;</type>.
</para>
<para>
The <literal>const ... &amp;</literal> around both is just for efficiency, like
using <classname>const std::string&amp;</classname> instead of
<classname>std::string</classname> for a method parameter to avoid unnecessary
copying.
</para>
</sect1>

</appendix>


<appendix id="chapter-signals">
<title>Signale</title>

<sect1 id="sec-connecting-signal-handlers">
<title>Verbinden von Signal-Handlern</title>
<para>
<application>gtkmm</application> widget classes have signal accessor methods, such as
<methodname>Gtk::Button::signal_clicked()</methodname>, which allow you to connect
your signal handler. Thanks to the flexibility of
<application>libsigc++</application>, the callback library used by <application>gtkmm</application>, the
signal handler can be almost any kind of function, but you will probably want
to use a class method. Among <application>GTK+</application> C coders, these
signal handlers are often named callbacks.
</para>

<para>
Here's an example of a signal handler being connected to a signal:
</para>

<para>
<programlisting>
#include &lt;gtkmm/button.h&gt;

void on_button_clicked()
{
    std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
}

main()
{
    Gtk::Button button("Hello World");
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
}
</programlisting>
</para>

<para>
There's rather a lot to think about in this (non-functional) code.
First let's identify the parties involved:
</para>

<itemizedlist>
<listitem>

<para>
The signal handler is <methodname>on_button_clicked()</methodname>.
</para>
</listitem>
<listitem>

<para>
We're hooking it up to the <classname>Gtk::Button</classname> object called
<varname>button</varname>.
</para>
</listitem>
<listitem>

<para>
When the Button emits its <literal>clicked</literal> signal,
<methodname>on_button_clicked()</methodname> will be called.
</para>
</listitem>

</itemizedlist>

<para>
Now let's look at the connection again:
</para>

<para>
<programlisting>
    ...
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
    ...
</programlisting>
</para>

<para>
Note that we don't pass a pointer to <methodname>on_button_clicked()</methodname>
directly to the signal's <methodname>connect()</methodname> method. Instead, we
call <function>sigc::ptr_fun()</function>, and pass the result to
<methodname>connect()</methodname>.
</para>

<para>
<function>sigc::ptr_fun()</function>  generates a <classname>sigc::slot</classname>.
A slot is an object which
looks and feels like a function, but is actually an object. These are also
known as function objects, or functors.
<function>sigc::ptr_fun()</function> generates a slot for a standalone function or static method.
<function>sigc::mem_fun()</function> generates a slot for a member method of a particular instance.
</para>

<para>
Here's a slightly larger example of slots in action:
</para>

<para>
<programlisting>
void on_button_clicked();

class some_class
{
    void on_button_clicked();
};

some_class some_object;

main()
{
    Gtk::Button button;
    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );
    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );
}
</programlisting>
</para>

<para>
The first call to <methodname>connect()</methodname> is just like the one we saw
last time; nothing new here.</para>
<para>The next is more interesting.
<function>sigc::mem_fun()</function> is called with two arguments. The first
argument is <parameter>some_object</parameter>, which is the object that our
new slot will be pointing at. The second argument is a pointer to one of its
methods. This particular version of <function>sigc::mem_fun()</function>
creates a slot which will, when "called", call the pointed-to method of the
specified object, in this case
<methodname>some_object.on_button_clicked()</methodname>.
</para>

<para>
Another thing to note about this example is that we made the call to
<methodname>connect()</methodname> twice for the same signal object. This is
perfectly fine - when the button is clicked, both signal handlers will be
called.
</para>

<para>
We just told you that the button's <literal>clicked</literal> signal is expecting
to call a method with no arguments. All signals have
requirements like this - you can't hook a function with two arguments
to a signal expecting none (unless you use an adapter, such as
<function>sigc::bind()</function>, of course). Therefore, it's important to
know what type of signal handler you'll be expected to connect to a given
signal.
</para>
</sect1>

<sect1 id="sec-writing-signal-handlers">
<title>Schreiben von Signal-Handlern</title>

<para>
To find out what type of signal handler you can connect to a signal, you can
look it up in the reference documentation or the header file. Here's an example of a signal declaration you
might see in the <application>gtkmm</application> headers:
</para>

<para>
<programlisting>
Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()
</programlisting>
</para>

<para>
Other than the signal's name (<literal>focus</literal>), two things are
important to note here: the number following the word
<classname>SignalProxy</classname> at the beginning (1, in this case), and the
types in the list (<type>bool</type> and <type>Gtk::DirectionType</type>). The
number indicates how many arguments the signal handler should have; the first
type, <type>bool</type>, is the type that the signal handler should return; and
the next type, <type>Gtk::DirectionType</type>, is the type of this signal's
first, and only, argument. By looking at the reference documentation, you can
see the names of the arguments too.
</para>

<para>
The same principles apply for signals which have more arguments. Here's one
with three (taken from <filename>&lt;gtkmm/editable.h&gt;</filename>):
</para>

<para>
<programlisting>
Glib::SignalProxy3&lt;void, const Glib::ustring&amp;, int, int*&gt; signal_insert_text()

</programlisting>
</para>

<para>
It follows the same form. The number 3 at the end of the type's name indicates
that our signal handler will need three arguments. The first type in the type
list is <type>void</type>, so that should be our signal handler's return type.
The following three types are the argument types, in order. Our signal
handler's prototype could look like this:
</para>

<para>
<programlisting>
void on_insert_text(const Glib::ustring&amp; text, int length, int* position);
</programlisting>
</para>
</sect1>

<sect1 id="sec-disconnecting-signal-handlers">
<title>Verbindungen von Signal-Handlern trennen</title>

<para>
Let's take another look at a Signal's <literal>connect</literal> method:
</para>

<para>
<programlisting>
sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );
</programlisting>
</para>

<para>
Notice that the return value is of type
<classname>sigc::signal&lt;void,int&gt;::iterator</classname>. This can be
implicitely converted into a <classname>sigc::connection</classname> which in
turn can be used to control the connection. By keeping a connection object you
can disconnect its associated signal handler using the method
<methodname>sigc::connection::disconnect()</methodname>.
</para>

</sect1>
<sect1 id="sec-overriding-default-signal-handlers">
<title>Überschreiben von Standard-Signalhandlern</title>

<para>
So far we've told you to perform actions in
response to button-presses and the like by handling signals.
That's certainly a good way to do things, but it's not the only
way.
</para>

<para>
Instead of laboriously connecting signal handlers to signals,
you can simply make a new class which inherits from a widget - say, a
Button - and then override the default signal handler, such as Button::on_clicked(). This can be a
lot simpler than hooking up signal handlers for everything.
</para>

<para>
Subclassing isn't always the best way to accomplish
things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects.
</para>

<para>
<application>gtkmm</application> classes are designed with overriding in mind; they contain
virtual member methods specifically intended to be overridden.
</para>

<para>
Let's look at an example of overriding:
</para>

<para>
<programlisting>
#include &lt;gtkmm/button.h&gt;

class OverriddenButton : public Gtk::Button
{
protected:
    virtual void on_clicked();
}

void OverriddenButton::on_clicked()
{
    std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;

    // call the base class's version of the method:
    Gtk::Button::on_clicked();
}
</programlisting>
</para>

<para>
Here  we define a new class called <classname>OverriddenButton</classname>,
which inherits from <classname>Gtk::Button</classname>. The only thing we
change is the <methodname>on_clicked()</methodname> method, which is called
whenever <classname>Gtk::Button</classname> emits the
<literal>clicked</literal> signal. This method prints "Hello World" to
<literal>stdout</literal>, and then calls the original, overridden method, to
let <classname>Gtk::Button</classname> do what it would have done had we not
overridden.
</para>

<para>
You don't always need to call the parent's method; there are times
when you might not want to. Note that we called the parent method
<emphasis>after</emphasis> writing "Hello World", but we could have called it before.
In this simple example, it hardly matters much, but there are times
when it will. With signals, it's not quite so easy to change details
like this, and you can do something here which you can't do at all
with connected signal handlers: you can call the parent method in the <emphasis>middle</emphasis> of
your custom code.
</para>

</sect1>

<sect1 id="sec-binding-extra-arguments">
<title>Binden weiterer Argumente</title>
<para>
If you use one signal handler to catch the same signal from several widgets,
you might like that signal handler to receive some extra information. For
instance, you might want to know which button was clicked. You can do this with
<function>sigc::bind()</function>. Here's some code from the <link linkend="sec-helloworld2">helloworld2</link> example, which you will
encounter later.
<programlisting>
m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1") );
</programlisting>
This says that we want the signal to send an extra
<classname>Glib::ustring</classname> argument to the signal handler, and that
the value of that argument should be "button 1". Of course we will need to add
that extra argument to the declaration of our signal handler:
<programlisting>
virtual void on_button_clicked(Glib::ustring data);
</programlisting>
Of course, a normal "clicked" signal handler would have no arguments.
</para>
<para>
<function>sigc::bind()</function> is not commonly used, but you might find it
helpful sometimes. If you are familiar with <application>GTK+</application>
programming then you have probably noticed that this is similar to the extra
<literal>gpointer data</literal> arguments which all GTK+ callbacks have. This
is generally overused in <application>GTK+</application> to pass information
that should be stored as member data in a derived widget, but widget derivation
is very difficult in C. We have far less need of this hack in <application>gtkmm</application>.
</para>
</sect1>

<sect1 id="sec-xeventsignals">
<title>X-Ereignissignale</title>
<para>
The <classname>Widget</classname> class has some special signals which
correspond to the underlying X-Windows events. These are suffixed by
<literal>_event</literal>; for instance,
<methodname>Widget::signal_button_pressed_event()</methodname>.
</para>
<para>
You might occasionally find it useful to handle X events when there's something
you can't accomplish with normal signals. <classname>Gtk::Button</classname>,
for example, does not send mouse-pointer coordinates with its
<literal>clicked</literal> signal, but you could handle
<literal>button_pressed_event</literal> if you needed this
information. X events are also often used to handle key-presses.
</para>

<para>
These signals behave slightly differently. The value returned from the signal handler indicates whether it has fully "handled"
the event. If the value is <literal>false</literal> then <application>gtkmm</application> will pass the event on to the next signal handler. If the value is <literal>true</literal> then no other signal handlers will need to be called.
</para>

<para>
Handling an X event doesn't affect the Widget's other signals. If you handle
<literal>button_pressed_event</literal> for
<classname>Gtk::Button</classname>, you'll still be able to get the
<literal>clicked</literal> signal. They are emitted at (nearly) the same time.
</para>

<para>Note also that not all widgets receive all X events by default. To receive additional
X events, you can use <methodname>Gtk::Widget::set_events()</methodname> before showing the
widget, or <methodname>Gtk::Widget::add_events()</methodname> after showing the widget. However,
some widgets must first be placed inside an <classname>EventBox</classname> widget. See
the <link linkend="chapter-widgets-without-xwindows">Widgets Without X-Windows</link> chapter.
</para>

<para>Hier ist ein einfaches Beispiel: <programlisting>
bool on_button_press(GdkEventButton* event);
Gtk::Button button("label");
button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );
</programlisting></para>
<para>
When the mouse is over the button and a mouse button is pressed,
<methodname>on_button_press()</methodname> will be called.
</para>

<para>
<type>GdkEventButton</type> is a structure containing the event's parameters,
such as the coordinates of the mouse pointer at the time the button was
pressed. There are several different types of <type>GdkEvent</type> structures
for the various events.
</para>

<sect2 id="signal-handler-sequence">
<title>Signalhandler-Sequenz</title>
<para>By default, your signal handlers are called after any previously-connected signal handlers. However, this can be a problem with the X Event signals. For instance, the existing signal handlers, or the default signal handler, might return true to stop other signal handlers from being called. To specify that your signal handler should be called before the other signal handlers, so that will always be called, you can specify <literal>false</literal> for the optional <literal>after</literal> parameter. For instance,
<programlisting>
button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );
</programlisting>
</para>

</sect2>

</sect1>

</appendix>



<appendix id="chapter-custom-signals">
<title>Erzeugen Ihrer eigenen Signale</title>
<para>
Now that you've seen signals and signal handlers in <application>gtkmm</application>, you
might like to use the same technique to allow interaction between your
own classes. That's actually very simple by using the
<application>libsigc++</application> library directly.
</para>
<para>
This isn't purely a <application>gtkmm</application> or GUI issue. <application>gtkmm</application> uses
<application>libsigc++</application> to implement its proxy wrappers for the
<application>GTK+</application> signal system, but for new,
non-GTK+ signals, you can create pure C++ signals, using the
<classname>sigc::signal&lt;&gt;</classname> template.
</para>
<para>
For instance, to create a signal that sends 2 parameters, a <type>bool</type>
and an <type>int</type>, just declare a <classname>sigc::signal</classname>,
like so:
<programlisting>
sigc::signal&lt;void, bool, int&gt; signal_something;
</programlisting>
</para>
<para>
You could just declare that signal as a public member variable, but
some people find that distasteful and prefer to make it available via
an accessor method, like so:
<programlisting>
class Server
{
public:
  //signal accessor:
  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}
</programlisting>
</para>

<para>
You can then connect to the signal using the same syntax used when
connecting to <application>gtkmm</application> signals. For instance,
<programlisting>
server.signal_something().connect(
  sigc::mem_fun(client, &amp;Client::on_server_something) );
</programlisting>
</para>

<sect1 id="chapter-custom-signals-example"><title>Beispiel</title>

<para>Dies ist ein voll funktionsfähiges Beispiel, welches ein benutzerdefiniertes Signal definiert und nutzt.</para>

<para><ulink url="http://git.gnome.org/browse/gtkmm-documentation/tree/examples/book/signals/custom/?h=">Quelltext</ulink></para>
<!-- start inserted example code -->
<para>File: <filename>client.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_CLIENT_H
#define GTKMM_EXAMPLE_CLIENT_H

#include &lt;sigc++/sigc++.h&gt;

//Client must inherit from sigc::trackable.
//because libsigc++ needs to keep track of the lifetime of signal handlers.
class Client : public sigc::trackable
{
public:
  Client();
  virtual ~Client();

  //Signal handler:
  void on_server_something(bool a, int b);
};

#endif //GTKMM_EXAMPLE_CLIENT_H
</programlisting>
<para>File: <filename>server.h</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#ifndef GTKMM_EXAMPLE_SERVER_H
#define GTKMM_EXAMPLE_SERVER_H

#include &lt;sigc++/sigc++.h&gt;

class Server
{
public:
  Server();
  virtual ~Server();

  void do_something();

  //signal accessor:
  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

#endif //GTKMM_EXAMPLE_SERVER_H
</programlisting>
<para>File: <filename>server.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "server.h"
#include &lt;iostream&gt;

Server::Server()
{
}

Server::~Server()
{
}

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}

void Server::do_something()
{
  m_signal_something.emit(false, 5);
}

</programlisting>
<para>File: <filename>main.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "server.h"
#include "client.h"
#include &lt;iostream&gt;

int main(int, char**)
{
  Server server;
  Client client;

  //Connect a Server signal to the signal handler in Client.
  server.signal_something().connect(sigc::mem_fun(client,
              &amp;Client::on_server_something) );

  std::cout &lt;&lt; "Before Server::do_something()" &lt;&lt; std::endl;

  //Tell the server to do something that will eventually cause it to emit the
  //"something" signal.
  server.do_something();    // Client::on_server_something() will run before
                            // Server::do_something() has completed.

  std::cout &lt;&lt; "After Server::do_something()" &lt;&lt; std::endl;

  return 0;
}
</programlisting>
<para>File: <filename>client.cc</filename> (For use with gtkmm 3, not gtkmm 2)
</para>
<programlisting>
#include "client.h"
#include &lt;iostream&gt;

Client::Client()
{
}

Client::~Client()
{
}

void Client::on_server_something(bool a, int b)
{
  std::cout &lt;&lt; "Client::on_server_something() called with these parameters: "
      &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; std::endl;
}
</programlisting>
<!-- end inserted example code -->

</sect1>

</appendix>




<appendix id="sec-signals-comparison">
<title>Vergleich mit anderen Signalsystemen</title>
<para>

(An aside: <application>GTK+</application> calls this scheme "signalling"; the
sharp-eyed reader with GUI toolkit experience will note that this same design
is often
seen under the name of "broadcaster-listener" (e.g., in Metrowerks'
PowerPlant framework for the Macintosh). It works in much the same
way: one sets up <literal>broadcasters</literal>, and then connects
<literal>listeners</literal> to them; the broadcaster keeps a list of the
objects listening to it, and when someone gives the broadcaster a
message, it calls all of its objects in its list with the message. In
<application>gtkmm</application>, signal objects play the role of broadcasters, and slots
play the role of listeners - sort of. More on this later.)
</para>
<para>
<application>gtkmm</application> signal handlers are strongly-typed, whereas
<application>GTK+</application> C code allows you to connect a callback with
the wrong number and type of arguments, leading to a segfault at runtime. And,
unlike <application>Qt</application>, <application>gtkmm</application> achieves this without modifying
the C++ language.</para>
<para>
Re. Overriding signal handlers: You can do this in the straight-C world of GTK+ too; that's what GTK's
object system is for. But in GTK+, you have to go through some
complicated procedures to get object-oriented features like
inheritance and overloading. In C++, it's simple, since those
features are supported in the language itself; you can let the
compiler do the dirty work.
</para>
<para>
This is one of the places where the beauty of C++ really comes out.
One wouldn't think of subclassing a GTK+ widget simply to override its
action method; it's just too much trouble. In GTK+, you almost always
use signals to get things done, unless you're writing a new widget.
But because overriding methods is so easy in C++, it's entirely
practical - and sensible - to subclass a button for that purpose.
</para>
</appendix>

<appendix id="sec-windows-installation">
        <title><application>gtkmm</application> und Win32</title>
    <para>
      One of the major advantages of <application>gtkmm</application> is that it is crossplatform. <application>gtkmm</application> programs written on other platforms such as
      GNU/Linux can generally be transferred to Windows (and vice
      versa) with few modifications to the source.
    </para>
    <para>
      <application>gtkmm</application> currently works with the <ulink url="http://mingw.org/">MingW/GCC3.4 compiler</ulink> and Microsoft
      Visual C++ 2005 or later (including the freely available express
      editions) on the Windows platform. There is an
      <ulink url="ftp://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm">
      installer</ulink> available for gtkmm on Microsoft Windows. Refer to
      <ulink url="http://live.gnome.org/gtkmm/MSWindows/">
      http://live.gnome.org/gtkmm/MSWindows</ulink> for instructions how to
      use it.
    </para>
  <sect1 id="sec-building-on-win32">
        <title>Erstellen von <application>gtkmm</application> auf Win32</title>
    <para>Please see <ulink url="http://live.gnome.org/gtkmm/MSWindows/BuildingGtkmm">http://live.gnome.org/gtkmm/MSWindows/BuildingGtkmm</ulink> for instructions on how to build gtkmm on Windws.
    </para>

    </sect1>
</appendix>

<appendix id="chapter-working-with-source">
  <title>Arbeiten mit dem Quelltext von gtkmm</title>
  <para>
    If you are interested in helping out with the development of <application>gtkmm</application>, or
    fixing a bug in <application>gtkmm</application>, you'll probably need to build the development
    version of <application>gtkmm</application>. However, you should not to install a development version over
    your stable version. Instead, you should install it alongside your existing <application>gtkmm</application>
    installation, in a separate path.
  </para>
  <para>
    The easiest way to do this is using <ulink url="http://developer.gnome.org/jhbuild/unstable/">jhbuild</ulink>.
    <application>jhbuild</application> is a program that makes building GNOME
    software much easier by calculating dependencies and building things in the
    correct order. This section will give a brief explanation of how to set up
    jhbuild to build and install <application>gtkmm</application> from the source repository (git). For up-to-date information
    on <application>jhbuild</application>, please refer to the <ulink url="http://developer.gnome.org/jhbuild/unstable/">jhbuild manual</ulink>.
    If you need assistance using <application>jhbuild</application>, you should
    ask for help on the <ulink url="http://mail.gnome.org/mailman/listinfo/gnome-love">gnome-love
      mailing list</ulink>.
  </para>
  <note>
    <para>
    Note that to build <application>gtkmm</application> from git, you'll often need to build all of its
    dependencies from git as well. <application>jhbuild</application> makes
    this easier than it would normally be, but it will take quite a while to
    build and install them all. You will probably encounter build problems, though these will usually be corrected quickly if you report them.
    </para>
  </note>
  <sect1 id="sec-setting-up-jhbuild">
    <title>Einrichten von jhbuild</title>
    <para>
      To set up <application>jhbuild</application>, follow the basic
      installation instructions from the <ulink url="http://developer.gnome.org/jhbuild/unstable/">jhbuild manual</ulink>.
      After you've have installd <application>jhbuild</application>, you
      should copy the sample <application>jhbuild</application> configuration
      file into your home directory by executing the following command from the
      <application>jhbuild</application> directory:
      <command>$ cp sample.jhbuildrc ~/.jhbuildrc</command>
    </para>
    <para>
      The <application>gtkmm</application> module is defined in the GNOME moduleset (i.e.
      <filename>gnome-2.xx.modules</filename>, so edit your
      <filename>.jhbuildrc</filename> file and set your moduleset setting to the
      latest version of GNOME like so:
      <programlisting>moduleset = 'gnome-2.30'</programlisting>
    </para>
    <para>
      After setting the correct moduleset, you need to tell
      <application>jhbuild</application> which module or modules to build. To
      build <application>gtkmm</application> and all of its dependencies, set <varname>modules</varname>
      like so: <programlisting>modules = [ 'gtkmm', ]</programlisting>
    </para>
    <para>
      You can build all GNOME C++ modules by setting the
      <varname>modules</varname> variable to the meta-package named
      <literal>meta-gnome-c++</literal> or build all of the core GNOME modules
      with <literal>meta-gnome-desktop</literal>. The
      <varname>modules</varname> variable specifies which modules that will be
      built when you don't explicitly specify anything on the command line. You
      can always build a different moduleset later by specifying it on the
      commandline (e.g. <command>jhbuild build gtkmm</command>).
    </para>
    <important>
      <title>Festlegen eines Präfix</title>
      <para>
        By default, <application>jhbuild</application>'s configuration is
        configured to install all software built with
        <application>jhbuild</application> under the
        <filename>/opt/gnome2</filename> prefix. You can choose a different
        prefix, but it is recommended that you keep this prefix different from
        other software that you've installed (don't set it to
        <filename>/usr</filename>!) If you've followed the jhbuild instructions
        then this prefix belongs to your user, so you don't need to run jhbuild
        as <literal>root</literal>.
      </para>
    </important>
  </sect1>
  <sect1 id="sec-installing-jhbuild">
    <title>Installing and Using the git version of <application>gtkmm</application></title>
    <para>
      Once you've configured <application>jhbuild</application> as described
      above, building <application>gtkmm</application> should be relatively straightforward. The first
      time you run <application>jhbuild</application>, you should run the
      following sequence of commands to ensure that
      <application>jhbuild</application> has the required tools and verify that
      it is set up correctly:
      <screen>$ jhbuild bootstrap
$ jhbuild sanitycheck</screen>
    </para>
    <sect2 id="jhbuild-installing-gtkmm">
      <title>Installation von <application>gtkmm</application> mit <application>jhbuild</application></title>
      <para>
        If everything worked correctly, you should be able to build <application>gtkmm</application> and
        all of its dependencies from git by executing <command>jhbuild
          build</command> (or, if you didn't specify <application>gtkmm</application> in the
        <varname>modules</varname> variable, with the command <command>jhbuild
          build gtkmm</command>).
      </para>
      <para>
        This command will build and install a series of modules and will probably
        take quite a long time the first time through. After the first time,
        however, it should go quite a bit faster since it only needs to rebuild
        files than changed since the last build. Alternatively, after you've
        built and installed <application>gtkmm</application> the first time, you can rebuild <application>gtkmm</application> by
        itself (without rebuilding all of its dependencies) with the command
        <command>jhbuild buildone gtkmm</command>.
      </para>
    </sect2>
    <sect2 id="jhbuild-using-gtkmm">
      <title>Using the git version of <application>gtkmm</application></title>
      <para>
        After you've installed the git version of <application>gtkmm</application>, you're ready to start
        using and experimenting with it. In order to use the new version of
        <application>gtkmm</application> you've just installed, you need to set some environment
        variables so that your <filename>configure</filename> script knows where
        to find the new libraries. Fortunately,
        <application>jhbuild</application> offers an easy solution to this
        problem. Executing the command <command>jhbuild shell</command> will
        start a new shell with all of the correct environment variables set.
        Now if you re-configure and build your project just as you usually do,
        it should link against the newly installed libraries. To return to your
        previous environment, simply exit the <application>jhbuild</application>
        shell.
      </para>
      <para>
        Once you've built your software, you'll need to run your program within
        the jhbuild environment as well. To do this, you can again use the
        <command>jhbuild shell</command> command to start a new shell with the
        <application>jhbuild</application> environment set up. Alternatively,
        you can execute a one-off command in the
        <application>jhbuild</application> environment using the following
        command: <command>jhbuild run command-name</command>. In this case,
        the command will be run with the correct environment variables set, but
        will return to your previous environment after the program exits.
      </para>

    </sect2>
  </sect1>
</appendix>

<appendix id="chapter-wrapping-c-libraries">
<title>Wrapping C Libraries with gmmproc</title>
<para><application>gtkmm</application> uses the <command>gmmproc</command> tool to generate most of its
    source code, using .defs files that define the APIs of
    <classname>GObject</classname>-based libraries. So it's quite easy to create
    additional gtkmm-style wrappers of other glib/GObject-based
    libraries.</para>
<para>This involves a variety of tools, some of them crufty, but it does at
    least work, and has been used successfully by several
    projects.</para>

<sect1 id="sec-wrapping-build-structure">
<title>Die Erstellungsstruktur</title>
<para>Generation of the source code for a gtkmm-style wrapper API requires use
    of tools such as <command>gmmproc</command> and
    <filename>generate_wrap_init.pl</filename>. In theory you could write your
    own build files to use these appropriately, but a much better option is to
    make use of the build infrastructure provided by the mm-common module. To
    get started, it helps a lot to pick an existing binding module as an example
    to look at.</para>
<para>For instance, let's pretend that we are wrapping a C library called
    libexample. It provides a <classname>GObject</classname>-based API with
    types named, for instance, <classname>ExampleThing</classname> and
    <classname>ExampleStuff</classname>.</para>

<sect2 id="copying-skeleton-project">
<title>kopieren des Projektgerüsts</title>

<para>Typically our wrapper library would be called libsomethingmm. We can start by
  copying the <ulink url="http://git.gnome.org/cgit/mm-common/tree/skeletonmm">skeleton
  source tree</ulink> from the mm-common module.
<programlisting>
  $ git clone git://git.gnome.org/mm-common
  $ cp -a mm-common/skeletonmm libsomethingmm
</programlisting>
</para>
<para>This provides a directory structure for the source .hg and .ccg files and the generated .h
  and .cc files, with <filename>filelist.am</filename> Automake include files that can specify the
  various files in use, in terms of generic Automake variables. The directory structure usually
  looks like this, after we have renamed the directories appropriately:
<itemizedlist>
    <listitem><para><filename>libsomethingmm</filename>: Der Ordner der obersten Ebene.</para>
     <itemizedlist>
         <listitem><para><filename>libsomething</filename>: Contains the main include file and the pkg-config .pc file.</para>
         <itemizedlist>
             <listitem><para><filename>src</filename>: Enthält .hg- und .ccg-Quelldateien.</para></listitem>
             <listitem><para><filename>libsomethingmm</filename>: Enthält generierte und handgeschriebene .h- und .cc-Dateien.</para>
             <itemizedlist>
                 <listitem><para><filename>private</filename>: Enthält generierte <filename>*_p.h</filename>-Dateien.</para></listitem>
             </itemizedlist>
           </listitem>
         </itemizedlist>
       </listitem>
    </itemizedlist>
  </listitem>
</itemizedlist>
</para>

<para>As well as renaming the directories, we should rename some of the source
    files. For instance:
<programlisting>
$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \
    d="${f%/*}"; b="${f##*/}"; mv "$f" "$d/${b//skeleton/libsomething}"; \
  done
</programlisting>
A number of the skeleton files must still be filled in with project-specific content later.
</para>
<para>Note that files ending in <filename>.in</filename> will be used to generate
    files with the same name but without the <filename>.in</filename> suffix, by
    replacing some variables with actual values during the configure stage.</para>
</sect2>

<sect2 id="modifying-build-files">
<title>Anpassen der Erstellungsdateien</title>

<para>Now we edit the files to adapt them to to our needs. You might prefer to use a multiple-file
  search-replace utility for this, such as <command>regexxer</command>. Note that nearly all of the
  files provided with the skeleton source tree contain placeholder text. Thus, the substitutions
  should be performed globally, and not be limited to the Automake and Autoconf files.</para>
<para>All mentions of <varname>skeleton</varname> should be replaced by the correct name of the C
  library you are wrapping, such as "something" or "libsomething". In the same manner, all
  instances of <varname>SKELETON</varname> should be replaced by "SOMETHING" or "LIBSOMETHING", and
  all occurrences of <varname>Skeleton</varname> changed to "Something".</para>
<para>Likewise, replace all instances of <varname>Joe Hacker</varname> by the name of the intended
  copyright holder, which is probably you. Do the same for the <varname>joe@example.com</varname>
  email address.</para>

<sect3 id="modifying-configure.ac">
<title>configure.ac</title>
<para>In <filename>configure.ac</filename>, <itemizedlist>
  <listitem><para>The <function>AC_CONFIG_SRCDIR()</function> line must mention a file
      in our source tree. We can edit this later if we don't yet know the
      names of any of the files that we will create.</para></listitem>
  <listitem><para>It is common for binding modules to track the version number
      of the library they are wrapping. So, for instance, if the C library is
      at version 1.23.4, then the initial version of the binding module would
      be 1.23.0. However, avoid starting with an even minor version number as
      that usually indicates a stable release.</para></listitem>
  <listitem><para>The <function>AC_CONFIG_HEADERS()</function> line is used to
      generate two or more configuration header files. The first header file
      in the list contains all configuration macros which are set during the
      configure run. The remaining headers in the list contain only a subset
      of configuration macros and their corresponding <filename>configh.h.in</filename>
      file will not be autogenerated. The reason for this separation is that
      the namespaced configuration headers are installed with your library and
      define publically visible macros.</para></listitem>
  <listitem><para>The <function>AC_SUBST([SOMETHINGMM_MODULES], ['...'])</function>
      line may need to be modified to check for the correct dependencies.</para></listitem>
  <listitem><para>The <function>AC_CONFIG_FILES()</function> block must mention
      the correct directory names, as described above.</para></listitem>
</itemizedlist></para>
</sect3>

<sect3 id="modifying-makefile.am">
<title>Makefile.am-Dateien</title>
<para>Next we must adapt the various <filename>Makefile.am</filename> files:
  <itemizedlist>
    <listitem><para>In <filename>skeleton/src/Makefile.am</filename> we
            must mention the correct values for the generic variables that are used
            elsewhere in the build system:</para>
        <variablelist>
            <varlistentry>
                <term><varname>binding_name</varname></term>
                <listitem><para>Der Name der Bibliothek, wie libsomethingmm.</para></listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>wrap_init_flags</varname></term>
                <listitem><para>Additional command-line flags passed to the
                    <filename>generate_wrap_init.pl</filename> script, such
                    as the C++ namespace and the parent directory prefix of
                    include files.</para></listitem>
            </varlistentry>
        </variablelist>
    </listitem>
    <listitem><para>In <filename>skeleton/skeletonmm/Makefile.am</filename> we
            must mention the correct values for the generic variables that are used
            elsewhere in the build system:</para>
      <variablelist>
        <varlistentry>
          <term><varname>lib_LTLIBRARIES</varname></term>
          <listitem><para>This variable must mention the correct library
              name, and this library name must be used to form the
              <varname>_SOURCES</varname>, <varname>_LDFLAGS</varname>, and
              <varname>_LIBADD</varname> variable names. It is permissible to
              use variables substituted by <filename>configure</filename> like
              <varname>@SOMETHINGMM_API_VERSION@</varname> as part of the
              variable names.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>AM_CPPFLAGS</varname></term>
          <listitem><para>Die an den C-Präprozessor übergebenen Befehlszeilenoptionen.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>AM_CXXFLAGS</varname></term>
          <listitem><para>Die an den C++-Compiler übergebenen Befehlszeilenoptionen.</para></listitem>
        </varlistentry>
      </variablelist>
    </listitem>
  </itemizedlist>
</para>
</sect3>

<sect3 id="creating-hg-ccg">
<title>Erstellen der .hg- und .ccg-Dateien</title>
<para>We should now create our first <filename>.hg</filename> and <filename>.ccg</filename> files,
  to wrap one of the objects in the C library. One pair of example source files already exists:
  <filename>skeleton.ccg</filename> and <filename>skeleton.hg</filename>. Create copies of these
  files as necessary.</para>
<para>We must mention all of our <filename>.hg</filename> and
  <filename>.ccg</filename> files in the
  <filename>skeleton/src/filelist.am</filename> file, typically in the
  <varname>files_hg</varname> variable.</para>
<para>Any additional non-generated <filename>.h</filename> and
  <filename>.cc</filename> source files may be placed in
  <filename>skeleton/skeletonmm/</filename> and listed in
  <filename>skeleton/skeletonmm/filelist.am</filename>, typically in the
  <varname>files_extra_h</varname> and <varname>files_extra_cc</varname>
  variables.</para>
<para>In the <link linkend="sec-wrapping-hg-files">.hg and .ccg files</link>
  section you can learn about the syntax used in these files.</para>
</sect3>
</sect2>
</sect1>

<sect1 id="sec-wrapping-defs-files">
<title>Erstellen der .defs-Dateien.</title>
<para>The <filename>.defs</filename> file are text files, in a lisp format, that describe the API
  of a C library, including its
<itemizedlist>
  <listitem><para>objects (GObjects, widgets, interfaces, boxed-types and plain structs)</para></listitem>
  <listitem><para>functions</para></listitem>
  <listitem><para>enums</para></listitem>
  <listitem><para>signals</para></listitem>
  <listitem><para>properties</para></listitem>
  <listitem><para>vfuncs</para></listitem>
</itemizedlist>
</para>
<para>At the moment, we have separate tools for generating different parts of
  these <filename>.defs</filename>, so we split them up into separate files.
  For instance, in the <filename>gtk/src</filename> directory of the <application>gtkmm</application>
  sources, you will find these files:
    <variablelist>
        <varlistentry>
            <term><filename>gtk.defs</filename></term>
            <listitem><para>Beinhaltet die andren Dateien.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_methods.defs</filename></term>
            <listitem><para>Objekte und Funktionen.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_enums.defs</filename></term>
            <listitem><para>Aufzählungen.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_signals.defs</filename></term>
            <listitem><para>Signale und Eigenschaften.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_vfuncs.defs</filename></term>
            <listitem><para>vfuncs (function pointer member fields in structs), written by hand.</para></listitem>
        </varlistentry>
    </variablelist>
</para>

<sect2 id="generating-defs-methods">
<title>Erzeugen der methods.defs</title>
<para>This <filename>.defs</filename> file describes objects and their functions.
  It is generated by the <command>h2def.py</command> script which you can find in
  pygobject's <filename>codegen</filename> directory. For instance,
<programlisting>
$ ./h2def.py /usr/include/gtk-2.0/gtk/*.h &gt; gtk_methods.defs
</programlisting>
</para>
</sect2>

<sect2 id="generating-defs-enums">
<title>Erzeugen der enums.defs</title>
<para>This <filename>.defs</filename> file describes enum types and their possible
  values. It is generated by the <filename>enum.pl</filename> script which you can
  find in glibmm's <filename>tools</filename> directory. For instance,
<programlisting>
$ ./enum.pl /usr/include/gtk-2.0/gtk/*.h &gt; gtk_enums.defs
</programlisting>
</para>
</sect2>

<sect2 id="generating-defs-signals-properties">
<title>Generating the signals and properties .defs</title>
<para>This <filename>.defs</filename> file describes signals and properties. It is
  generated by the special <filename>extra_defs</filename> utility that is in every
  wrapping project, such as <filename>gtkmm/tools/extra_defs_gen/</filename>.
  For instance
<programlisting>
$ cd tools/extra_defs_gen
$ ./generate_extra_defs &gt; gtk_signals.defs
</programlisting>
</para>
<para>You must edit the source code of your own <filename>generate_extra_defs</filename> tool
  in order to generate the <filename>.defs</filename> for the GObject C types that you wish to
  wrap. In the skeleton source tree, the source file is named
  <filename>codegen/extradefs/generate_extra_defs_skeleton.cc</filename>. If not done so
  already, the file should be renamed, with the basename of your new binding substituted
  for the <varname>skeleton</varname> placeholder. The <filename>codegen/Makefile.am</filename>
  file should also mention the new source filename.</para>
<para>Then edit the <filename>.cc</filename> file to specify the correct types.
  For instance, your <function>main()</function> function might look like this:
<programlisting>
#include &lt;libsomething.h&gt;

int main(int, char**)
{
  something_init();

  std::cout &lt;&lt; get_defs(EXAMPLE_TYPE_SOMETHING)
            &lt;&lt; get_defs(EXAMPLE_TYPE_THING);
  return 0;
}
</programlisting>
</para>
</sect2>

<sect2 id="writing-defs-vfuncs">
<title>Schreiben der vfuncs.defs</title>
<para>
<programlisting>
</programlisting>
</para>
</sect2>

</sect1>

<sect1 id="sec-wrapping-hg-files">
    <title>Die .hg- und .ccg-Dateien</title>
    <para>The .hg and .ccg source files are very much like
        .h and .cc C++ source files, but they contain extra macros, such as
        <function>_CLASS_GOBJECT()</function> and
        <function>_WRAP_METHOD()</function>, from which
        <command>gmmproc</command> generates appropriate C++ source code,
        usually at the same position in the header. Any additional C++ source
        code will be copied verbatim into the corresponding
        .h or .cc file.</para>
    <para>A .hg file will typically include some headers
        and then declare a class, using some macros to add API or behaviour to
        this class. For instance, gtkmm's <filename>button.hg</filename> looks
        roughly like this:

<programlisting>
#include &lt;gtkmm/bin.h&gt;
#include &lt;gtkmm/stockid.h&gt;
_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/bin_p.h)

namespace Gtk
{

class Button : public Bin
{
  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)
public:

  _CTOR_DEFAULT
  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);
  explicit Button(const StockID&amp; stock_id);

  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)

  ...

  _WRAP_SIGNAL(void clicked(), "clicked")

  ...

  _WRAP_PROPERTY("label", Glib::ustring)
};

} // namespace Gtk
</programlisting>
</para>
<para>The macros in this example do the following:
<variablelist>
    <varlistentry>
        <term><function>_DEFS()</function></term>
        <listitem><para>Specifies the destination directry for generated sources, and the name of the main .defs file that <command>gmmproc</command> should parse.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_PINCLUDE()</function></term>
        <listitem><para>Tells <command>gmmproc</command> to include a header from the generated private/button_p.h file.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_CLASS_GTKOBJECT()</function></term>
        <listitem><para>Tells <command>gmmproc</command> to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a GtkObject-derived type.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_WRAP_METHOD()</function>,
            <function>_WRAP_SIGNAL()</function>, and
            <function>_WRAP_PROPERTY()</function></term>
        <listitem><para>Add methods to wrap parts of the C API.</para></listitem>
    </varlistentry>
</variablelist>
</para>
<para>The .h and .cc files will be generated from the .hg and .ccg files by
    processing them with <command>gmmproc</command> like so, though this happens
    automatically when using the above build structure:
<programlisting>
$ cd gtk/src
$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm
</programlisting>
</para>
<para>Notice that we provided <command>gmmproc</command> with the path to the
    .m4 convert files, the path to the .defs file, the name of a .hg file, the
    source directory, and the destination directory.</para>
<para>You should avoid including the C header from your C++ header, to avoid
    polluting the global namespace, and to avoid exporting unnecessary public
    API. But you will need to include the necessary C headers from your
    .ccg file.</para>

<para>The macros are explained in more detail in the following sections.</para>

<sect2 id="gmmproc-m4-conversions">
<title>m4-Umwandlungen</title>
<para>The macros that you use in the .hg and .ccg files often need to know how
to convert a C++ type to a C type, or vice-versa. gmmproc takes this information
from an .m4 file in your <literal>tools/m4/</literal> directory. This allows it
to call a C function in the implementation of your C++ method, passing the
appropriate parameters to that C functon. For instance, this
tells gmmproc how to convert a GtkTreeView pointer to a Gtk::TreeView pointer:
<programlisting>
_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')
</programlisting>
</para>

<para><literal>$3</literal> will be replaced by the parameter name when this
conversion is used by gmmproc.
</para>

<para>
Some extra macros make this easier and consistent. Look in gtkmm's .m4 files
for examples. For instance:
<programlisting>
_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)
_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)
_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))
</programlisting>
</para>
</sect2>


<sect2 id="gmmproc-class-macros">
<title>Klassen-Makros</title>
<para>The class macro declares the class itself and its relationship with the
    underlying C type. It generates some internal constructors, the member
    <varname>gobject_</varname>, typedefs, the <function>gobj()</function>
    accessors, type registration, and the <function>Glib::wrap()</function>
    method, among other things.</para>
<para>Other macros, such as <function>_WRAP_METHOD()</function> and
    <function>_SIGNAL()</function> may only be used after a call to a
    <function>_CLASS_*</function> macro.</para>

<sect3 id="gmmproc-class-gobject">
<title>_CLASS_GOBJECT</title>
<para>This macro declares a wrapper for a type that is derived from
    <classname>GObject</classname>, but which is not derived from
    <classname>GtkObject</classname>.</para>
<para><function>_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )</function></para>
<para>For instance, from <filename>accelgroup.hg</filename>:
<programlisting>
_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-gtkobject">
<title>_CLASS_GTKOBJECT</title>
<para>This macro declares a wrapper for a type that is derived from
    <classname>GtkObject</classname>, such as a widget or dialog.</para>
<para><function>_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )</function></para>
<para>For instance, from <filename>button.hg</filename>:
<programlisting>
_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-boxedtype">
<title>_CLASS_BOXEDTYPE</title>
<para>This macro declares a wrapper for a non-<classname>GObject</classname>
    struct, registered with
    <function>g_boxed_type_register_static()</function>.</para>
<para><function>_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )</function></para>
<para>For instance, for <classname>Gdk::Color</classname>:
<programlisting>
_CLASS_BOXEDTYPE(Color, GdkColor, NONE, gdk_color_copy, gdk_color_free)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-boxedtype-static">
<title>_CLASS_BOXEDTYPE_STATIC</title>
<para>This macro declares a wrapper for a simple assignable struct such as
    <classname>GdkRectangle</classname>. It is similar to
    <function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated
    dynamically.</para>
<para><function>_CLASS_BOXEDTYPE_STATIC( C++-Klasse, C-Klasse )</function></para>
<para>For instance, for <classname>Gdk::Rectangle</classname>:
<programlisting>
_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-opaque-copyable">
<title>_CLASS_OPAQUE_COPYABLE</title>
<para>This macro declares a wrapper for an opaque struct that has copy and free
    functions. The new, copy and free functions will be used to instantiate the
    default constructor, copy constructor and destructor.</para>
<para><function>_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )</function></para>
<para>For instance, for <classname>Gdk::Region</classname>:
<programlisting>
_CLASS_OPAQUE_COPYABLE(Region, GdkRegion, gdk_region_new, gdk_region_copy, gdk_region_destroy)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-opaque-refcounted">
<title>_CLASS_OPAQUE_REFCOUNTED</title>
<para>This macro declares a wrapper for a reference-counted opaque struct. The
    C++ wrapper cannot be directly instantiated and can only be used with
    <classname>Glib::RefPtr</classname>.</para>
<para><function>_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, ref function, unref function )</function></para>
<para>For instance, for <classname>Pango::Coverage</classname>:
<programlisting>
_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-generic">
<title>_CLASS_GENERIC</title>
<para>This macro can be used to wrap structs which don't fit into any
    specialized category.</para>
<para><function>_CLASS_GENERIC( C++-Klasse, C-Klasse )</function></para>
<para>For instance, for <classname>Pango::AttrIter</classname>:
<programlisting>
_CLASS_GENERIC(AttrIter, PangoAttrIterator)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-class-interface">
<title>_CLASS_INTERFACE</title>
<para>This macro declares a wrapper for a type that is derived from
    <classname>GObject</classname>, but which is not derived from
    <classname>GtkObject</classname>.
</para>
<para><function>_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )</function></para>
<para>
For instance, from <filename>celleditable.hg</filename>:
<programlisting>
  _CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)
</programlisting>
</para>
<para>Two extra parameters are optional, for the case that the interface derives from another interface,
which should be the case when the GInterface has another GInterface as a prerequisitite.
For instance, from <filename>loadableicon.hg</filename>:
<programlisting>
  _CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)
</programlisting>
</para>
</sect3>


</sect2>

<sect2 id="gmmproc-constructor-macros">
<title>Konstruktor-Makros</title>
<para>The <function>_CTOR_DEFAULT()</function> and
    <function>_WRAP_CTOR()</function> macros add constructors, wrapping the
    specified <function>*_new()</function> C functions. These macros assume that
    the C object has properties with the same names as the function parameters,
    as is usually the case, so that it can supply the parameters directly to a
    <function>g_object_new()</function> call. These constructors never actually
    call the <function>*_new()</function> C functions,
    because gtkmm must actually instantiate derived GTypes, and the
    <function>*_new()</function> C functions are meant only as convenience
    functions for C programmers.</para>
<para>When using <function>_CLASS_GOBJECT()</function>, the constructors should
    be protected (rather than public) and each constructor should have a
    corresponding <function>_WRAP_CREATE()</function> in the public section.
    This prevents the class from being instantiated without using a
    <classname>RefPtr</classname>. For instance:
<programlisting>
class ActionGroup : public Glib::Object
{
  _CLASS_GOBJECT(ActionGroup, GtkActionGroup, GTK_ACTION_GROUP, Glib::Object, GObject)

protected:
  _WRAP_CTOR(ActionGroup(const Glib::ustring&amp; name = Glib::ustring()), gtk_action_group_new)

public:
  _WRAP_CREATE(const Glib::ustring&amp; name = Glib::ustring())
</programlisting>
</para>

<sect3 id="gmmproc-ctor-default">
<title>_CTOR_DEFAULT</title>
<para>This macro creates a default constructor with no arguments.
</para>
</sect3>

<sect3 id="gmmproc-wrap-ctor">
<title>_WRAP_CTOR</title>
<para>This macro creates a constructor with arguments, equivalent to a
  <function>*_new()</function> C function. It won't actually call the
  <function>*_new()</function> function, but will simply create an equivalent
  constructor with the same argument types. It takes a C++ constructor
  signature, and a C function name.
</para>
</sect3>

<sect3 id="gmmproc-ctor-manual">
<title>Handgeschriebene Konstruktoren</title>
<para>When a constructor must be partly hand written because, for instance, the
    <function>*_new()</function> C function's parameters do not correspond
    directly to object properties, or because the <function>*_new()</function> C
    function does more than call <function>g_object_new()</function>, the
    <function>_CONSTRUCT()</function> macro may be used in the
    .ccg file to save some work. The <function>_CONSTRUCT</function> macro takes
    a series of property names and values. For instance, from
    <filename>button.ccg</filename>:
<programlisting>
Button::Button(const Glib::ustring&amp; label, bool mnemonic)
:
  _CONSTRUCT("label", label.c_str(), "use_underline", gboolean(mnemonic))
{}
</programlisting>
</para>
</sect3>

</sect2>

<sect2 id="gmmproc-method-macros">
<title>Methoden-Makros</title>

<sect3 id="gmmproc-wrap-method">
<title>_WRAP_METHOD</title>
<para>This macro generates the C++ method to wrap a C function.</para>
<para><function>_WRAP_METHOD( C++ method signature, C function name)</function></para>
<para>For instance, from <filename>entry.hg</filename>:
<programlisting>
_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)
</programlisting>
</para>
<para>The C function (e.g. <function>gtk_entry_set_text</function>) is described
    more fully in the .defs file, and the <filename>convert*.m4</filename> files
    contain the necessary conversion from the C++ parameter type to the C
    parameter type. This macro also generates doxygen documentation comments
    based on the <filename>*_docs.xml</filename> and
    <filename>*_docs_override.xml</filename> files.</para>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>refreturn</term>
        <listitem>
            <para>Do an extra reference() on the return value, in case the C
                function does not provide a reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>errthrow</term>
        <listitem>
            <para>Use the last GError* parameter of the C function to
                throw an exception.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>deprecated</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional
                parameter.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>constversion</term>
        <listitem>
            <para>Just call the non-const version of the same function,
                instead of generating almost duplicate code.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
<para>Though it's usually obvious what C++ types should be used in the C++ method, here are some hints:
<itemizedlist>
    <listitem><para>Objects used via <classname>RefPtr</classname>: Pass the
            <classname>RefPtr</classname> as a const reference. For instance,
            <code>const Glib::RefPtr&lt;Gtk::Action&gt;&amp;
                action</code>.</para></listitem>
    <listitem><para>Const Objects used via <classname>RefPtr</classname>: If the
            object should not be changed by the function, then make sure that
            the object is const, even if the <classname>RefPtr</classname> is
            already const. For instance, <code>const Glib::RefPtr&lt;const
            Gtk::Action&gt;&amp; action</code>.</para></listitem>
<listitem><para>Wrapping <classname>GList*</classname> and
        <classname>GSList*</classname> parameters: First, you need to discover
        what objects are contained in the list's data field for each item,
        usually by reading the documentation for the C function. The list can
        then be wrapped by a <classname>std::vector</classname> type.
        For instance, <code>std::vector&lt;
        Glib::RefPtr&lt;Action&gt; &gt;</code>.
        You may need to define a Traits type to specify how the C
        and C++ types should be converted.</para></listitem>
<listitem><para>Wrapping <classname>GList*</classname> and
        <classname>GSList*</classname> return types: You must discover whether
        the caller should free the list and whether it should release the items
        in the list, again by reading the documentation of the C function. With
        this information you can choose the ownership (none, shallow or deep)
        for the m4 conversion rule, which you should probably put directly into
        the .hg file because the ownership depends on the
        function rather than the type. For instance:
<programlisting>#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')</programlisting></para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="gmmproc-wrap-method-docs-only">
<title>_WRAP_METHOD_DOCS_ONLY</title>
<para>This macro is like <function>_WRAP_METHOD()</function>, but it generates
    only the documentation for a  C++ method that wraps a C function. Use this
    when you must hand-code the method, but you want to use the documentation
    that would be generated if the method was generated.</para>
<para><function>_WRAP_METHOD_DOCS_ONLY(C-Funktionsname)</function></para>
<para>For instance, from <filename>container.hg</filename>:
<programlisting>
_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-ignore">
<title>_IGNORE()</title>
<para><command>gmmproc</command> will warn you on stdout about functions that
    you have forgotten to wrap, helping to ensure that you are wrapping the
    complete API. Buf if you don't want to wrap some functions or if you chose
    to hand-code some methods then you can use the _IGNORE() macro the make
    <command>gmmproc</command> stop complaining.</para>
<para><function>_IGNORE(C-Funktionsname 1, C-Funktionsname2, usw.)</function></para>
<para>For instance, from <filename>buttonbox.hg</filename>:
<programlisting>
_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing,
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-wrap-signal">
<title>_WRAP_SIGNAL</title>
<para>This macro generates the C++ libsigc++-style signal to wrap a C GObject
    signal. It actually generates a public accessor method, such as
    <function>signal_clicked()</function>, which returns a proxy object.
    <command>gmmproc</command> uses the .defs file to discover the C parameter
    types and the .m4 convert files to discover appropriate type
    conversions.</para>
<para><function>_WRAP_SIGNAL( C++ signal handler signature, C signal name)</function></para>
<para>For instance, from <filename>button.hg</filename>:
<programlisting>
_WRAP_SIGNAL(void clicked(),"clicked")
</programlisting>
</para>
<para>Signals usually have function pointers in the GTK struct, with a
    corresponding enum value. and a <function>g_signal_new()</function> in the
    .c file.</para>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>no_default_handler</term>
        <listitem>
            <para>Do not generate an <function>on_something()</function> virtual
                method to allow easy overriding of the default signal handler.
                Use this when adding a signal with a default signal handler
                would break the ABI by increasing the size of the class's
                virtual function table.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
</sect3>

<sect3 id="gmmproc-wrap-property">
<title>_WRAP_PROPERTY</title>
<para>This macro generates the C++ method to wrap a C GObject property. You must
    specify the property name and the wanted C++ type for the property. <command>gmmproc</command>
    uses the .defs file to discover the C type and the .m4 convert files to
    discover appropriate type conversions.</para>
<para><function>_WRAP_PROPERTY(C-Eigenschaftsname, C++-Typ)</function></para>
<para>For instance, from <filename>button.hg</filename>:
<programlisting>
_WRAP_PROPERTY("label", Glib::ustring)
</programlisting>
</para>
</sect3>

</sect2>

<sect2 id="gmmproc-other-macros">
<title>Weitere Makros</title>
<sect3 id="gmmproc-wrap-enum">
<title>_WRAP_ENUM</title>
<para>This macro generates a C++ enum to wrap a C enum. You must specify the desired C++ name and
    the name of the underlying C enum.</para>
<para>For instance, from <filename>widget.hg</filename>:
<programlisting>
_WRAP_ENUM(WindowType, GdkWindowType)
</programlisting>
</para>
<para>If the enum is not a <classname>GType</classname>, you must pass a third parameter NO_GTYPE.
  This is the case when there is no <function>*_get_type()</function> function for the C enum, but
  be careful that you don't just need to include an extra header for that function. You should also
  file a bug against the C API, because all enums should be registered as GTypes.</para>
<para>Zum Beispiel: <programlisting>
_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags)
</programlisting></para>
</sect3>

<sect3 id="gmmproc-wrap-gerror">
<title>_WRAP_GERROR</title>
<para>This macro generates a C++ exception class, derived from Glib::Error, with
a Code enum and a code() method. You must specify the desired C++ name, the name
of the corresponding C enum, and the prefix for the C enum values.</para>
<para>This exception can then be thrown by methods which are generated from _WRAP_METHOD() with the errthrow option.</para>
<para>For instance, from <filename>pixbuf.hg</filename>:
<programlisting>
_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)
</programlisting>
</para>
</sect3>

<sect3 id="gmmproc-member-set-get">
    <title>_MEMBER_GET / _MEMBER_SET</title>
  <para>
    Use these macros if you're wrapping a simple struct or boxed type that provides
    direct access to its data members, to create getters and setters for the data members.
  </para>
  <para><function>_MEMBER_GET(C++-Name, C-Name, C++-Typ, C-Typ)</function></para>
  <para><function>_MEMBER_SET(C++-Name, C-Name, C++-Typ, C-Typ)</function></para>
  <para>Beispielsweise in <filename>rectangle.hg</filename>: <programlisting>_MEMBER_GET(x, x, int, int)</programlisting></para>
</sect3>
<sect3 id="gmmproc-member-get-set-ptr">
  <title>_MEMBER_GET_PTR / _MEMBER_SET_PTR</title>
  <para>
    Use these macros to automatically provide getters and setters for a data
    member that is a pointer type. For the getter function, it will
    create two methods, one const and one non-const.
  </para>
  <para><function>_MEMBER_GET_PTR(C++-Name, C-Name, C++-Typ, C-Typ)</function></para>
  <para><function>_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)</function></para>
  <para>Zum Beispiel in <filename>progress.hg</filename>: <programlisting>
_MEMBER_GET_PTR(vbox, vbox, VBox*, GtkWidget*)
</programlisting></para>
</sect3>
<sect3 id="gmmproc-member-get-set-gobject">
  <title>_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT</title>
  <para>
    Use this macro to provide getters and setters for a data member that is a
    <classname>GObject</classname> type that must be referenced before being
    returned.
  </para>
  <para><function>_MEMBER_GET_GOBJECT(C++-Name, C-Name, C++-Typ, C-Typ)</function></para>
  <para><function>_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)</function></para>
  <para>Zum Beispiel in <filename>progress.hg</filename>: <programlisting>
_MEMBER_GET_GOBJECT(offscreen_pixmap, offscreen_pixmap, Gdk::Pixmap, GdkPixmap*)
</programlisting></para>
</sect3>
</sect2>
<sect2 id="gmmproc-basic-types">
  <title>Grundlegende Typen</title>
  <para>Some of the basic types that are used in C APIs have better alternatives
    in C++. For example, there's no need for a <type>gboolean</type> type since
    C++ has <type>bool</type>. The following list shows some commonly-used
    types in C APIs and what you might convert them to in a C++ wrapper library.
  </para>
  <segmentedlist><title>Grundlegende Typ-Äquivalente</title>
    <?dbhtml list-presentation="table"?>
    <segtitle>C-Typ</segtitle>
    <segtitle>C++-Typ</segtitle>
    <seglistitem><seg><type>gboolean</type></seg><seg><type>bool</type></seg></seglistitem>
    <seglistitem><seg><type>gint</type></seg><seg><type>int</type></seg></seglistitem>
    <seglistitem><seg><type>guint</type></seg><seg><type>guint</type></seg></seglistitem>
    <seglistitem><seg><type>gdouble</type></seg><seg><type>double</type></seg></seglistitem>
    <seglistitem><seg><type>gunichar</type></seg><seg><type>gunichar</type></seg></seglistitem>
    <seglistitem><seg><type>gchar*</type></seg><seg><classname>Glib::ustring</classname> (oder <classname>std::string</classname> für Dateinamen)</seg></seglistitem>
  </segmentedlist>
</sect2>
</sect1>


<sect1 id="sec-wrapping-hand-coded-files">
<title>Handgeschriebene Quelldateien</title>
<para>You might want to include additional source files that will not be
  generated by <command>gmmproc</command> from <filename>.hg</filename> and
  <filename>.ccg</filename> files. You can simply place these in your
  <filename>libsomething/libsomethingmm</filename> directory and mention them
  in the <filename>Makefile.am</filename> in the
  <varname>files_extra_h</varname> and <varname>files_extra_cc</varname>
  variables.</para>
</sect1>

<sect1 id="sec-wrapping-initialization">
<title>Initialisierung</title>
<para>Your library must be initialized before it can be used, to register the
    new types that it makes available. Also, the C library that you are wrapping
    might have its own initialization function that you should call. You can do
    this in an <function>init()</function> function that you can place in
    hand-coded <filename>init.h</filename> and <filename>init.cc</filename>
    files. This function should initialize your dependencies (such as the C
    function, and <application>gtkmm</application>) and call your generated
    <function>wrap_init()</function> function. For instance:
<programlisting>
void init()
{
  Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.
  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.
}
</programlisting>
</para>
<para>The implementation of the <function>wrap_init()</function> method in
    <filename>wrap_init.cc</filename> is generated by
    <filename>generate_wrap_init.pl</filename>, but the declaration in
    <filename>wrap_init.h</filename> is hand-coded, so you will need to adjust
    <filename>wrap_init.h</filename> so that the <function>init()</function>
    function appears in the correct C++ namespace.</para>
</sect1>

<sect1 id="sec-wrapping-problems">
<title>Probleme in der C-API.</title>
<para>You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common problems, with solutions.</para>
<sect2 id="wrapping-predeclare-structs">
<title>Unable to predeclare structs</title>
<para>By convention, structs are declared in glib/GTK+-style headers like so:
<programlisting>
typedef struct _ExampleWidget ExampleWidget;

struct _ExampleWidget
{
  ...
};
</programlisting>
</para>
<para>The extra typedef allows the struct to be used in a header without including its full defintion, simply by predeclaring it, by repeating that typedef. This means that you don't have to include the C library's header in your C++ header, thus keeping it out of your public API. <command>gmmproc</command> assumes that this technique was used, so you will see compiler errors if that is not the case.</para>
<para>
This compiler error might look like this:
<programlisting>
example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'
../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here
make[4]: *** [example-widget.lo] Error 1
</programlisting>
or this:
<programlisting>
example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol
../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'
</programlisting>
</para>
<para>This is easy to correct in the C library, so do send a patch to the relevant maintainer.</para>
</sect2>

<sect2 id="wrapping-no-properties">
<title>Fehlende Eigenschaften</title>
<para>By convention, glib/GTK+-style objects have <function>*_new()</function>
    functions, such as <function>example_widget_new()</function> that do nothing
    more than call <function>g_object_new()</function> and return the result.
    The input parameters are supplied to <function>g_object_new()</function>
    along with the names of the properties for which they are values. For
    instance,
<programlisting>
GtkWidget* example_widget_new(int something, const char* thing)
{
        return g_object_new (EXAMPLE_TYPE_WIDGET, "something", something, "thing", thing, NULL);
}
</programlisting>
</para>
<para>This allows language bindings to implement their own equivalents (such as
    C++ constructors), without using the <function>*_new()</function> function.
    This is often necessary so that they can actually instantiate a derived
    GType, to add their own hooks for signal handlers and vfuncs.</para>
<para>At the least, the <function>_new()</function> function should not use any
    private API (functions that are only in a .c file). Even when there are no
    functions, we can sometimes reimplement 2 or 3 lines of code in a
    <function>_new()</function> function as long as those lines of code use API
    that is available to us.</para>
<para>Another workaround is to add a <function>*_construct()</function> function
    that the C++ constructor can call after instantiating its own type. For
    instance,
<programlisting>
GtkWidget* example_widget_new(int something, const char* thing)
{
        ExampleWidget* widget;
        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);
        example_widget_construct(widget, "something", something, "thing", thing);
}

void example_widget_construct(ExampleWidget* widget, int something, const char* thing)
{
        //Do stuff that uses private API:
        widget-&gt;priv-&gt;thing = thing;
        do_something(something);
}
</programlisting>
</para>
<para>Adding properties, and ensuring that they interact properly with each
    other, is relatively difficult to correct in the C library, but it is
    possible, so do file a bug and try to send a patch to the relevant
    maintainer.</para>
</sect2>
</sect1>

<sect1 id="sec-wrapping-documentation">
<title>Dokumentation</title>
<para>In general, gtkmm-style projects use Doxygen, which reads specially formatted C++ comments and generates HTML documentation. You may write these doxygen comments directly in the header files.</para>

<sect2 id="wrapping-reusing-c-documentation">
<title>Die C-Dokumentation wiederverwenden</title>
<para>You might wish to reuse documentation that exists for the C library that you are wrapping. GTK-style C libraries typically use gtk-doc and therefore have source code comments formatted for gtk-doc and some extra documentation in .tmpl files. The docextract_to_xml.py script, from pygobject's codegen directory, can read these files and generate an .xml file that <command>gmmproc</command> can use to generate doxygen comments. <command>gmmproc</command> will even try to transform the documentation to make it more appropriate for a C++ API.</para>
<para>Zum Beispiel, <programlisting>./docextract_to_xml.py -s /gnome/head/cvs/gtk+/gtk/ -s /gnome/head/cvs/gtk+/docs/reference/gtk/tmpl/ &gt; gtk_docs.xml
</programlisting></para>
<para>Because this automatic transformation is not always appropriate, you might
    want to provide hand-written text for a particular method. You can do this
    by copying the XML node for the function from your
    <filename>something_docs.xml</filename> file to the
    <filename>something_docs_override.xml</filename> file and changing the
    contents.</para>
</sect2>

<sect2 id="wrapping-documentation-build-structure">
<title>Struktur zur Dokumentationserstellung</title>
<para>If you copied the skeleton source tree in mm-common and substituted the
  placeholder text, then you will already have suitable <filename>Makefile.am</filename>
  and <filename>Doxyfile.in</filename> files. With the mm-common build setup, the list
  of Doxygen input files is not defined in the Doxygen configuration file, but passed
  along from <command>make</command> to the standard input of <command>doxygen</command>.
  The input file list is defined by the <varname>doc_input</varname> variable in the
  <filename>Makefile.am</filename> file.
</para>
</sect2>

</sect1>

</appendix>

</book>
<!-- some vim settings
    vim:ts=2 sw=2 et
-->
